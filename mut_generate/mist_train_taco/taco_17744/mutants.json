{
  "task_id": "taco_17744",
  "entry_point": "find_best_representation",
  "mutant_count": 176,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000008",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000008\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000006",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000006\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 0",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 0\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = -1000000007",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = -1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "t = -1",
      "mutated_line": "t = +1",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = +1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if t == -1:",
      "mutated_line": "return (1, 1)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t != -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "t = -1",
      "mutated_line": "t = -2",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -2\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "t = -1",
      "mutated_line": "t = -0",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -0\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "t = -1",
      "mutated_line": "t = -0",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -0\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "t = -1",
      "mutated_line": "t = --1",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = --1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "z = [0] * m",
      "mutated_line": "z = [0] / m",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] / m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "z = [0] * m",
      "mutated_line": "z = [0] + m",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] + m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "z = [0] * m",
      "mutated_line": "z = [0] ** m",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] ** m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 1\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "c = 0",
      "mutated_line": "c = -1",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = -1\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 1\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "f = [1] * m",
      "mutated_line": "f = [1] / m",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] / m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "f = [1] * m",
      "mutated_line": "f = [1] + m",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] + m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "f = [1] * m",
      "mutated_line": "f = [1] ** m",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] ** m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, n // 2 + 1):",
      "mutated_line": "for j in range(2, n // 2 + 1):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(2, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, n // 2 + 1):",
      "mutated_line": "for j in range(0, n // 2 + 1):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(0, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, n // 2 + 1):",
      "mutated_line": "for j in range(0, n // 2 + 1):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(0, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, n // 2 + 1):",
      "mutated_line": "for j in range(-1, n // 2 + 1):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(-1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for j in range(1, n // 2 + 1):",
      "mutated_line": "for j in range(1, n // 2 - 1):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 - 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for j in range(1, n // 2 + 1):",
      "mutated_line": "for j in range(1, n // 2 * 1):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 * 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if n % j == 0 and w[:n - j] == w[j:]:",
      "mutated_line": "if n % j == 0 or w[:n - j] == w[j:]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 or w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "if t == -1:",
      "mutated_line": "return (1, 1)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == +1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "elif t == 1:",
      "mutated_line": "elif t != 1:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t != 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, m):",
      "mutated_line": "for i in range(2, m):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(2, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, m):",
      "mutated_line": "for i in range(0, m):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(0, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, m):",
      "mutated_line": "for i in range(0, m):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(0, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, m):",
      "mutated_line": "for i in range(-1, m):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(-1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if i + z[i - c] < c + z[c]:",
      "mutated_line": "if i + z[i - c] <= c + z[c]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] <= c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if i + z[i - c] < c + z[c]:",
      "mutated_line": "if i + z[i - c] >= c + z[c]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] >= c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if i + z[i - c] < c + z[c]:",
      "mutated_line": "if i + z[i - c] != c + z[c]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] != c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for p in range(1, m):",
      "mutated_line": "for p in range(2, m):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(2, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for p in range(1, m):",
      "mutated_line": "for p in range(0, m):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(0, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for p in range(1, m):",
      "mutated_line": "for p in range(0, m):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(0, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for p in range(1, m):",
      "mutated_line": "for p in range(-1, m):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(-1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for j in range(1, n // 2 + 1):",
      "mutated_line": "for j in range(1, n / 2 + 1):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n / 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for j in range(1, n // 2 + 1):",
      "mutated_line": "for j in range(1, n * 2 + 1):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n * 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, n // 2 + 1):",
      "mutated_line": "for j in range(1, n // 2 + 2):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 2):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, n // 2 + 1):",
      "mutated_line": "for j in range(1, n // 2 + 0):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 0):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, n // 2 + 1):",
      "mutated_line": "for j in range(1, n // 2 + 0):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 0):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, n // 2 + 1):",
      "mutated_line": "for j in range(1, n // 2 + -1):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + -1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if n % j == 0 and w[:n - j] == w[j:]:",
      "mutated_line": "if n % j != 0 and w[:n - j] == w[j:]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j != 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if n % j == 0 and w[:n - j] == w[j:]:",
      "mutated_line": "if n % j == 0 and w[:n - j] != w[j:]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] != w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if t == -1:",
      "mutated_line": "return (1, 1)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -2:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if t == -1:",
      "mutated_line": "return (1, 1)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -0:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if t == -1:",
      "mutated_line": "return (1, 1)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -0:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if t == -1:",
      "mutated_line": "return (1, 1)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == --1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 1, 1",
      "mutated_line": "return (2, 1)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (2, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 1, 1",
      "mutated_line": "return (0, 1)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (0, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 1, 1",
      "mutated_line": "return (0, 1)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (0, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 1, 1",
      "mutated_line": "return (-1, 1)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (-1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 1, 1",
      "mutated_line": "return (1, 2)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 2)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 1, 1",
      "mutated_line": "return (1, 0)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 0)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 1, 1",
      "mutated_line": "return (1, 0)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 0)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 1, 1",
      "mutated_line": "return (1, -1)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, -1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "elif t == 1:",
      "mutated_line": "elif t == 2:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 2:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "elif t == 1:",
      "mutated_line": "elif t == 0:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 0:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "elif t == 1:",
      "mutated_line": "elif t == 0:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 0:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "elif t == 1:",
      "mutated_line": "elif t == -1:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == -1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 1\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = -1",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = -1\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 1\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "z = [0] * m",
      "mutated_line": "z = [1] * m",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [1] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "z = [0] * m",
      "mutated_line": "z = [-1] * m",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [-1] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "z = [0] * m",
      "mutated_line": "z = [1] * m",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [1] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "f = [1] * m",
      "mutated_line": "f = [2] * m",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [2] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "f = [1] * m",
      "mutated_line": "f = [0] * m",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [0] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "f = [1] * m",
      "mutated_line": "f = [0] * m",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [0] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "f = [1] * m",
      "mutated_line": "f = [-1] * m",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [-1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if i + z[i - c] < c + z[c]:",
      "mutated_line": "if i - z[i - c] < c + z[c]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i - z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if i + z[i - c] < c + z[c]:",
      "mutated_line": "if i * z[i - c] < c + z[c]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i * z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if i + z[i - c] < c + z[c]:",
      "mutated_line": "if i + z[i - c] < c - z[c]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c - z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if i + z[i - c] < c + z[c]:",
      "mutated_line": "if i + z[i - c] < c * z[c]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c * z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "while i + j < n and s[j] == s[i + j]:",
      "mutated_line": "while i + j < n or s[j] == s[i + j]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n or s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j -= 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for k in range(2, z[p] // p + 2):",
      "mutated_line": "for k in range(3, z[p] // p + 2):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(3, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for k in range(2, z[p] // p + 2):",
      "mutated_line": "for k in range(1, z[p] // p + 2):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(1, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for k in range(2, z[p] // p + 2):",
      "mutated_line": "for k in range(0, z[p] // p + 2):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(0, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for k in range(2, z[p] // p + 2):",
      "mutated_line": "for k in range(1, z[p] // p + 2):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(1, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for k in range(2, z[p] // p + 2):",
      "mutated_line": "for k in range(-2, z[p] // p + 2):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(-2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for k in range(2, z[p] // p + 2):",
      "mutated_line": "for k in range(2, z[p] // p - 2):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p - 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for k in range(2, z[p] // p + 2):",
      "mutated_line": "for k in range(2, z[p] // p * 2):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p * 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "f[k * p - 1] = 0",
      "mutated_line": "f[k * p - 1] = 1",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 1\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "f[k * p - 1] = 0",
      "mutated_line": "f[k * p - 1] = -1",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = -1\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "f[k * p - 1] = 0",
      "mutated_line": "f[k * p - 1] = 1",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 1\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, n // 2 + 1):",
      "mutated_line": "for j in range(1, n // 3 + 1):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 3 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, n // 2 + 1):",
      "mutated_line": "for j in range(1, n // 1 + 1):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 1 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, n // 2 + 1):",
      "mutated_line": "for j in range(1, n // 0 + 1):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 0 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, n // 2 + 1):",
      "mutated_line": "for j in range(1, n // 1 + 1):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 1 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(1, n // 2 + 1):",
      "mutated_line": "for j in range(1, n // -2 + 1):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // -2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if n % j == 0 and w[:n - j] == w[j:]:",
      "mutated_line": "if n * j == 0 and w[:n - j] == w[j:]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n * j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if n % j == 0 and w[:n - j] == w[j:]:",
      "mutated_line": "if n + j == 0 and w[:n - j] == w[j:]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n + j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n % j == 0 and w[:n - j] == w[j:]:",
      "mutated_line": "if n % j == 1 and w[:n - j] == w[j:]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 1 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n % j == 0 and w[:n - j] == w[j:]:",
      "mutated_line": "if n % j == -1 and w[:n - j] == w[j:]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == -1 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if n % j == 0 and w[:n - j] == w[j:]:",
      "mutated_line": "if n % j == 1 and w[:n - j] == w[j:]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 1 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return n, 1",
      "mutated_line": "return (n, 2)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 2)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return n, 1",
      "mutated_line": "return (n, 0)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 0)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return n, 1",
      "mutated_line": "return (n, 0)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 0)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return n, 1",
      "mutated_line": "return (n, -1)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, -1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(0, n - 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(1, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(0, n - 1):",
      "mutated_line": "for i in range(-1, n - 1):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(-1, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(0, n - 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(1, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "for i in range(0, n - 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n + 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "for i in range(0, n - 1):",
      "mutated_line": "for i in range(0, n * 1):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n * 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "LCR",
      "lineno": 39,
      "original_line": "if zl[i] and zr[n - 2 - i]:",
      "mutated_line": "if zl[i] or zr[n - 2 - i]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] or zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt -= 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 2, cnt % MOD",
      "mutated_line": "return (3, cnt % MOD)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (3, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 2, cnt % MOD",
      "mutated_line": "return (1, cnt % MOD)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (1, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 2, cnt % MOD",
      "mutated_line": "return (0, cnt % MOD)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (0, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 2, cnt % MOD",
      "mutated_line": "return (1, cnt % MOD)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (1, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 2, cnt % MOD",
      "mutated_line": "return (-2, cnt % MOD)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (-2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return 2, cnt % MOD",
      "mutated_line": "return (2, cnt * MOD)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt * MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return 2, cnt % MOD",
      "mutated_line": "return (2, cnt + MOD)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt + MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "z[i] = z[i - c]",
      "mutated_line": "z[i] = z[i + c]",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i + c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "z[i] = z[i - c]",
      "mutated_line": "z[i] = z[i * c]",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i * c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "j = max(0, c + z[c] - i)",
      "mutated_line": "j = max(1, c + z[c] - i)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(1, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "j = max(0, c + z[c] - i)",
      "mutated_line": "j = max(-1, c + z[c] - i)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(-1, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "j = max(0, c + z[c] - i)",
      "mutated_line": "j = max(1, c + z[c] - i)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(1, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "j = max(0, c + z[c] - i)",
      "mutated_line": "j = max(0, c + z[c] + i)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] + i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "j = max(0, c + z[c] - i)",
      "mutated_line": "j = max(0, (c + z[c]) * i)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, (c + z[c]) * i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while i + j < n and s[j] == s[i + j]:",
      "mutated_line": "while i + j <= n and s[j] == s[i + j]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j <= n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while i + j < n and s[j] == s[i + j]:",
      "mutated_line": "while i + j >= n and s[j] == s[i + j]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j >= n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while i + j < n and s[j] == s[i + j]:",
      "mutated_line": "while i + j != n and s[j] == s[i + j]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j != n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while i + j < n and s[j] == s[i + j]:",
      "mutated_line": "while i + j < n and s[j] != s[i + j]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] != s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 2\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 0\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 0\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += -1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for k in range(2, z[p] // p + 2):",
      "mutated_line": "for k in range(2, z[p] / p + 2):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] / p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for k in range(2, z[p] // p + 2):",
      "mutated_line": "for k in range(2, z[p] * p + 2):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] * p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for k in range(2, z[p] // p + 2):",
      "mutated_line": "for k in range(2, z[p] // p + 3):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 3):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for k in range(2, z[p] // p + 2):",
      "mutated_line": "for k in range(2, z[p] // p + 1):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 1):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for k in range(2, z[p] // p + 2):",
      "mutated_line": "for k in range(2, z[p] // p + 0):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 0):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for k in range(2, z[p] // p + 2):",
      "mutated_line": "for k in range(2, z[p] // p + 1):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 1):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for k in range(2, z[p] // p + 2):",
      "mutated_line": "for k in range(2, z[p] // p + -2):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + -2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "f[k * p - 1] = 0",
      "mutated_line": "f[k * p + 1] = 0",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p + 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "f[k * p - 1] = 0",
      "mutated_line": "f[k * p * 1] = 0",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p * 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(0, n - 1):",
      "mutated_line": "for i in range(0, n - 2):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 2):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(0, n - 1):",
      "mutated_line": "for i in range(0, n - 0):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 0):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(0, n - 1):",
      "mutated_line": "for i in range(0, n - 0):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 0):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(0, n - 1):",
      "mutated_line": "for i in range(0, n - -1):",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - -1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 2\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 0\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 0\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += -1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if i + z[i - c] < c + z[c]:",
      "mutated_line": "if i + z[i + c] < c + z[c]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i + c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if i + z[i - c] < c + z[c]:",
      "mutated_line": "if i + z[i * c] < c + z[c]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i * c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "j = max(0, c + z[c] - i)",
      "mutated_line": "j = max(0, c - z[c] - i)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c - z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "j = max(0, c + z[c] - i)",
      "mutated_line": "j = max(0, c * z[c] - i)",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c * z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "while i + j < n and s[j] == s[i + j]:",
      "mutated_line": "while i - j < n and s[j] == s[i + j]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i - j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "while i + j < n and s[j] == s[i + j]:",
      "mutated_line": "while i * j < n and s[j] == s[i + j]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i * j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "f[k * p - 1] = 0",
      "mutated_line": "f[k / p - 1] = 0",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k / p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "f[k * p - 1] = 0",
      "mutated_line": "f[k + p - 1] = 0",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k + p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "f[k * p - 1] = 0",
      "mutated_line": "f[k ** p - 1] = 0",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k ** p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "f[k * p - 1] = 0",
      "mutated_line": "f[k * p - 2] = 0",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 2] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "f[k * p - 1] = 0",
      "mutated_line": "f[k * p - 0] = 0",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 0] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "f[k * p - 1] = 0",
      "mutated_line": "f[k * p - 0] = 0",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 0] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "f[k * p - 1] = 0",
      "mutated_line": "f[k * p - -1] = 0",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - -1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if n % j == 0 and w[:n - j] == w[j:]:",
      "mutated_line": "if n % j == 0 and w[:n + j] == w[j:]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n + j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if n % j == 0 and w[:n - j] == w[j:]:",
      "mutated_line": "if n % j == 0 and w[:n * j] == w[j:]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n * j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if zl[i] and zr[n - 2 - i]:",
      "mutated_line": "if zl[i] and zr[n - 2 + i]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 + i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if zl[i] and zr[n - 2 - i]:",
      "mutated_line": "if zl[i] and zr[(n - 2) * i]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[(n - 2) * i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "while i + j < n and s[j] == s[i + j]:",
      "mutated_line": "while i + j < n and s[j] == s[i - j]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i - j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "while i + j < n and s[j] == s[i + j]:",
      "mutated_line": "while i + j < n and s[j] == s[i * j]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i * j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if zl[i] and zr[n - 2 - i]:",
      "mutated_line": "if zl[i] and zr[n + 2 - i]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n + 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if zl[i] and zr[n - 2 - i]:",
      "mutated_line": "if zl[i] and zr[n * 2 - i]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n * 2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if zl[i] and zr[n - 2 - i]:",
      "mutated_line": "if zl[i] and zr[n - 3 - i]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 3 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if zl[i] and zr[n - 2 - i]:",
      "mutated_line": "if zl[i] and zr[n - 1 - i]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 1 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if zl[i] and zr[n - 2 - i]:",
      "mutated_line": "if zl[i] and zr[n - 0 - i]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 0 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if zl[i] and zr[n - 2 - i]:",
      "mutated_line": "if zl[i] and zr[n - 1 - i]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - 1 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if zl[i] and zr[n - 2 - i]:",
      "mutated_line": "if zl[i] and zr[n - -2 - i]:",
      "code": "def find_best_representation(w: str) -> tuple[int, int]:\n    MOD = 1000000007\n    n = len(w)\n    t = -1\n\n    def Z(s: list[str]) -> list[int]:\n        m = len(s)\n        z = [0] * m\n        c = 0\n        f = [1] * m\n        for i in range(1, m):\n            if i + z[i - c] < c + z[c]:\n                z[i] = z[i - c]\n            else:\n                j = max(0, c + z[c] - i)\n                while i + j < n and s[j] == s[i + j]:\n                    j += 1\n                z[i] = j\n                c = i\n        for p in range(1, m):\n            for k in range(2, z[p] // p + 2):\n                f[k * p - 1] = 0\n        return f\n    for j in range(1, n // 2 + 1):\n        if n % j == 0 and w[:n - j] == w[j:]:\n            t = j\n            break\n    if t == -1:\n        return (1, 1)\n    elif t == 1:\n        return (n, 1)\n    else:\n        zl = Z(list(w))\n        zr = Z(list(reversed(w)))\n        cnt = 0\n        for i in range(0, n - 1):\n            if zl[i] and zr[n - -2 - i]:\n                cnt += 1\n        return (2, cnt % MOD)"
    }
  ]
}