{
  "task_id": "taco_14141",
  "entry_point": "find_min_cost_painting",
  "mutant_count": 157,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans = [0] * n",
      "mutated_line": "ans = [0] / n",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] / n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans = [0] * n",
      "mutated_line": "ans = [0] + n",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] + n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ans = [0] * n",
      "mutated_line": "ans = [0] ** n",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] ** n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "w = 0",
      "mutated_line": "w = 1",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 1\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "w = 0",
      "mutated_line": "w = -1",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = -1\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "w = 0",
      "mutated_line": "w = 1",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 1\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ansi = 1",
      "mutated_line": "ansi = 2",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 2\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ansi = 1",
      "mutated_line": "ansi = 0",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 0\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ansi = 1",
      "mutated_line": "ansi = 0",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 0\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ansi = 1",
      "mutated_line": "ansi = -1",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = -1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "cost[1][ansi] += c1[v]",
      "mutated_line": "cost[1][ansi] -= c1[v]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] -= c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "cost[2][ansi] += c2[v]",
      "mutated_line": "cost[2][ansi] -= c2[v]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] -= c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "cost[3][ansi] += c3[v]",
      "mutated_line": "cost[3][ansi] -= c3[v]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] -= c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if pal[3] == float('inf'):",
      "mutated_line": "if pal[3] != float('inf'):",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] != float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if len(tree[u]) > 2:",
      "mutated_line": "if len(tree[u]) >= 2:",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) >= 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if len(tree[u]) > 2:",
      "mutated_line": "if len(tree[u]) <= 2:",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) <= 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if len(tree[u]) > 2:",
      "mutated_line": "if len(tree[u]) != 2:",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) != 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if len(tree[u]) == 1:",
      "mutated_line": "if len(tree[u]) != 1:",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) != 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ansi = (ansi + 1) % 3",
      "mutated_line": "ansi = (ansi + 1) * 3",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) * 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ansi = (ansi + 1) % 3",
      "mutated_line": "ansi = ansi + 1 + 3",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = ansi + 1 + 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if len(tree[v]) == 1:",
      "mutated_line": "if len(tree[v]) != 1:",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) != 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "UOI",
      "lineno": 49,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return +1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if len(tree[u]) > 2:",
      "mutated_line": "if len(tree[u]) > 3:",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 3:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if len(tree[u]) > 2:",
      "mutated_line": "if len(tree[u]) > 1:",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 1:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if len(tree[u]) > 2:",
      "mutated_line": "if len(tree[u]) > 0:",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 0:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if len(tree[u]) > 2:",
      "mutated_line": "if len(tree[u]) > 1:",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 1:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if len(tree[u]) > 2:",
      "mutated_line": "if len(tree[u]) > -2:",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > -2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return +1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if len(tree[u]) == 1:",
      "mutated_line": "if len(tree[u]) == 2:",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 2:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if len(tree[u]) == 1:",
      "mutated_line": "if len(tree[u]) == 0:",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 0:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if len(tree[u]) == 1:",
      "mutated_line": "if len(tree[u]) == 0:",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 0:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if len(tree[u]) == 1:",
      "mutated_line": "if len(tree[u]) == -1:",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == -1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = [0] * n",
      "mutated_line": "ans = [1] * n",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [1] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = [0] * n",
      "mutated_line": "ans = [-1] * n",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [-1] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ans = [0] * n",
      "mutated_line": "ans = [1] * n",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [1] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "cost = [[0, 0, 0] for _ in range(4)]",
      "mutated_line": "cost = [[1, 0, 0] for _ in range(4)]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[1, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "cost = [[0, 0, 0] for _ in range(4)]",
      "mutated_line": "cost = [[-1, 0, 0] for _ in range(4)]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[-1, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "cost = [[0, 0, 0] for _ in range(4)]",
      "mutated_line": "cost = [[1, 0, 0] for _ in range(4)]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[1, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "cost = [[0, 0, 0] for _ in range(4)]",
      "mutated_line": "cost = [[0, 1, 0] for _ in range(4)]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 1, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "cost = [[0, 0, 0] for _ in range(4)]",
      "mutated_line": "cost = [[0, -1, 0] for _ in range(4)]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, -1, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "cost = [[0, 0, 0] for _ in range(4)]",
      "mutated_line": "cost = [[0, 1, 0] for _ in range(4)]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 1, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "cost = [[0, 0, 0] for _ in range(4)]",
      "mutated_line": "cost = [[0, 0, 1] for _ in range(4)]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 1] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "cost = [[0, 0, 0] for _ in range(4)]",
      "mutated_line": "cost = [[0, 0, -1] for _ in range(4)]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, -1] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "cost = [[0, 0, 0] for _ in range(4)]",
      "mutated_line": "cost = [[0, 0, 1] for _ in range(4)]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 1] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ansi = (ansi + 1) % 3",
      "mutated_line": "ansi = (ansi - 1) % 3",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi - 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ansi = (ansi + 1) % 3",
      "mutated_line": "ansi = ansi * 1 % 3",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = ansi * 1 % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ansi = (ansi + 1) % 3",
      "mutated_line": "ansi = (ansi + 1) % 4",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 4\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ansi = (ansi + 1) % 3",
      "mutated_line": "ansi = (ansi + 1) % 2",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 2\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ansi = (ansi + 1) % 3",
      "mutated_line": "ansi = (ansi + 1) % 0",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 0\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ansi = (ansi + 1) % 3",
      "mutated_line": "ansi = (ansi + 1) % 1",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 1\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ansi = (ansi + 1) % 3",
      "mutated_line": "ansi = (ansi + 1) % -3",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % -3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if len(tree[v]) == 1:",
      "mutated_line": "if len(tree[v]) == 2:",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 2:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if len(tree[v]) == 1:",
      "mutated_line": "if len(tree[v]) == 0:",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 0:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if len(tree[v]) == 1:",
      "mutated_line": "if len(tree[v]) == 0:",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 0:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if len(tree[v]) == 1:",
      "mutated_line": "if len(tree[v]) == -1:",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == -1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if pal[3] == float('inf'):",
      "mutated_line": "if pal[4] == float('inf'):",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[4] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if pal[3] == float('inf'):",
      "mutated_line": "if pal[2] == float('inf'):",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[2] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if pal[3] == float('inf'):",
      "mutated_line": "if pal[0] == float('inf'):",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[0] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if pal[3] == float('inf'):",
      "mutated_line": "if pal[1] == float('inf'):",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[1] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if pal[3] == float('inf'):",
      "mutated_line": "if pal[-3] == float('inf'):",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[-3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if pal[3] == float('inf'):",
      "mutated_line": "if pal[3] == float(''):",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float(''):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -2\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -0\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -0\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return --1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -2\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -0\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -0\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return --1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "cost = [[0, 0, 0] for _ in range(4)]",
      "mutated_line": "cost = [[0, 0, 0] for _ in range(5)]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(5)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "cost = [[0, 0, 0] for _ in range(4)]",
      "mutated_line": "cost = [[0, 0, 0] for _ in range(3)]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(3)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "cost = [[0, 0, 0] for _ in range(4)]",
      "mutated_line": "cost = [[0, 0, 0] for _ in range(0)]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(0)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "cost = [[0, 0, 0] for _ in range(4)]",
      "mutated_line": "cost = [[0, 0, 0] for _ in range(1)]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(1)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "cost = [[0, 0, 0] for _ in range(4)]",
      "mutated_line": "cost = [[0, 0, 0] for _ in range(-4)]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(-4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cost[1][ansi] += c1[v]",
      "mutated_line": "cost[2][ansi] += c1[v]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[2][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cost[1][ansi] += c1[v]",
      "mutated_line": "cost[0][ansi] += c1[v]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[0][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cost[1][ansi] += c1[v]",
      "mutated_line": "cost[0][ansi] += c1[v]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[0][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cost[1][ansi] += c1[v]",
      "mutated_line": "cost[-1][ansi] += c1[v]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[-1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost[2][ansi] += c2[v]",
      "mutated_line": "cost[3][ansi] += c2[v]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[3][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost[2][ansi] += c2[v]",
      "mutated_line": "cost[1][ansi] += c2[v]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[1][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost[2][ansi] += c2[v]",
      "mutated_line": "cost[0][ansi] += c2[v]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[0][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost[2][ansi] += c2[v]",
      "mutated_line": "cost[1][ansi] += c2[v]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[1][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cost[2][ansi] += c2[v]",
      "mutated_line": "cost[-2][ansi] += c2[v]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[-2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cost[3][ansi] += c3[v]",
      "mutated_line": "cost[4][ansi] += c3[v]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[4][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cost[3][ansi] += c3[v]",
      "mutated_line": "cost[2][ansi] += c3[v]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[2][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cost[3][ansi] += c3[v]",
      "mutated_line": "cost[0][ansi] += c3[v]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[0][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cost[3][ansi] += c3[v]",
      "mutated_line": "cost[1][ansi] += c3[v]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[1][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cost[3][ansi] += c3[v]",
      "mutated_line": "cost[-3][ansi] += c3[v]",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[-3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ansi = (ansi + 1) % 3",
      "mutated_line": "ansi = (ansi + 2) % 3",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 2) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ansi = (ansi + 1) % 3",
      "mutated_line": "ansi = (ansi + 0) % 3",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 0) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ansi = (ansi + 1) % 3",
      "mutated_line": "ansi = (ansi + 0) % 3",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 0) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ansi = (ansi + 1) % 3",
      "mutated_line": "ansi = (ansi + -1) % 3",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + -1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] - cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] - cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2])",
      "mutated_line": "pal = min(((p1, p2, p3, (cost[p1][0] + cost[p2][1]) * cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, (cost[p1][0] + cost[p2][1]) * cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if p1 != p2",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 == p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 == p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return pal[3], [pal[ansi] for ansi in ans]",
      "mutated_line": "return (pal[4], [pal[ansi] for ansi in ans])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[4], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return pal[3], [pal[ansi] for ansi in ans]",
      "mutated_line": "return (pal[2], [pal[ansi] for ansi in ans])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[2], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return pal[3], [pal[ansi] for ansi in ans]",
      "mutated_line": "return (pal[0], [pal[ansi] for ansi in ans])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[0], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return pal[3], [pal[ansi] for ansi in ans]",
      "mutated_line": "return (pal[1], [pal[ansi] for ansi in ans])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[1], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return pal[3], [pal[ansi] for ansi in ans]",
      "mutated_line": "return (pal[-3], [pal[ansi] for ansi in ans])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[-3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] - cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] - cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] * cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] * cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for p1 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (2, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (2, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for p1 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (0, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (0, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for p1 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (0, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (0, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for p1 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (-1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (-1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for p1 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 3, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 3, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for p1 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 1, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 1, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for p1 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 0, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 0, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for p1 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 1, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 1, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for p1 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, -2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, -2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for p1 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 4) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 4) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for p1 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 2) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 2) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for p1 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 0) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 0) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for p1 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 1) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 1) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "for p1 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, -3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, -3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for p2 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (2, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (2, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for p2 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (0, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (0, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for p2 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (0, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (0, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for p2 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (-1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (-1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for p2 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 3, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 3, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for p2 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 1, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 1, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for p2 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 0, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 0, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for p2 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 1, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 1, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for p2 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, -2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, -2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for p2 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 4) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 4) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for p2 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 2) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 2) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for p2 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 0) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 0) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for p2 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 1) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 1) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for p2 in (1, 2, 3)",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, -3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, -3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 + p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 + p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in ((6 - p1) * p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in ((6 - p1) * p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[4])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[4])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[2])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[2])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[0])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[0])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[1])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[1])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[-3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[-3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][3]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][3]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][1]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][1]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][0]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][0]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][1]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][1]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][-2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][-2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 + p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 + p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 * p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 * p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "(v, w) = (next((x for x in tree[v] if x != w)), v)",
      "mutated_line": "(v, w) = (next((x for x in tree[v] if x == w)), v)",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x == w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][1] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][1] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][-1] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][-1] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][1] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][1] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][2] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][2] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][0] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][0] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][0] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][0] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][-1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][-1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (7 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (7 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (5 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (5 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (0 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (0 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (1 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (1 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "for p3 in (6 - p1 - p2,)), key=lambda x: x[3])",
      "mutated_line": "pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (-6 - p1 - p2,)), key=lambda x: x[3])",
      "code": "def find_min_cost_painting(n, c1, c2, c3, edges):\n    from itertools import chain\n    tree = [[] for _ in range(n)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    for u in range(n):\n        if len(tree[u]) > 2:\n            return -1\n    for u in range(n):\n        if len(tree[u]) == 1:\n            v = u\n            break\n    ans = [0] * n\n    cost = [[0, 0, 0] for _ in range(4)]\n    w = 0\n    ansi = 1\n    for _ in range(n):\n        ans[v] = ansi\n        cost[1][ansi] += c1[v]\n        cost[2][ansi] += c2[v]\n        cost[3][ansi] += c3[v]\n        ansi = (ansi + 1) % 3\n        if len(tree[v]) == 1:\n            w = v\n            (v,) = tree[v]\n        else:\n            (v, w) = (next((x for x in tree[v] if x != w)), v)\n    pal = min(((p1, p2, p3, cost[p1][0] + cost[p2][1] + cost[p3][2]) for p1 in (1, 2, 3) for p2 in (1, 2, 3) if p1 != p2 for p3 in (-6 - p1 - p2,)), key=lambda x: x[3])\n    if pal[3] == float('inf'):\n        return -1\n    else:\n        return (pal[3], [pal[ansi] for ansi in ans])"
    }
  ]
}