{
  "task_id": "taco_14468",
  "entry_point": "reconstruct_array",
  "mutant_count": 12,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "subset_sums.pop(0)  # Remove the 0 which corresponds to the empty subset",
      "mutated_line": "subset_sums.pop(1)",
      "code": "import heapq\n\ndef reconstruct_array(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, subset_sums) = case\n        subset_sums.sort()\n        subset_sums.pop(1)\n        ans = []\n        pq = []\n        subsets = []\n        for val in subset_sums:\n            if pq and val == pq[0]:\n                heapq.heappop(pq)\n            else:\n                ans.append(val)\n                for i in range(len(subsets)):\n                    subsets.append(subsets[i] + val)\n                    heapq.heappush(pq, subsets[i] + val)\n                subsets.append(val)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "subset_sums.pop(0)  # Remove the 0 which corresponds to the empty subset",
      "mutated_line": "subset_sums.pop(-1)",
      "code": "import heapq\n\ndef reconstruct_array(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, subset_sums) = case\n        subset_sums.sort()\n        subset_sums.pop(-1)\n        ans = []\n        pq = []\n        subsets = []\n        for val in subset_sums:\n            if pq and val == pq[0]:\n                heapq.heappop(pq)\n            else:\n                ans.append(val)\n                for i in range(len(subsets)):\n                    subsets.append(subsets[i] + val)\n                    heapq.heappush(pq, subsets[i] + val)\n                subsets.append(val)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "subset_sums.pop(0)  # Remove the 0 which corresponds to the empty subset",
      "mutated_line": "subset_sums.pop(1)",
      "code": "import heapq\n\ndef reconstruct_array(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, subset_sums) = case\n        subset_sums.sort()\n        subset_sums.pop(1)\n        ans = []\n        pq = []\n        subsets = []\n        for val in subset_sums:\n            if pq and val == pq[0]:\n                heapq.heappop(pq)\n            else:\n                ans.append(val)\n                for i in range(len(subsets)):\n                    subsets.append(subsets[i] + val)\n                    heapq.heappush(pq, subsets[i] + val)\n                subsets.append(val)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "if pq and val == pq[0]:",
      "mutated_line": "if pq or val == pq[0]:",
      "code": "import heapq\n\ndef reconstruct_array(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, subset_sums) = case\n        subset_sums.sort()\n        subset_sums.pop(0)\n        ans = []\n        pq = []\n        subsets = []\n        for val in subset_sums:\n            if pq or val == pq[0]:\n                heapq.heappop(pq)\n            else:\n                ans.append(val)\n                for i in range(len(subsets)):\n                    subsets.append(subsets[i] + val)\n                    heapq.heappush(pq, subsets[i] + val)\n                subsets.append(val)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if pq and val == pq[0]:",
      "mutated_line": "if pq and val != pq[0]:",
      "code": "import heapq\n\ndef reconstruct_array(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, subset_sums) = case\n        subset_sums.sort()\n        subset_sums.pop(0)\n        ans = []\n        pq = []\n        subsets = []\n        for val in subset_sums:\n            if pq and val != pq[0]:\n                heapq.heappop(pq)\n            else:\n                ans.append(val)\n                for i in range(len(subsets)):\n                    subsets.append(subsets[i] + val)\n                    heapq.heappush(pq, subsets[i] + val)\n                subsets.append(val)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if pq and val == pq[0]:",
      "mutated_line": "if pq and val == pq[1]:",
      "code": "import heapq\n\ndef reconstruct_array(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, subset_sums) = case\n        subset_sums.sort()\n        subset_sums.pop(0)\n        ans = []\n        pq = []\n        subsets = []\n        for val in subset_sums:\n            if pq and val == pq[1]:\n                heapq.heappop(pq)\n            else:\n                ans.append(val)\n                for i in range(len(subsets)):\n                    subsets.append(subsets[i] + val)\n                    heapq.heappush(pq, subsets[i] + val)\n                subsets.append(val)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if pq and val == pq[0]:",
      "mutated_line": "if pq and val == pq[-1]:",
      "code": "import heapq\n\ndef reconstruct_array(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, subset_sums) = case\n        subset_sums.sort()\n        subset_sums.pop(0)\n        ans = []\n        pq = []\n        subsets = []\n        for val in subset_sums:\n            if pq and val == pq[-1]:\n                heapq.heappop(pq)\n            else:\n                ans.append(val)\n                for i in range(len(subsets)):\n                    subsets.append(subsets[i] + val)\n                    heapq.heappush(pq, subsets[i] + val)\n                subsets.append(val)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if pq and val == pq[0]:",
      "mutated_line": "if pq and val == pq[1]:",
      "code": "import heapq\n\ndef reconstruct_array(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, subset_sums) = case\n        subset_sums.sort()\n        subset_sums.pop(0)\n        ans = []\n        pq = []\n        subsets = []\n        for val in subset_sums:\n            if pq and val == pq[1]:\n                heapq.heappop(pq)\n            else:\n                ans.append(val)\n                for i in range(len(subsets)):\n                    subsets.append(subsets[i] + val)\n                    heapq.heappush(pq, subsets[i] + val)\n                subsets.append(val)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "subsets.append(subsets[i] + val)",
      "mutated_line": "subsets.append(subsets[i] - val)",
      "code": "import heapq\n\ndef reconstruct_array(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, subset_sums) = case\n        subset_sums.sort()\n        subset_sums.pop(0)\n        ans = []\n        pq = []\n        subsets = []\n        for val in subset_sums:\n            if pq and val == pq[0]:\n                heapq.heappop(pq)\n            else:\n                ans.append(val)\n                for i in range(len(subsets)):\n                    subsets.append(subsets[i] - val)\n                    heapq.heappush(pq, subsets[i] + val)\n                subsets.append(val)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "subsets.append(subsets[i] + val)",
      "mutated_line": "subsets.append(subsets[i] * val)",
      "code": "import heapq\n\ndef reconstruct_array(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, subset_sums) = case\n        subset_sums.sort()\n        subset_sums.pop(0)\n        ans = []\n        pq = []\n        subsets = []\n        for val in subset_sums:\n            if pq and val == pq[0]:\n                heapq.heappop(pq)\n            else:\n                ans.append(val)\n                for i in range(len(subsets)):\n                    subsets.append(subsets[i] * val)\n                    heapq.heappush(pq, subsets[i] + val)\n                subsets.append(val)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "heapq.heappush(pq, subsets[i] + val)",
      "mutated_line": "heapq.heappush(pq, subsets[i] - val)",
      "code": "import heapq\n\ndef reconstruct_array(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, subset_sums) = case\n        subset_sums.sort()\n        subset_sums.pop(0)\n        ans = []\n        pq = []\n        subsets = []\n        for val in subset_sums:\n            if pq and val == pq[0]:\n                heapq.heappop(pq)\n            else:\n                ans.append(val)\n                for i in range(len(subsets)):\n                    subsets.append(subsets[i] + val)\n                    heapq.heappush(pq, subsets[i] - val)\n                subsets.append(val)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "heapq.heappush(pq, subsets[i] + val)",
      "mutated_line": "heapq.heappush(pq, subsets[i] * val)",
      "code": "import heapq\n\ndef reconstruct_array(T, test_cases):\n    results = []\n    for case in test_cases:\n        (N, subset_sums) = case\n        subset_sums.sort()\n        subset_sums.pop(0)\n        ans = []\n        pq = []\n        subsets = []\n        for val in subset_sums:\n            if pq and val == pq[0]:\n                heapq.heappop(pq)\n            else:\n                ans.append(val)\n                for i in range(len(subsets)):\n                    subsets.append(subsets[i] + val)\n                    heapq.heappush(pq, subsets[i] * val)\n                subsets.append(val)\n        results.append(ans)\n    return results"
    }
  ]
}