{
  "task_id": "taco_703",
  "entry_point": "min_operators_to_target",
  "mutant_count": 68,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return dp(math.ceil(math.log(target, x)), target) - 1",
      "mutated_line": "return dp(math.ceil(math.log(target, x)), target) + 1",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) + 1"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return dp(math.ceil(math.log(target, x)), target) - 1",
      "mutated_line": "return dp(math.ceil(math.log(target, x)), target) * 1",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) * 1"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i == 0:",
      "mutated_line": "if i != 0:",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i != 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if j == 1:",
      "mutated_line": "if j != 1:",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j != 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if (i, j) in memo:",
      "mutated_line": "if (i, j) not in memo:",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) not in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "base = x ** i",
      "mutated_line": "base = x * i",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x * i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "base = x ** i",
      "mutated_line": "base = x + i",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x + i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if r == 0:",
      "mutated_line": "if r != 0:",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r != 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return dp(math.ceil(math.log(target, x)), target) - 1",
      "mutated_line": "return dp(math.ceil(math.log(target, x)), target) - 2",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 2"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return dp(math.ceil(math.log(target, x)), target) - 1",
      "mutated_line": "return dp(math.ceil(math.log(target, x)), target) - 0",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return dp(math.ceil(math.log(target, x)), target) - 1",
      "mutated_line": "return dp(math.ceil(math.log(target, x)), target) - 0",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 0"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return dp(math.ceil(math.log(target, x)), target) - 1",
      "mutated_line": "return dp(math.ceil(math.log(target, x)), target) - -1",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if i == 0:",
      "mutated_line": "if i == 1:",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 1:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if i == 0:",
      "mutated_line": "if i == -1:",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == -1:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if i == 0:",
      "mutated_line": "if i == 1:",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 1:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return 2 * j",
      "mutated_line": "return 2 / j",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 / j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return 2 * j",
      "mutated_line": "return 2 + j",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 + j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return 2 * j",
      "mutated_line": "return 2 ** j",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 ** j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if j == 1:",
      "mutated_line": "if j == 2:",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 2:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if j == 1:",
      "mutated_line": "if j == 0:",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 0:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if j == 1:",
      "mutated_line": "if j == 0:",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 0:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if j == 1:",
      "mutated_line": "if j == -1:",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == -1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 2",
      "mutated_line": "return 3",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 3\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 2",
      "mutated_line": "return 1",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 1\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 2",
      "mutated_line": "return 0",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 0\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 2",
      "mutated_line": "return 1",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 1\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 2",
      "mutated_line": "return -2",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return -2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if r == 0:",
      "mutated_line": "if r == 1:",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 1:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if r == 0:",
      "mutated_line": "if r == -1:",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == -1:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if r == 0:",
      "mutated_line": "if r == 1:",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 1:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return q * i",
      "mutated_line": "return q / i",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q / i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return q * i",
      "mutated_line": "return q + i",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q + i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return q * i",
      "mutated_line": "return q ** i",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q ** i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i - dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i - dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i * dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i * dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i - dp(i - 1, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i - dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i * dp(i - 1, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i * dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 2 * j",
      "mutated_line": "return 3 * j",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 3 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 2 * j",
      "mutated_line": "return 1 * j",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 1 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 2 * j",
      "mutated_line": "return 0 * j",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 0 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 2 * j",
      "mutated_line": "return 1 * j",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 1 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return 2 * j",
      "mutated_line": "return -2 * j",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return -2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q / i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q / i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q + i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q + i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q ** i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q ** i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) / i + dp(i - 1, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) / i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i + dp(i - 1, r), q + 1 + i + dp(i - 1, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), q + 1 + i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) ** i + dp(i - 1, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) ** i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i + dp(i + 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i + 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i + dp(i * 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i * 1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q - 1) * i + dp(i - 1, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q - 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i + dp(i - 1, r), q * 1 * i + dp(i - 1, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), q * 1 * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i + 1, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i + 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i * 1, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i * 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base + r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base + r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base * r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base * r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i + dp(i - 2, r), (q + 1) * i + dp(i - 1, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 2, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i + dp(i - 0, r), (q + 1) * i + dp(i - 1, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 0, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i + dp(i - 0, r), (q + 1) * i + dp(i - 1, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 0, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i + dp(i - -1, r), (q + 1) * i + dp(i - 1, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - -1, r), (q + 1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 2) * i + dp(i - 1, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 2) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 0) * i + dp(i - 1, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 0) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 0) * i + dp(i - 1, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 0) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + -1) * i + dp(i - 1, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + -1) * i + dp(i - 1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 2, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 2, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 0, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 0, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 0, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 0, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - 1, base - r))",
      "mutated_line": "memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - -1, base - r))",
      "code": "import math\n\ndef min_operators_to_target(x: int, target: int) -> int:\n\n    def dp(i, j):\n        if i == 0:\n            return 2 * j\n        if j == 1:\n            return 2\n        if (i, j) in memo:\n            return memo[i, j]\n        base = x ** i\n        (q, r) = divmod(j, base)\n        if r == 0:\n            return q * i\n        memo[i, j] = min(q * i + dp(i - 1, r), (q + 1) * i + dp(i - -1, base - r))\n        return memo[i, j]\n    memo = {}\n    return dp(math.ceil(math.log(target, x)), target) - 1"
    }
  ]
}