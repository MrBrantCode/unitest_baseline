{
  "task_id": "taco_18516",
  "entry_point": "calculate_minimum_total_distance",
  "mutant_count": 76,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result1 = sum(distt) * 2 + min1 - (0 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 - (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result1 = (sum(distt) * 2 + min1) * (0 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = (sum(distt) * 2 + min1) * (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result2 = sum(distt) * 2 + min1 - (0 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 - (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result2 = (sum(distt) * 2 + min1) * (0 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = (sum(distt) * 2 + min1) * (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "distamt = [dista[i] - distt[i] for i in range(n)]",
      "mutated_line": "distamt = [dista[i] + distt[i] for i in range(n)]",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] + distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "distamt = [dista[i] - distt[i] for i in range(n)]",
      "mutated_line": "distamt = [dista[i] * distt[i] for i in range(n)]",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] * distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "distbmt = [distb[i] - distt[i] for i in range(n)]",
      "mutated_line": "distbmt = [distb[i] + distt[i] for i in range(n)]",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] + distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "distbmt = [distb[i] - distt[i] for i in range(n)]",
      "mutated_line": "distbmt = [distb[i] * distt[i] for i in range(n)]",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] * distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result1 = sum(distt) * 2 - min1 + (0 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 - min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result1 = sum(distt) * 2 * min1 + (0 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 * min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result2 = sum(distt) * 2 - min1 + (0 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 - min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result2 = sum(distt) * 2 * min1 + (0 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 * min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt(a * a + b * b)",
      "mutated_line": "return math.sqrt(a * a - b * b)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a - b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt(a * a + b * b)",
      "mutated_line": "return math.sqrt(a * a * (b * b))",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a * (b * b))\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if i in skipi:",
      "mutated_line": "if i not in skipi:",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i not in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "if result is None or l[i] < result:",
      "mutated_line": "if result is None and l[i] < result:",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None and l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "distt = [hyp(x - tx, y - ty) for x, y in bottles]",
      "mutated_line": "dista = [hyp(x - ax, y - ay) for (x, y) in bottles]",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x + tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "distt = [hyp(x - tx, y - ty) for x, y in bottles]",
      "mutated_line": "dista = [hyp(x - ax, y - ay) for (x, y) in bottles]",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x * tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "distt = [hyp(x - tx, y - ty) for x, y in bottles]",
      "mutated_line": "dista = [hyp(x - ax, y - ay) for (x, y) in bottles]",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y + ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "distt = [hyp(x - tx, y - ty) for x, y in bottles]",
      "mutated_line": "dista = [hyp(x - ax, y - ay) for (x, y) in bottles]",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y * ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dista = [hyp(x - ax, y - ay) for x, y in bottles]",
      "mutated_line": "distb = [hyp(x - bx, y - by) for (x, y) in bottles]",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x + ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dista = [hyp(x - ax, y - ay) for x, y in bottles]",
      "mutated_line": "distb = [hyp(x - bx, y - by) for (x, y) in bottles]",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x * ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dista = [hyp(x - ax, y - ay) for x, y in bottles]",
      "mutated_line": "distb = [hyp(x - bx, y - by) for (x, y) in bottles]",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y + ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "dista = [hyp(x - ax, y - ay) for x, y in bottles]",
      "mutated_line": "distb = [hyp(x - bx, y - by) for (x, y) in bottles]",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y * ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distb = [hyp(x - bx, y - by) for x, y in bottles]",
      "mutated_line": "distb = [hyp(x + bx, y - by) for (x, y) in bottles]",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x + bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distb = [hyp(x - bx, y - by) for x, y in bottles]",
      "mutated_line": "distb = [hyp(x * bx, y - by) for (x, y) in bottles]",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x * bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distb = [hyp(x - bx, y - by) for x, y in bottles]",
      "mutated_line": "distb = [hyp(x - bx, y + by) for (x, y) in bottles]",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y + by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "distb = [hyp(x - bx, y - by) for x, y in bottles]",
      "mutated_line": "distb = [hyp(x - bx, y * by) for (x, y) in bottles]",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y * by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result1 = sum(distt) / 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) / 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result1 = sum(distt) + 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) + 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result1 = sum(distt) ** 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) ** 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None and min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None and min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result1 = sum(distt) * 2 + min1 + (1 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (1 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result1 = sum(distt) * 2 + min1 + (-1 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (-1 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result1 = sum(distt) * 2 + min1 + (1 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (1 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result2 = sum(distt) / 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) / 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result2 = sum(distt) + 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) + 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result2 = sum(distt) ** 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) ** 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None and min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None and min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result2 = sum(distt) * 2 + min1 + (1 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (1 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result2 = sum(distt) * 2 + min1 + (-1 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (-1 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result2 = sum(distt) * 2 + min1 + (1 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (1 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt(a * a + b * b)",
      "mutated_line": "return math.sqrt(a / a + b * b)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a / a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt(a * a + b * b)",
      "mutated_line": "return math.sqrt(a + a + b * b)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a + a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt(a * a + b * b)",
      "mutated_line": "return math.sqrt(a ** a + b * b)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a ** a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt(a * a + b * b)",
      "mutated_line": "return math.sqrt(a * a + b / b)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b / b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt(a * a + b * b)",
      "mutated_line": "return math.sqrt(a * a + (b + b))",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + (b + b))\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt(a * a + b * b)",
      "mutated_line": "return math.sqrt(a * a + b ** b)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b ** b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if result is None or l[i] < result:",
      "mutated_line": "if result is not None or l[i] < result:",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is not None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if result is None or l[i] < result:",
      "mutated_line": "if result is None or l[i] <= result:",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] <= result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if result is None or l[i] < result:",
      "mutated_line": "if result is None or l[i] >= result:",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] >= result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if result is None or l[i] < result:",
      "mutated_line": "if result is None or l[i] != result:",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] != result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result1 = sum(distt) * 3 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 3 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result1 = sum(distt) * 1 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 1 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result1 = sum(distt) * 0 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 0 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result1 = sum(distt) * 1 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 1 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result1 = sum(distt) * -2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * -2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is not None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is not None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 >= 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 >= 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 <= 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 <= 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 != 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 != 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result2 = sum(distt) * 3 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 3 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result2 = sum(distt) * 1 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 1 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result2 = sum(distt) * 0 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 0 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result2 = sum(distt) * 1 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 1 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result2 = sum(distt) * -2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * -2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is not None or min2 > 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is not None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 >= 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 >= 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 <= 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 <= 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 != 0 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 != 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 1 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 1 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > -1 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > -1 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 1 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 1 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 1 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 1 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > -1 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > -1 else min2)\n    return min(result1, result2)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)",
      "mutated_line": "result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 1 else min2)",
      "code": "import math\n\ndef calculate_minimum_total_distance(ax, ay, bx, by, tx, ty, n, bottles):\n\n    def hyp(a, b):\n        return math.sqrt(a * a + b * b)\n\n    def minn(l, skipi=set([])):\n        result = None\n        mini = None\n        for i in range(len(l)):\n            if i in skipi:\n                continue\n            if result is None or l[i] < result:\n                mini = i\n                result = l[i]\n        return (result, mini)\n    distt = [hyp(x - tx, y - ty) for (x, y) in bottles]\n    dista = [hyp(x - ax, y - ay) for (x, y) in bottles]\n    distb = [hyp(x - bx, y - by) for (x, y) in bottles]\n    distamt = [dista[i] - distt[i] for i in range(n)]\n    distbmt = [distb[i] - distt[i] for i in range(n)]\n    (min1, min1i) = minn(distamt)\n    (min2, min2i) = minn(distbmt, skipi=set([min1i]))\n    result1 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 0 else min2)\n    (min1, min1i) = minn(distbmt)\n    (min2, min2i) = minn(distamt, skipi=set([min1i]))\n    result2 = sum(distt) * 2 + min1 + (0 if min2 is None or min2 > 1 else min2)\n    return min(result1, result2)"
    }
  ]
}