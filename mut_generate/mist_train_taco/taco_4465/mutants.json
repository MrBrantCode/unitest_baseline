{
  "task_id": "taco_4465",
  "entry_point": "find_possible_shifts",
  "mutant_count": 71,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "cnt = [0] * n",
      "mutated_line": "cnt = [0] / n",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] / n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "cnt = [0] * n",
      "mutated_line": "cnt = [0] + n",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] + n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "cnt = [0] * n",
      "mutated_line": "cnt = [0] ** n",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] ** n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "cnt[(i + 1 - p[i] + n) % n] += 1",
      "mutated_line": "cnt[(i + 1 - p[i] + n) % n] -= 1",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] -= 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if self.par[node] == node:",
      "mutated_line": "if self.par[node] != node:",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] != node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if a == b:",
      "mutated_line": "if a != b:",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a != b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cnt[(i + 1 - p[i] + n) % n] += 1",
      "mutated_line": "cnt[(i + 1 - p[i] + n) % n] += 2",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 2\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cnt[(i + 1 - p[i] + n) % n] += 1",
      "mutated_line": "cnt[(i + 1 - p[i] + n) % n] += 0",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 0\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cnt[(i + 1 - p[i] + n) % n] += 1",
      "mutated_line": "cnt[(i + 1 - p[i] + n) % n] += 0",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 0\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cnt[(i + 1 - p[i] + n) % n] += 1",
      "mutated_line": "cnt[(i + 1 - p[i] + n) % n] += -1",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += -1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if cnt[i] + 2 * m >= n:",
      "mutated_line": "if cnt[i] + 2 * m > n:",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m > n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if cnt[i] + 2 * m >= n:",
      "mutated_line": "if cnt[i] + 2 * m < n:",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m < n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if cnt[i] + 2 * m >= n:",
      "mutated_line": "if cnt[i] + 2 * m == n:",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m == n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cnt = [0] * n",
      "mutated_line": "cnt = [1] * n",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [1] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cnt = [0] * n",
      "mutated_line": "cnt = [-1] * n",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [-1] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cnt = [0] * n",
      "mutated_line": "cnt = [1] * n",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [1] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cnt[(i + 1 - p[i] + n) % n] += 1",
      "mutated_line": "cnt[(i + 1 - p[i] + n) * n] += 1",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) * n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cnt[(i + 1 - p[i] + n) % n] += 1",
      "mutated_line": "cnt[i + 1 - p[i] + n + n] += 1",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[i + 1 - p[i] + n + n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if cnt[i] + 2 * m >= n:",
      "mutated_line": "if cnt[i] - 2 * m >= n:",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] - 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if cnt[i] + 2 * m >= n:",
      "mutated_line": "if cnt[i] * (2 * m) >= n:",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] * (2 * m) >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "curr = 0",
      "mutated_line": "curr = 1",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 1\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "curr = 0",
      "mutated_line": "curr = -1",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = -1\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "curr = 0",
      "mutated_line": "curr = 1",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 1\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "curr += 1",
      "mutated_line": "curr -= 1",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr -= 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "curr += 1",
      "mutated_line": "curr -= 1",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr -= 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if n - len(connectedRoot) <= m:",
      "mutated_line": "if n - len(connectedRoot) < m:",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) < m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if n - len(connectedRoot) <= m:",
      "mutated_line": "if n - len(connectedRoot) > m:",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) > m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if n - len(connectedRoot) <= m:",
      "mutated_line": "if n - len(connectedRoot) == m:",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) == m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cnt[(i + 1 - p[i] + n) % n] += 1",
      "mutated_line": "cnt[(i + 1 - p[i] - n) % n] += 1",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] - n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cnt[(i + 1 - p[i] + n) % n] += 1",
      "mutated_line": "cnt[(i + 1 - p[i]) * n % n] += 1",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i]) * n % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if cnt[i] + 2 * m >= n:",
      "mutated_line": "if cnt[i] + 2 / m >= n:",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 / m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if cnt[i] + 2 * m >= n:",
      "mutated_line": "if cnt[i] + (2 + m) >= n:",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + (2 + m) >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if cnt[i] + 2 * m >= n:",
      "mutated_line": "if cnt[i] + 2 ** m >= n:",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 ** m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "curr += 1",
      "mutated_line": "curr += 2",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 2\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "curr += 1",
      "mutated_line": "curr += 0",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 0\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "curr += 1",
      "mutated_line": "curr += 0",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 0\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "curr += 1",
      "mutated_line": "curr += -1",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += -1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(0, i):",
      "mutated_line": "for j in range(1, i):",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(1, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(0, i):",
      "mutated_line": "for j in range(-1, i):",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(-1, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(0, i):",
      "mutated_line": "for j in range(1, i):",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(1, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "curr += 1",
      "mutated_line": "curr += 2",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 2\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "curr += 1",
      "mutated_line": "curr += 0",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 0\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "curr += 1",
      "mutated_line": "curr += 0",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 0\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "curr += 1",
      "mutated_line": "curr += -1",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += -1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if n - len(connectedRoot) <= m:",
      "mutated_line": "if n + len(connectedRoot) <= m:",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n + len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if n - len(connectedRoot) <= m:",
      "mutated_line": "if n * len(connectedRoot) <= m:",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n * len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cnt[(i + 1 - p[i] + n) % n] += 1",
      "mutated_line": "cnt[(i + 1 + p[i] + n) % n] += 1",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 + p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cnt[(i + 1 - p[i] + n) % n] += 1",
      "mutated_line": "cnt[((i + 1) * p[i] + n) % n] += 1",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[((i + 1) * p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if cnt[i] + 2 * m >= n:",
      "mutated_line": "if cnt[i] + 3 * m >= n:",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 3 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if cnt[i] + 2 * m >= n:",
      "mutated_line": "if cnt[i] + 1 * m >= n:",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 1 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if cnt[i] + 2 * m >= n:",
      "mutated_line": "if cnt[i] + 0 * m >= n:",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 0 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if cnt[i] + 2 * m >= n:",
      "mutated_line": "if cnt[i] + 1 * m >= n:",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 1 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if cnt[i] + 2 * m >= n:",
      "mutated_line": "if cnt[i] + -2 * m >= n:",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + -2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "obj.union(curr, p[j] - 1)",
      "mutated_line": "obj.union(curr, p[j] + 1)",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] + 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "obj.union(curr, p[j] - 1)",
      "mutated_line": "obj.union(curr, p[j] * 1)",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] * 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "obj.union(curr, p[j] - 1)",
      "mutated_line": "obj.union(curr, p[j] + 1)",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] + 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "obj.union(curr, p[j] - 1)",
      "mutated_line": "obj.union(curr, p[j] * 1)",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] * 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cnt[(i + 1 - p[i] + n) % n] += 1",
      "mutated_line": "cnt[(i - 1 - p[i] + n) % n] += 1",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i - 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "cnt[(i + 1 - p[i] + n) % n] += 1",
      "mutated_line": "cnt[(i * 1 - p[i] + n) % n] += 1",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i * 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "obj.union(curr, p[j] - 1)",
      "mutated_line": "obj.union(curr, p[j] - 2)",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 2)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "obj.union(curr, p[j] - 1)",
      "mutated_line": "obj.union(curr, p[j] - 0)",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 0)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "obj.union(curr, p[j] - 1)",
      "mutated_line": "obj.union(curr, p[j] - 0)",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 0)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "obj.union(curr, p[j] - 1)",
      "mutated_line": "obj.union(curr, p[j] - -1)",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - -1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "obj.union(curr, p[j] - 1)",
      "mutated_line": "obj.union(curr, p[j] - 2)",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 2)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "obj.union(curr, p[j] - 1)",
      "mutated_line": "obj.union(curr, p[j] - 0)",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 0)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "obj.union(curr, p[j] - 1)",
      "mutated_line": "obj.union(curr, p[j] - 0)",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 0)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "obj.union(curr, p[j] - 1)",
      "mutated_line": "obj.union(curr, p[j] - -1)",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - -1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cnt[(i + 1 - p[i] + n) % n] += 1",
      "mutated_line": "cnt[(i + 2 - p[i] + n) % n] += 1",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 2 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cnt[(i + 1 - p[i] + n) % n] += 1",
      "mutated_line": "cnt[(i + 0 - p[i] + n) % n] += 1",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 0 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cnt[(i + 1 - p[i] + n) % n] += 1",
      "mutated_line": "cnt[(i + 0 - p[i] + n) % n] += 1",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + 0 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cnt[(i + 1 - p[i] + n) % n] += 1",
      "mutated_line": "cnt[(i + -1 - p[i] + n) % n] += 1",
      "code": "class UnionFindAlgo:\n\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n\n    def find(self, node):\n        if self.par[node] == node:\n            return node\n        self.par[node] = self.find(self.par[node])\n        return self.par[node]\n\n    def union(self, u, v):\n        a = self.find(u)\n        b = self.find(v)\n        if a == b:\n            return\n        self.par[b] = a\n\ndef find_possible_shifts(n, m, p):\n    cnt = [0] * n\n    for i in range(n):\n        cnt[(i + -1 - p[i] + n) % n] += 1\n    ans = []\n    for i in range(n):\n        if cnt[i] + 2 * m >= n:\n            obj = UnionFindAlgo(n)\n            curr = 0\n            for j in range(i, n):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            for j in range(0, i):\n                obj.union(curr, p[j] - 1)\n                curr += 1\n            connectedRoot = set()\n            for j in range(n):\n                connectedRoot.add(obj.find(j))\n            if n - len(connectedRoot) <= m:\n                ans.append(i)\n    return (len(ans), ans)"
    }
  ]
}