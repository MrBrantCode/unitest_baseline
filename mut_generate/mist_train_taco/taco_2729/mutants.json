{
  "task_id": "taco_2729",
  "entry_point": "calculate_max_crossings",
  "mutant_count": 69,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 1\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = -1\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 1\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "d[num] -= 1",
      "mutated_line": "d[num] += 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] += 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if len(lst) < 2:",
      "mutated_line": "if len(lst) <= 2:",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) <= 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if len(lst) < 2:",
      "mutated_line": "if len(lst) >= 2:",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) >= 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if len(lst) < 2:",
      "mutated_line": "if len(lst) != 2:",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) != 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "half = len(lst) // 2",
      "mutated_line": "half = len(lst) / 2",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) / 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "half = len(lst) // 2",
      "mutated_line": "half = len(lst) * 2",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) * 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "half_ = len(lst) - len(lst) // 2",
      "mutated_line": "half_ = len(lst) + len(lst) // 2",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) + len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "half_ = len(lst) - len(lst) // 2",
      "mutated_line": "half_ = len(lst) * (len(lst) // 2)",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) * (len(lst) // 2)\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i1 = 0",
      "mutated_line": "i1 = 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 1\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i1 = 0",
      "mutated_line": "i1 = -1",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = -1\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "i1 = 0",
      "mutated_line": "i1 = 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 1\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "i2 = 0",
      "mutated_line": "i2 = 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 1\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "i2 = 0",
      "mutated_line": "i2 = -1",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = -1\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "i2 = 0",
      "mutated_line": "i2 = 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 1\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "while i1 < half or i2 < half_:",
      "mutated_line": "while i1 < half and i2 < half_:",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half and i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "d[num] -= 1",
      "mutated_line": "d[num] -= 2",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 2\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "d[num] -= 1",
      "mutated_line": "d[num] -= 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 0\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "d[num] -= 1",
      "mutated_line": "d[num] -= 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 0\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "d[num] -= 1",
      "mutated_line": "d[num] -= -1",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= -1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(lst) < 2:",
      "mutated_line": "if len(lst) < 3:",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 3:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(lst) < 2:",
      "mutated_line": "if len(lst) < 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 1:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(lst) < 2:",
      "mutated_line": "if len(lst) < 0:",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 0:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(lst) < 2:",
      "mutated_line": "if len(lst) < 1:",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 1:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(lst) < 2:",
      "mutated_line": "if len(lst) < -2:",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < -2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "half = len(lst) // 2",
      "mutated_line": "half = len(lst) // 3",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 3\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "half = len(lst) // 2",
      "mutated_line": "half = len(lst) // 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 1\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "half = len(lst) // 2",
      "mutated_line": "half = len(lst) // 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 0\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "half = len(lst) // 2",
      "mutated_line": "half = len(lst) // 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 1\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "half = len(lst) // 2",
      "mutated_line": "half = len(lst) // -2",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // -2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "half_ = len(lst) - len(lst) // 2",
      "mutated_line": "half_ = len(lst) - len(lst) / 2",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) / 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "half_ = len(lst) - len(lst) // 2",
      "mutated_line": "half_ = len(lst) - len(lst) * 2",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) * 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while i1 < half or i2 < half_:",
      "mutated_line": "while i1 <= half or i2 < half_:",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 <= half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while i1 < half or i2 < half_:",
      "mutated_line": "while i1 >= half or i2 < half_:",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 >= half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while i1 < half or i2 < half_:",
      "mutated_line": "while i1 != half or i2 < half_:",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 != half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while i1 < half or i2 < half_:",
      "mutated_line": "while i1 < half or i2 <= half_:",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 <= half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while i1 < half or i2 < half_:",
      "mutated_line": "while i1 < half or i2 >= half_:",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 >= half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while i1 < half or i2 < half_:",
      "mutated_line": "while i1 < half or i2 != half_:",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 != half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if i1 == half:",
      "mutated_line": "if i1 != half:",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 != half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "lst += second_half[i2:]",
      "mutated_line": "lst -= second_half[i2:]",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst -= second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if i2 == half_:",
      "mutated_line": "if i2 != half_:",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 != half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "lst += first_half[i1:]",
      "mutated_line": "lst -= first_half[i1:]",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst -= first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "ans += (half - i1) * i2",
      "mutated_line": "ans -= (half - i1) * i2",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans -= (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if first_half[i1] <= second_half[i2]:",
      "mutated_line": "if first_half[i1] < second_half[i2]:",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] < second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if first_half[i1] <= second_half[i2]:",
      "mutated_line": "if first_half[i1] > second_half[i2]:",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] > second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if first_half[i1] <= second_half[i2]:",
      "mutated_line": "if first_half[i1] == second_half[i2]:",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] == second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "i1 += 1",
      "mutated_line": "i1 -= 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 -= 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "ans += i2",
      "mutated_line": "ans -= i2",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans -= i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "i2 += 1",
      "mutated_line": "i2 -= 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 -= 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "half_ = len(lst) - len(lst) // 2",
      "mutated_line": "half_ = len(lst) - len(lst) // 3",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 3\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "half_ = len(lst) - len(lst) // 2",
      "mutated_line": "half_ = len(lst) - len(lst) // 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 1\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "half_ = len(lst) - len(lst) // 2",
      "mutated_line": "half_ = len(lst) - len(lst) // 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 0\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "half_ = len(lst) - len(lst) // 2",
      "mutated_line": "half_ = len(lst) - len(lst) // 1",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 1\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "half_ = len(lst) - len(lst) // 2",
      "mutated_line": "half_ = len(lst) - len(lst) // -2",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // -2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans += (half - i1) * i2",
      "mutated_line": "ans += (half - i1) / i2",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) / i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans += (half - i1) * i2",
      "mutated_line": "ans += half - i1 + i2",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += half - i1 + i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans += (half - i1) * i2",
      "mutated_line": "ans += (half - i1) ** i2",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) ** i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "i1 += 1",
      "mutated_line": "i1 += 2",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 2\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "i1 += 1",
      "mutated_line": "i1 += 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 0\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "i1 += 1",
      "mutated_line": "i1 += 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 0\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "i1 += 1",
      "mutated_line": "i1 += -1",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += -1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "i2 += 1",
      "mutated_line": "i2 += 2",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 2\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "i2 += 1",
      "mutated_line": "i2 += 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 0\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "i2 += 1",
      "mutated_line": "i2 += 0",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 0\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "i2 += 1",
      "mutated_line": "i2 += -1",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half - i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += -1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans += (half - i1) * i2",
      "mutated_line": "ans += (half + i1) * i2",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += (half + i1) * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans += (half - i1) * i2",
      "mutated_line": "ans += half * i1 * i2",
      "code": "from collections import defaultdict\n\ndef calculate_max_crossings(test_cases):\n\n    def reversePairs(nums):\n        ans = 0\n\n        def getReverse(lst):\n            nonlocal ans\n            if len(lst) < 2:\n                return lst\n            half = len(lst) // 2\n            half_ = len(lst) - len(lst) // 2\n            (first_half, second_half) = (getReverse(lst[:half]), getReverse(lst[half:]))\n            lst = []\n            i1 = 0\n            i2 = 0\n            while i1 < half or i2 < half_:\n                if i1 == half:\n                    lst += second_half[i2:]\n                    break\n                if i2 == half_:\n                    lst += first_half[i1:]\n                    ans += half * i1 * i2\n                    break\n                if first_half[i1] <= second_half[i2]:\n                    lst.append(first_half[i1])\n                    i1 += 1\n                    ans += i2\n                else:\n                    lst.append(second_half[i2])\n                    i2 += 1\n            return lst\n        getReverse(nums)\n        return ans\n    results = []\n    for (n, a) in test_cases:\n        tmp_lst = []\n        d = defaultdict(int)\n        for num in a:\n            d[num] -= 1\n            tmp_lst.append((num, d[num]))\n        results.append(reversePairs(tmp_lst))\n    return results"
    }
  ]
}