{
  "task_id": "taco_5266",
  "entry_point": "can_robot_reach_exit",
  "mutant_count": 186,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sx = sy = gx = gy = 0",
      "mutated_line": "sx = sy = gx = gy = 1",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 1\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sx = sy = gx = gy = 0",
      "mutated_line": "sx = sy = gx = gy = -1",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = -1\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "sx = sy = gx = gy = 0",
      "mutated_line": "sx = sy = gx = gy = 1",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 1\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S0 = [1] * (N + 1)",
      "mutated_line": "S0 = [1] / (N + 1)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] / (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S0 = [1] * (N + 1)",
      "mutated_line": "S0 = [1] + (N + 1)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] + (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S0 = [1] * (N + 1)",
      "mutated_line": "S0 = [1] ** (N + 1)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] ** (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cur = 1",
      "mutated_line": "cur = 2",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 2\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cur = 1",
      "mutated_line": "cur = 0",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 0\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cur = 1",
      "mutated_line": "cur = 0",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 0\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cur = 1",
      "mutated_line": "cur = -1",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = -1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d = [N + 1] * 4",
      "mutated_line": "d = [N + 1] / 4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] / 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d = [N + 1] * 4",
      "mutated_line": "d = [N + 1] + 4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] + 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d = [N + 1] * 4",
      "mutated_line": "d = [N + 1] ** 4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] ** 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "D = [None] * (N + 1)",
      "mutated_line": "D = [None] / (N + 1)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] / (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "D = [None] * (N + 1)",
      "mutated_line": "D = [None] + (N + 1)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] + (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "D = [None] * (N + 1)",
      "mutated_line": "D = [None] ** (N + 1)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] ** (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "T[sy][sx] = 0",
      "mutated_line": "T[sy][sx] = 1",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 1\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "T[sy][sx] = 0",
      "mutated_line": "T[sy][sx] = -1",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = -1\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "T[sy][sx] = 0",
      "mutated_line": "T[sy][sx] = 1",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 1\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "ROR",
      "lineno": 59,
      "original_line": "return T[gy][gx] < N + 1",
      "mutated_line": "return T[gy][gx] <= N + 1",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] <= N + 1"
    },
    {
      "operator": "ROR",
      "lineno": 59,
      "original_line": "return T[gy][gx] < N + 1",
      "mutated_line": "return T[gy][gx] >= N + 1",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] >= N + 1"
    },
    {
      "operator": "ROR",
      "lineno": 59,
      "original_line": "return T[gy][gx] < N + 1",
      "mutated_line": "return T[gy][gx] != N + 1",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] != N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "C = [[0] * W for _ in range(H)]",
      "mutated_line": "C = [[0] / W for _ in range(H)]",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] / W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "C = [[0] * W for _ in range(H)]",
      "mutated_line": "C = [[0] + W for _ in range(H)]",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] + W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "C = [[0] * W for _ in range(H)]",
      "mutated_line": "C = [[0] ** W for _ in range(H)]",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] ** W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S0 = [1] * (N + 1)",
      "mutated_line": "S0 = [1] * (N - 1)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N - 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S0 = [1] * (N + 1)",
      "mutated_line": "S0 = [1] * (N * 1)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N * 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if commands[i] == 'L':",
      "mutated_line": "if commands[i] != 'L':",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] != 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d = [N + 1] * 4",
      "mutated_line": "d = [N + 1] * 5",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 5\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d = [N + 1] * 4",
      "mutated_line": "d = [N + 1] * 3",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 3\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d = [N + 1] * 4",
      "mutated_line": "d = [N + 1] * 0",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 0\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d = [N + 1] * 4",
      "mutated_line": "d = [N + 1] * 1",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 1\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d = [N + 1] * 4",
      "mutated_line": "d = [N + 1] * -4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * -4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "D = [None] * (N + 1)",
      "mutated_line": "D = [None] * (N - 1)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N - 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "D = [None] * (N + 1)",
      "mutated_line": "D = [None] * (N * 1)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N * 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "for i in range(N, -1, -1):",
      "mutated_line": "for i in range(N, +1, -1):",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, +1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "for i in range(N, -1, -1):",
      "mutated_line": "for i in range(N, -1, +1):",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, +1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "T = [[N + 1] * W for _ in range(H)]",
      "mutated_line": "T = [[N + 1] / W for _ in range(H)]",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] / W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "T = [[N + 1] * W for _ in range(H)]",
      "mutated_line": "T = [[N + 1] + W for _ in range(H)]",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] + W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "T = [[N + 1] * W for _ in range(H)]",
      "mutated_line": "T = [[N + 1] ** W for _ in range(H)]",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] ** W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if T[y][x] < cost:",
      "mutated_line": "if T[y][x] <= cost:",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] <= cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if T[y][x] < cost:",
      "mutated_line": "if T[y][x] >= cost:",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] >= cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if T[y][x] < cost:",
      "mutated_line": "if T[y][x] != cost:",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] != cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 59,
      "original_line": "return T[gy][gx] < N + 1",
      "mutated_line": "return T[gy][gx] < N - 1",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N - 1"
    },
    {
      "operator": "AOR",
      "lineno": 59,
      "original_line": "return T[gy][gx] < N + 1",
      "mutated_line": "return T[gy][gx] < N * 1",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N * 1"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((+1, 0), (0, -1), (1, 0), (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((+1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 1), (0, -1), (1, 0), (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 1), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, -1), (0, -1), (1, 0), (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, -1), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 1), (0, -1), (1, 0), (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 1), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (1, -1), (1, 0), (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (1, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (-1, -1), (1, 0), (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (-1, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (1, -1), (1, 0), (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (1, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, +1), (1, 0), (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, +1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (2, 0), (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (2, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (0, 0), (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (0, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (0, 0), (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (0, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (-1, 0), (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (-1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (1, 1), (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 1), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (1, -1), (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, -1), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (1, 1), (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 1), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (1, 0), (1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (1, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (1, 0), (-1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (-1, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (1, 0), (1, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (1, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 2))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 2))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 0))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 0))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 0))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 0))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, -1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, -1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if maze[i][j] == '#':",
      "mutated_line": "if maze[i][j] != '#':",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] != '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S0 = [1] * (N + 1)",
      "mutated_line": "S0 = [2] * (N + 1)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [2] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S0 = [1] * (N + 1)",
      "mutated_line": "S0 = [0] * (N + 1)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [0] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S0 = [1] * (N + 1)",
      "mutated_line": "S0 = [0] * (N + 1)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [0] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S0 = [1] * (N + 1)",
      "mutated_line": "S0 = [-1] * (N + 1)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [-1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S0 = [1] * (N + 1)",
      "mutated_line": "S0 = [1] * (N + 2)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 2)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S0 = [1] * (N + 1)",
      "mutated_line": "S0 = [1] * (N + 0)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 0)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S0 = [1] * (N + 1)",
      "mutated_line": "S0 = [1] * (N + 0)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 0)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S0 = [1] * (N + 1)",
      "mutated_line": "S0 = [1] * (N + -1)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + -1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if commands[i] == 'L':",
      "mutated_line": "if commands[i] == '':",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == '':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "cur = (cur - 1) % 4",
      "mutated_line": "cur = (cur - 1) * 4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) * 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "cur = (cur - 1) % 4",
      "mutated_line": "cur = cur - 1 + 4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = cur - 1 + 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "cur = (cur + 1) % 4",
      "mutated_line": "cur = (cur + 1) * 4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) * 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "cur = (cur + 1) % 4",
      "mutated_line": "cur = cur + 1 + 4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = cur + 1 + 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "S0[i + 1] = cur",
      "mutated_line": "S0[i - 1] = cur",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i - 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "S0[i + 1] = cur",
      "mutated_line": "S0[i * 1] = cur",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i * 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d = [N + 1] * 4",
      "mutated_line": "d = [N - 1] * 4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N - 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d = [N + 1] * 4",
      "mutated_line": "d = [N * 1] * 4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N * 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "D = [None] * (N + 1)",
      "mutated_line": "D = [None] * (N + 2)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 2)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "D = [None] * (N + 1)",
      "mutated_line": "D = [None] * (N + 0)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 0)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "D = [None] * (N + 1)",
      "mutated_line": "D = [None] * (N + 0)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 0)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "D = [None] * (N + 1)",
      "mutated_line": "D = [None] * (N + -1)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + -1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N, -1, -1):",
      "mutated_line": "for i in range(N, -2, -1):",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -2, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N, -1, -1):",
      "mutated_line": "for i in range(N, -0, -1):",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -0, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N, -1, -1):",
      "mutated_line": "for i in range(N, -0, -1):",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -0, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N, -1, -1):",
      "mutated_line": "for i in range(N, --1, -1):",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, --1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N, -1, -1):",
      "mutated_line": "for i in range(N, -1, -2):",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -2):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N, -1, -1):",
      "mutated_line": "for i in range(N, -1, -0):",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -0):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N, -1, -1):",
      "mutated_line": "for i in range(N, -1, -0):",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -0):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(N, -1, -1):",
      "mutated_line": "for i in range(N, -1, --1):",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, --1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "que = [(0, sx, sy)]",
      "mutated_line": "que = [(1, sx, sy)]",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(1, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "que = [(0, sx, sy)]",
      "mutated_line": "que = [(-1, sx, sy)]",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(-1, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "que = [(0, sx, sy)]",
      "mutated_line": "que = [(1, sx, sy)]",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(1, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "for k in range(4):",
      "mutated_line": "for k in range(5):",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(5):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "for k in range(4):",
      "mutated_line": "for k in range(3):",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(3):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "for k in range(4):",
      "mutated_line": "for k in range(0):",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(0):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "for k in range(4):",
      "mutated_line": "for k in range(1):",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(1):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "for k in range(4):",
      "mutated_line": "for k in range(-4):",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(-4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "LCR",
      "lineno": 52,
      "original_line": "if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:",
      "mutated_line": "if not (0 <= nx < W and 0 <= ny < H) and C[ny][nx]:",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) and C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if n_cost < T[ny][nx]:",
      "mutated_line": "if n_cost <= T[ny][nx]:",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost <= T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if n_cost < T[ny][nx]:",
      "mutated_line": "if n_cost >= T[ny][nx]:",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost >= T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if n_cost < T[ny][nx]:",
      "mutated_line": "if n_cost != T[ny][nx]:",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost != T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "return T[gy][gx] < N + 1",
      "mutated_line": "return T[gy][gx] < N + 2",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 2"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "return T[gy][gx] < N + 1",
      "mutated_line": "return T[gy][gx] < N + 0",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 0"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "return T[gy][gx] < N + 1",
      "mutated_line": "return T[gy][gx] < N + 0",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 0"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "return T[gy][gx] < N + 1",
      "mutated_line": "return T[gy][gx] < N + -1",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + -1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-2, 0), (0, -1), (1, 0), (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-2, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-0, 0), (0, -1), (1, 0), (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-0, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-0, 0), (0, -1), (1, 0), (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-0, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((--1, 0), (0, -1), (1, 0), (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((--1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -2), (1, 0), (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -2), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -0), (1, 0), (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -0), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, -0), (1, 0), (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -0), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dd = ((-1, 0), (0, -1), (1, 0), (0, 1))",
      "mutated_line": "dd = ((-1, 0), (0, --1), (1, 0), (0, 1))",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, --1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "C = [[0] * W for _ in range(H)]",
      "mutated_line": "C = [[1] * W for _ in range(H)]",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[1] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "C = [[0] * W for _ in range(H)]",
      "mutated_line": "C = [[-1] * W for _ in range(H)]",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[-1] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "C = [[0] * W for _ in range(H)]",
      "mutated_line": "C = [[1] * W for _ in range(H)]",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[1] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if maze[i][j] == '#':",
      "mutated_line": "if maze[i][j] == '':",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "C[i][j] = 1",
      "mutated_line": "C[i][j] = 2",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 2\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "C[i][j] = 1",
      "mutated_line": "C[i][j] = 0",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 0\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "C[i][j] = 1",
      "mutated_line": "C[i][j] = 0",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 0\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "C[i][j] = 1",
      "mutated_line": "C[i][j] = -1",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = -1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "elif maze[i][j] == 'S':",
      "mutated_line": "elif maze[i][j] != 'S':",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] != 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "cur = (cur - 1) % 4",
      "mutated_line": "cur = (cur + 1) % 4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur + 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "cur = (cur - 1) % 4",
      "mutated_line": "cur = cur * 1 % 4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = cur * 1 % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cur = (cur - 1) % 4",
      "mutated_line": "cur = (cur - 1) % 5",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 5\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cur = (cur - 1) % 4",
      "mutated_line": "cur = (cur - 1) % 3",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 3\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cur = (cur - 1) % 4",
      "mutated_line": "cur = (cur - 1) % 0",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 0\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cur = (cur - 1) % 4",
      "mutated_line": "cur = (cur - 1) % 1",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 1\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cur = (cur - 1) % 4",
      "mutated_line": "cur = (cur - 1) % -4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % -4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "cur = (cur + 1) % 4",
      "mutated_line": "cur = (cur - 1) % 4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur - 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "cur = (cur + 1) % 4",
      "mutated_line": "cur = cur * 1 % 4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = cur * 1 % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cur = (cur + 1) % 4",
      "mutated_line": "cur = (cur + 1) % 5",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 5\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cur = (cur + 1) % 4",
      "mutated_line": "cur = (cur + 1) % 3",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 3\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cur = (cur + 1) % 4",
      "mutated_line": "cur = (cur + 1) % 0",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 0\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cur = (cur + 1) % 4",
      "mutated_line": "cur = (cur + 1) % 1",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 1\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cur = (cur + 1) % 4",
      "mutated_line": "cur = (cur + 1) % -4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % -4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "S0[i + 1] = cur",
      "mutated_line": "S0[i + 2] = cur",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 2] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "S0[i + 1] = cur",
      "mutated_line": "S0[i + 0] = cur",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 0] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "S0[i + 1] = cur",
      "mutated_line": "S0[i + 0] = cur",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 0] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "S0[i + 1] = cur",
      "mutated_line": "S0[i + -1] = cur",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + -1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d = [N + 1] * 4",
      "mutated_line": "d = [N + 2] * 4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 2] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d = [N + 1] * 4",
      "mutated_line": "d = [N + 0] * 4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 0] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d = [N + 1] * 4",
      "mutated_line": "d = [N + 0] * 4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 0] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d = [N + 1] * 4",
      "mutated_line": "d = [N + -1] * 4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + -1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "T = [[N + 1] * W for _ in range(H)]",
      "mutated_line": "T = [[N - 1] * W for _ in range(H)]",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N - 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "T = [[N + 1] * W for _ in range(H)]",
      "mutated_line": "T = [[N * 1] * W for _ in range(H)]",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N * 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x - dx, y + dy)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x - dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x * dx, y + dy)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x * dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y - dy)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y - dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "nx, ny = x + dx, y + dy",
      "mutated_line": "(nx, ny) = (x + dx, y * dy)",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y * dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif maze[i][j] == 'S':",
      "mutated_line": "elif maze[i][j] == '':",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == '':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "elif maze[i][j] == 'G':",
      "mutated_line": "elif maze[i][j] != 'G':",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] != 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cur = (cur - 1) % 4",
      "mutated_line": "cur = (cur - 2) % 4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 2) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cur = (cur - 1) % 4",
      "mutated_line": "cur = (cur - 0) % 4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 0) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cur = (cur - 1) % 4",
      "mutated_line": "cur = (cur - 0) % 4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 0) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cur = (cur - 1) % 4",
      "mutated_line": "cur = (cur - -1) % 4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - -1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cur = (cur + 1) % 4",
      "mutated_line": "cur = (cur + 2) % 4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 2) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cur = (cur + 1) % 4",
      "mutated_line": "cur = (cur + 0) % 4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 0) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cur = (cur + 1) % 4",
      "mutated_line": "cur = (cur + 0) % 4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 0) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cur = (cur + 1) % 4",
      "mutated_line": "cur = (cur + -1) % 4",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + -1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "T = [[N + 1] * W for _ in range(H)]",
      "mutated_line": "T = [[N + 2] * W for _ in range(H)]",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 2] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "T = [[N + 1] * W for _ in range(H)]",
      "mutated_line": "T = [[N + 0] * W for _ in range(H)]",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 0] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "T = [[N + 1] * W for _ in range(H)]",
      "mutated_line": "T = [[N + 0] * W for _ in range(H)]",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 0] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "T = [[N + 1] * W for _ in range(H)]",
      "mutated_line": "T = [[N + -1] * W for _ in range(H)]",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + -1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "LCR",
      "lineno": 52,
      "original_line": "if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:",
      "mutated_line": "if not (0 <= nx < W or 0 <= ny < H) or C[ny][nx]:",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W or 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "elif maze[i][j] == 'G':",
      "mutated_line": "elif maze[i][j] == '':",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == '':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:",
      "mutated_line": "if not (0 < nx < W and 0 <= ny < H) or C[ny][nx]:",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 < nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:",
      "mutated_line": "if not (0 > nx < W and 0 <= ny < H) or C[ny][nx]:",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 > nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:",
      "mutated_line": "if not (0 == nx < W and 0 <= ny < H) or C[ny][nx]:",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 == nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:",
      "mutated_line": "if not (0 <= nx < W and 0 < ny < H) or C[ny][nx]:",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 < ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:",
      "mutated_line": "if not (0 <= nx < W and 0 > ny < H) or C[ny][nx]:",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 > ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:",
      "mutated_line": "if not (0 <= nx < W and 0 == ny < H) or C[ny][nx]:",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 0 == ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:",
      "mutated_line": "if not (1 <= nx < W and 0 <= ny < H) or C[ny][nx]:",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (1 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:",
      "mutated_line": "if not (-1 <= nx < W and 0 <= ny < H) or C[ny][nx]:",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (-1 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:",
      "mutated_line": "if not (1 <= nx < W and 0 <= ny < H) or C[ny][nx]:",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (1 <= nx < W and 0 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:",
      "mutated_line": "if not (0 <= nx < W and 1 <= ny < H) or C[ny][nx]:",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 1 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:",
      "mutated_line": "if not (0 <= nx < W and -1 <= ny < H) or C[ny][nx]:",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and -1 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if not (0 <= nx < W and 0 <= ny < H) or C[ny][nx]:",
      "mutated_line": "if not (0 <= nx < W and 1 <= ny < H) or C[ny][nx]:",
      "code": "from heapq import heappush, heappop\n\ndef can_robot_reach_exit(H, W, N, commands, maze):\n    dd = ((-1, 0), (0, -1), (1, 0), (0, 1))\n    C = [[0] * W for _ in range(H)]\n    sx = sy = gx = gy = 0\n    for i in range(H):\n        for j in range(W):\n            if maze[i][j] == '#':\n                C[i][j] = 1\n            elif maze[i][j] == 'S':\n                (sx, sy) = (j, i)\n            elif maze[i][j] == 'G':\n                (gx, gy) = (j, i)\n    S0 = [1] * (N + 1)\n    cur = 1\n    for i in range(N):\n        if commands[i] == 'L':\n            cur = (cur - 1) % 4\n        else:\n            cur = (cur + 1) % 4\n        S0[i + 1] = cur\n    d = [N + 1] * 4\n    D = [None] * (N + 1)\n    for i in range(N, -1, -1):\n        d[S0[i]] = i\n        D[i] = d[:]\n    T = [[N + 1] * W for _ in range(H)]\n    T[sy][sx] = 0\n    que = [(0, sx, sy)]\n    while que:\n        (cost, x, y) = heappop(que)\n        if T[y][x] < cost:\n            continue\n        d = D[cost]\n        for k in range(4):\n            (dx, dy) = dd[k]\n            n_cost = d[k]\n            (nx, ny) = (x + dx, y + dy)\n            if not (0 <= nx < W and 1 <= ny < H) or C[ny][nx]:\n                continue\n            if n_cost < T[ny][nx]:\n                T[ny][nx] = n_cost\n                heappush(que, (n_cost, nx, ny))\n    return T[gy][gx] < N + 1"
    }
  ]
}