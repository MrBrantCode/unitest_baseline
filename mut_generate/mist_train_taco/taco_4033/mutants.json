{
  "task_id": "taco_4033",
  "entry_point": "detect_cycle_in_undirected_graph",
  "mutant_count": 45,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if V < 3:",
      "mutated_line": "if V <= 3:",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V <= 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if V < 3:",
      "mutated_line": "if V >= 3:",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V >= 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if V < 3:",
      "mutated_line": "if V != 3:",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V != 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 1"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if x == parent[x]:",
      "mutated_line": "if x != parent[x]:",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x != parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if x == parent[x]:",
      "mutated_line": "if x != parent[x]:",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x != parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "return find_parent(x, parent) == find_parent(y, parent)",
      "mutated_line": "return find_parent(x, parent) != find_parent(y, parent)",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) != find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if x_par == y_par:",
      "mutated_line": "if x_par != y_par:",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par != y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if rank[x_par] >= rank[y_par]:",
      "mutated_line": "if rank[x_par] > rank[y_par]:",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] > rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if rank[x_par] >= rank[y_par]:",
      "mutated_line": "if rank[x_par] < rank[y_par]:",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] < rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if rank[x_par] >= rank[y_par]:",
      "mutated_line": "if rank[x_par] == rank[y_par]:",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] == rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "rank[x_par] += 1",
      "mutated_line": "rank[x_par] -= 1",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] -= 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "rank[y_par] += 1",
      "mutated_line": "rank[y_par] -= 1",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] -= 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 2\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 0\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 0\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return -1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if V < 3:",
      "mutated_line": "if V < 4:",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 4:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if V < 3:",
      "mutated_line": "if V < 2:",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 2:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if V < 3:",
      "mutated_line": "if V < 0:",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 0:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if V < 3:",
      "mutated_line": "if V < 1:",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 1:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if V < 3:",
      "mutated_line": "if V < -3:",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < -3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 1\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return -1\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 1\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "rank = [0 for i in range(V)]",
      "mutated_line": "rank = [1 for i in range(V)]",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [1 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "rank = [0 for i in range(V)]",
      "mutated_line": "rank = [-1 for i in range(V)]",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [-1 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "rank = [0 for i in range(V)]",
      "mutated_line": "rank = [1 for i in range(V)]",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [1 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 1\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return -1\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 1\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "rank[x_par] += 1",
      "mutated_line": "rank[x_par] += 2",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 2\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "rank[x_par] += 1",
      "mutated_line": "rank[x_par] += 0",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 0\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "rank[x_par] += 1",
      "mutated_line": "rank[x_par] += 0",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 0\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "rank[x_par] += 1",
      "mutated_line": "rank[x_par] += -1",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += -1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "rank[y_par] += 1",
      "mutated_line": "rank[y_par] += 2",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 2\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "rank[y_par] += 1",
      "mutated_line": "rank[y_par] += 0",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 0\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "rank[y_par] += 1",
      "mutated_line": "rank[y_par] += 0",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 0\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "rank[y_par] += 1",
      "mutated_line": "rank[y_par] += -1",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += -1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 1\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 2\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 0\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return 0\n        union(u, v, parent, rank)\n    return 0"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def detect_cycle_in_undirected_graph(V, adj):\n\n    def find_parent(x, parent):\n        if x == parent[x]:\n            return x\n        else:\n            return find_parent(parent[x], parent)\n\n    def compress(x, r, parent):\n        if x == parent[x]:\n            return x\n        else:\n            parent[x] = compress(parent[x], r, parent)\n            return parent[x]\n\n    def is_connected(x, y, parent):\n        return find_parent(x, parent) == find_parent(y, parent)\n\n    def union(x, y, parent, rank):\n        x_par = find_parent(x, parent)\n        y_par = find_parent(y, parent)\n        if x_par == y_par:\n            return 0\n        if rank[x_par] >= rank[y_par]:\n            parent[y_par] = x_par\n            rank[x_par] += 1\n        else:\n            parent[x_par] = y_par\n            rank[y_par] += 1\n        return 1\n\n    def list_to_edges(G):\n        E = []\n        for u in range(len(G)):\n            for v in G[u]:\n                E.append((u, v))\n        return E\n    if V < 3:\n        return 0\n    E = list_to_edges(adj)\n    parent = [i for i in range(V)]\n    rank = [0 for i in range(V)]\n    for (u, v) in E:\n        if is_connected(u, v, parent):\n            return -1\n        union(u, v, parent, rank)\n    return 0"
    }
  ]
}