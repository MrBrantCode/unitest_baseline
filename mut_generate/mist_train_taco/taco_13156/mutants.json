{
  "task_id": "taco_13156",
  "entry_point": "min_removals_to_make_sequence_good",
  "mutant_count": 61,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return len(sequence) - fun(sequence)",
      "mutated_line": "return len(sequence) + fun(sequence)",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) + fun(sequence)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return len(sequence) - fun(sequence)",
      "mutated_line": "return len(sequence) * fun(sequence)",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) * fun(sequence)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(a) <= 3:",
      "mutated_line": "if len(a) < 3:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) < 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(a) <= 3:",
      "mutated_line": "if len(a) > 3:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) > 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(a) <= 3:",
      "mutated_line": "if len(a) == 3:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) == 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if maxE == 0:",
      "mutated_line": "if maxE != 0:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE != 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "msb = 1",
      "mutated_line": "msb = 2",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 2\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "msb = 1",
      "mutated_line": "msb = 0",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 0\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "msb = 1",
      "mutated_line": "msb = 0",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 0\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "msb = 1",
      "mutated_line": "msb = -1",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = -1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while 2 * msb <= maxE:",
      "mutated_line": "while 2 * msb < maxE:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb < maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while 2 * msb <= maxE:",
      "mutated_line": "while 2 * msb > maxE:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb > maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while 2 * msb <= maxE:",
      "mutated_line": "while 2 * msb == maxE:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb == maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "msb *= 2",
      "mutated_line": "msb /= 2",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb /= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if max1 == 0:",
      "mutated_line": "if max1 != 0:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 != 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if max2 == 0:",
      "mutated_line": "if max2 != 0:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 != 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(a) <= 3:",
      "mutated_line": "if len(a) <= 4:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 4:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(a) <= 3:",
      "mutated_line": "if len(a) <= 2:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 2:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(a) <= 3:",
      "mutated_line": "if len(a) <= 0:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 0:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(a) <= 3:",
      "mutated_line": "if len(a) <= 1:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 1:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(a) <= 3:",
      "mutated_line": "if len(a) <= -3:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= -3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if maxE == 0:",
      "mutated_line": "if maxE == 1:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 1:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if maxE == 0:",
      "mutated_line": "if maxE == -1:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == -1:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if maxE == 0:",
      "mutated_line": "if maxE == 1:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 1:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "while 2 * msb <= maxE:",
      "mutated_line": "while 2 / msb <= maxE:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 / msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "while 2 * msb <= maxE:",
      "mutated_line": "while 2 + msb <= maxE:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 + msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "while 2 * msb <= maxE:",
      "mutated_line": "while 2 ** msb <= maxE:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 ** msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "msb *= 2",
      "mutated_line": "msb *= 3",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 3\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "msb *= 2",
      "mutated_line": "msb *= 1",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 1\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "msb *= 2",
      "mutated_line": "msb *= 0",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 0\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "msb *= 2",
      "mutated_line": "msb *= 1",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 1\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "msb *= 2",
      "mutated_line": "msb *= -2",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= -2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if x >= msb:",
      "mutated_line": "if x > msb:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x > msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if x >= msb:",
      "mutated_line": "if x < msb:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x < msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if x >= msb:",
      "mutated_line": "if x == msb:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x == msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if max1 == 0:",
      "mutated_line": "if max1 == 1:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 1:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if max1 == 0:",
      "mutated_line": "if max1 == -1:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == -1:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if max1 == 0:",
      "mutated_line": "if max1 == 1:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 1:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if max2 == 0:",
      "mutated_line": "if max2 == 1:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 1:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if max2 == 0:",
      "mutated_line": "if max2 == -1:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == -1:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if max2 == 0:",
      "mutated_line": "if max2 == 1:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 1:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return max(1 + max1, 1 + max2)",
      "mutated_line": "return max(1 - max1, 1 + max2)",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 - max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return max(1 + max1, 1 + max2)",
      "mutated_line": "return max(1 * max1, 1 + max2)",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 * max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return max(1 + max1, 1 + max2)",
      "mutated_line": "return max(1 + max1, 1 - max2)",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 - max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return max(1 + max1, 1 + max2)",
      "mutated_line": "return max(1 + max1, 1 * max2)",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 * max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while 2 * msb <= maxE:",
      "mutated_line": "while 3 * msb <= maxE:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 3 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while 2 * msb <= maxE:",
      "mutated_line": "while 1 * msb <= maxE:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 1 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while 2 * msb <= maxE:",
      "mutated_line": "while 0 * msb <= maxE:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 0 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while 2 * msb <= maxE:",
      "mutated_line": "while 1 * msb <= maxE:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 1 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while 2 * msb <= maxE:",
      "mutated_line": "while -2 * msb <= maxE:",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while -2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return max(1 + max1, 1 + max2)",
      "mutated_line": "return max(2 + max1, 1 + max2)",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(2 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return max(1 + max1, 1 + max2)",
      "mutated_line": "return max(0 + max1, 1 + max2)",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(0 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return max(1 + max1, 1 + max2)",
      "mutated_line": "return max(0 + max1, 1 + max2)",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(0 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return max(1 + max1, 1 + max2)",
      "mutated_line": "return max(-1 + max1, 1 + max2)",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(-1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return max(1 + max1, 1 + max2)",
      "mutated_line": "return max(1 + max1, 2 + max2)",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 2 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return max(1 + max1, 1 + max2)",
      "mutated_line": "return max(1 + max1, 0 + max2)",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 0 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return max(1 + max1, 1 + max2)",
      "mutated_line": "return max(1 + max1, 0 + max2)",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 0 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return max(1 + max1, 1 + max2)",
      "mutated_line": "return max(1 + max1, -1 + max2)",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x - msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, -1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "l1.append(x - msb)",
      "mutated_line": "l1.append(x + msb)",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x + msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "l1.append(x - msb)",
      "mutated_line": "l1.append(x * msb)",
      "code": "def min_removals_to_make_sequence_good(sequence):\n    \"\"\"\n    Determines the minimum number of removals required to make the given sequence of distinct non-negative integers good.\n\n    A sequence is considered good if the resulting graph formed by connecting each element to the nearest XOR neighbor forms a tree.\n\n    Parameters:\n    sequence (list of int): A list of distinct non-negative integers.\n\n    Returns:\n    int: The minimum number of elements to remove in order to make the remaining sequence good.\n    \"\"\"\n\n    def fun(a):\n        if len(a) <= 3:\n            return len(a)\n        maxE = max(a)\n        if maxE == 0:\n            return len(a)\n        msb = 1\n        while 2 * msb <= maxE:\n            msb *= 2\n        l1 = []\n        l2 = []\n        for x in a:\n            if x >= msb:\n                l1.append(x * msb)\n            else:\n                l2.append(x)\n        max1 = fun(l1)\n        max2 = fun(l2)\n        if max1 == 0:\n            return max2\n        if max2 == 0:\n            return max1\n        return max(1 + max1, 1 + max2)\n    return len(sequence) - fun(sequence)"
    }
  ]
}