{
  "task_id": "taco_4393",
  "entry_point": "calculate_projection",
  "mutant_count": 47,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return a.real * b.real + a.imag * b.imag",
      "mutated_line": "return a.real * b.real - a.imag * b.imag",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real - a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return a.real * b.real + a.imag * b.imag",
      "mutated_line": "return a.real * b.real * (a.imag * b.imag)",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real * (a.imag * b.imag)\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "base_vector = s.target - s.source",
      "mutated_line": "base_vector = s.target + s.source",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target + s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "base_vector = s.target - s.source",
      "mutated_line": "base_vector = s.target * s.source",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target * s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)",
      "mutated_line": "prj_ratio = dot(p - s.source, base_vector) * pow(abs(base_vector), 2)",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) * pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)",
      "mutated_line": "prj_ratio = dot(p - s.source, base_vector) // pow(abs(base_vector), 2)",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) // pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return s.source + base_vector * prj_ratio",
      "mutated_line": "return s.source - base_vector * prj_ratio",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source - base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return s.source + base_vector * prj_ratio",
      "mutated_line": "return s.source * (base_vector * prj_ratio)",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source * (base_vector * prj_ratio)\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "__slots__ = ('source', 'target')",
      "mutated_line": "__slots__ = ('', 'target')",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "__slots__ = ('source', 'target')",
      "mutated_line": "__slots__ = ('source', '')",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', '')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return a.real * b.real + a.imag * b.imag",
      "mutated_line": "return a.real / b.real + a.imag * b.imag",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real / b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return a.real * b.real + a.imag * b.imag",
      "mutated_line": "return a.real + b.real + a.imag * b.imag",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real + b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return a.real * b.real + a.imag * b.imag",
      "mutated_line": "return a.real ** b.real + a.imag * b.imag",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real ** b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return a.real * b.real + a.imag * b.imag",
      "mutated_line": "return a.real * b.real + a.imag / b.imag",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag / b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return a.real * b.real + a.imag * b.imag",
      "mutated_line": "return a.real * b.real + (a.imag + b.imag)",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + (a.imag + b.imag)\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return a.real * b.real + a.imag * b.imag",
      "mutated_line": "return a.real * b.real + a.imag ** b.imag",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag ** b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return s.source + base_vector * prj_ratio",
      "mutated_line": "return s.source + base_vector / prj_ratio",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector / prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return s.source + base_vector * prj_ratio",
      "mutated_line": "return s.source + (base_vector + prj_ratio)",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + (base_vector + prj_ratio)\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "return s.source + base_vector * prj_ratio",
      "mutated_line": "return s.source + base_vector ** prj_ratio",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector ** prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p1_complex = complex(p1[0], p1[1])",
      "mutated_line": "p1_complex = complex(p1[1], p1[1])",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[1], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p1_complex = complex(p1[0], p1[1])",
      "mutated_line": "p1_complex = complex(p1[-1], p1[1])",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[-1], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p1_complex = complex(p1[0], p1[1])",
      "mutated_line": "p1_complex = complex(p1[1], p1[1])",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[1], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p1_complex = complex(p1[0], p1[1])",
      "mutated_line": "p1_complex = complex(p1[0], p1[2])",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[2])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p1_complex = complex(p1[0], p1[1])",
      "mutated_line": "p1_complex = complex(p1[0], p1[0])",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[0])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p1_complex = complex(p1[0], p1[1])",
      "mutated_line": "p1_complex = complex(p1[0], p1[0])",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[0])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "p1_complex = complex(p1[0], p1[1])",
      "mutated_line": "p1_complex = complex(p1[0], p1[-1])",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[-1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p2_complex = complex(p2[0], p2[1])",
      "mutated_line": "p2_complex = complex(p2[1], p2[1])",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[1], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p2_complex = complex(p2[0], p2[1])",
      "mutated_line": "p2_complex = complex(p2[-1], p2[1])",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[-1], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p2_complex = complex(p2[0], p2[1])",
      "mutated_line": "p2_complex = complex(p2[1], p2[1])",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[1], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p2_complex = complex(p2[0], p2[1])",
      "mutated_line": "p2_complex = complex(p2[0], p2[2])",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[2])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p2_complex = complex(p2[0], p2[1])",
      "mutated_line": "p2_complex = complex(p2[0], p2[0])",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[0])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p2_complex = complex(p2[0], p2[1])",
      "mutated_line": "p2_complex = complex(p2[0], p2[0])",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[0])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "p2_complex = complex(p2[0], p2[1])",
      "mutated_line": "p2_complex = complex(p2[0], p2[-1])",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[-1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)",
      "mutated_line": "prj_ratio = dot(p + s.source, base_vector) / pow(abs(base_vector), 2)",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p + s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)",
      "mutated_line": "prj_ratio = dot(p * s.source, base_vector) / pow(abs(base_vector), 2)",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p * s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)",
      "mutated_line": "prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 3)",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 3)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)",
      "mutated_line": "prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 1)",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 1)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)",
      "mutated_line": "prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 0)",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 0)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)",
      "mutated_line": "prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 1)",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 1)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)",
      "mutated_line": "prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), -2)",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), -2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "p_complex = complex(point[0], point[1])",
      "mutated_line": "p_complex = complex(point[1], point[1])",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[1], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "p_complex = complex(point[0], point[1])",
      "mutated_line": "p_complex = complex(point[-1], point[1])",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[-1], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "p_complex = complex(point[0], point[1])",
      "mutated_line": "p_complex = complex(point[1], point[1])",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[1], point[1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "p_complex = complex(point[0], point[1])",
      "mutated_line": "p_complex = complex(point[0], point[2])",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[2])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "p_complex = complex(point[0], point[1])",
      "mutated_line": "p_complex = complex(point[0], point[0])",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[0])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "p_complex = complex(point[0], point[1])",
      "mutated_line": "p_complex = complex(point[0], point[0])",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[0])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "p_complex = complex(point[0], point[1])",
      "mutated_line": "p_complex = complex(point[0], point[-1])",
      "code": "def calculate_projection(p1, p2, points):\n\n    class Segment(object):\n        __slots__ = ('source', 'target')\n\n        def __init__(self, source, target):\n            self.source = complex(source)\n            self.target = complex(target)\n\n    def dot(a, b):\n        return a.real * b.real + a.imag * b.imag\n\n    def project(s, p):\n        base_vector = s.target - s.source\n        prj_ratio = dot(p - s.source, base_vector) / pow(abs(base_vector), 2)\n        return s.source + base_vector * prj_ratio\n    p1_complex = complex(p1[0], p1[1])\n    p2_complex = complex(p2[0], p2[1])\n    prj_segment = Segment(p1_complex, p2_complex)\n    projections = []\n    for point in points:\n        p_complex = complex(point[0], point[-1])\n        prj = project(prj_segment, p_complex)\n        projections.append((prj.real, prj.imag))\n    return projections"
    }
  ]
}