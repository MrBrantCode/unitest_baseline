{
  "task_id": "taco_16279",
  "entry_point": "find_min_cost_to_reach_n",
  "mutant_count": 98,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "cost = [float('inf')] * (N + 1)",
      "mutated_line": "cost = [float('inf')] / (N + 1)",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] / (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "cost = [float('inf')] * (N + 1)",
      "mutated_line": "cost = [float('inf')] + (N + 1)",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] + (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "cost = [float('inf')] * (N + 1)",
      "mutated_line": "cost = [float('inf')] ** (N + 1)",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] ** (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cost[1] = 0",
      "mutated_line": "cost[1] = 1",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 1\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cost[1] = 0",
      "mutated_line": "cost[1] = -1",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = -1\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cost[1] = 0",
      "mutated_line": "cost[1] = 1",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 1\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "flag = [False] * (N + 1)",
      "mutated_line": "flag = [False] / (N + 1)",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] / (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "flag = [False] * (N + 1)",
      "mutated_line": "flag = [False] + (N + 1)",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] + (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "flag = [False] * (N + 1)",
      "mutated_line": "flag = [False] ** (N + 1)",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] ** (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(2, N):",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(2, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(0, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(0, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(-1, N):",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(-1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "cost = [float('inf')] * (N + 1)",
      "mutated_line": "cost = [float('inf')] * (N - 1)",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N - 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "cost = [float('inf')] * (N + 1)",
      "mutated_line": "cost = [float('inf')] * (N * 1)",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N * 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cost[1] = 0",
      "mutated_line": "cost[2] = 0",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[2] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cost[1] = 0",
      "mutated_line": "cost[0] = 0",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[0] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cost[1] = 0",
      "mutated_line": "cost[0] = 0",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[0] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cost[1] = 0",
      "mutated_line": "cost[-1] = 0",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[-1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "flag = [False] * (N + 1)",
      "mutated_line": "flag = [False] * (N - 1)",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N - 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "flag = [False] * (N + 1)",
      "mutated_line": "flag = [False] * (N * 1)",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N * 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "flag[p] = True",
      "mutated_line": "flag[p] = False",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = False\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cost = [float('inf')] * (N + 1)",
      "mutated_line": "cost = [float('inf')] * (N + 2)",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 2)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cost = [float('inf')] * (N + 1)",
      "mutated_line": "cost = [float('inf')] * (N + 0)",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 0)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cost = [float('inf')] * (N + 1)",
      "mutated_line": "cost = [float('inf')] * (N + 0)",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 0)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cost = [float('inf')] * (N + 1)",
      "mutated_line": "cost = [float('inf')] * (N + -1)",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + -1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "flag = [False] * (N + 1)",
      "mutated_line": "flag = [True] * (N + 1)",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [True] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "flag = [False] * (N + 1)",
      "mutated_line": "flag = [False] * (N + 2)",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 2)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "flag = [False] * (N + 1)",
      "mutated_line": "flag = [False] * (N + 0)",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 0)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "flag = [False] * (N + 1)",
      "mutated_line": "flag = [False] * (N + 0)",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 0)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "flag = [False] * (N + 1)",
      "mutated_line": "flag = [False] * (N + -1)",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + -1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "start = [[0, 1]]",
      "mutated_line": "start = [[1, 1]]",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[1, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "start = [[0, 1]]",
      "mutated_line": "start = [[-1, 1]]",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[-1, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "start = [[0, 1]]",
      "mutated_line": "start = [[1, 1]]",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[1, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "start = [[0, 1]]",
      "mutated_line": "start = [[0, 2]]",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 2]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "start = [[0, 1]]",
      "mutated_line": "start = [[0, 0]]",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 0]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "start = [[0, 1]]",
      "mutated_line": "start = [[0, 0]]",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 0]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "start = [[0, 1]]",
      "mutated_line": "start = [[0, -1]]",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, -1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if cost[e[0]] > cost[p] + e[1]:",
      "mutated_line": "if cost[e[0]] >= cost[p] + e[1]:",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] >= cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if cost[e[0]] > cost[p] + e[1]:",
      "mutated_line": "if cost[e[0]] <= cost[p] + e[1]:",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] <= cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if cost[e[0]] > cost[p] + e[1]:",
      "mutated_line": "if cost[e[0]] != cost[p] + e[1]:",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] != cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "adj = [[] for _ in range(N + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N - 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "adj = [[] for _ in range(N + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N * 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "adj[u].append([v, 0])",
      "mutated_line": "adj[u].append([v, 1])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 1])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "adj[u].append([v, 0])",
      "mutated_line": "adj[u].append([v, -1])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, -1])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "adj[u].append([v, 0])",
      "mutated_line": "adj[u].append([v, 1])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 1])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "adj[v].append([u, 0])",
      "mutated_line": "adj[v].append([u, 1])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 1])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "adj[v].append([u, 0])",
      "mutated_line": "adj[v].append([u, -1])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, -1])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "adj[v].append([u, 0])",
      "mutated_line": "adj[v].append([u, 1])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 1])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "adj[i].append([i + 1, 1])",
      "mutated_line": "adj[i].append([i - 1, 1])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i - 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "adj[i].append([i + 1, 1])",
      "mutated_line": "adj[i].append([i * 1, 1])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i * 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "adj[i].append([i + 1, 1])",
      "mutated_line": "adj[i].append([i + 1, 2])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 2])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "adj[i].append([i + 1, 1])",
      "mutated_line": "adj[i].append([i + 1, 0])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 0])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "adj[i].append([i + 1, 1])",
      "mutated_line": "adj[i].append([i + 1, 0])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 0])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "adj[i].append([i + 1, 1])",
      "mutated_line": "adj[i].append([i + 1, -1])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, -1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "adj[i + 1].append([i, 1])",
      "mutated_line": "adj[i + 1].append([i, 2])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 2])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "adj[i + 1].append([i, 1])",
      "mutated_line": "adj[i + 1].append([i, 0])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 0])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "adj[i + 1].append([i, 1])",
      "mutated_line": "adj[i + 1].append([i, 0])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 0])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "adj[i + 1].append([i, 1])",
      "mutated_line": "adj[i + 1].append([i, -1])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, -1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "cost = [float('inf')] * (N + 1)",
      "mutated_line": "cost = [float('')] * (N + 1)",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if cost[e[0]] > cost[p] + e[1]:",
      "mutated_line": "if cost[e[0]] > cost[p] - e[1]:",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] - e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if cost[e[0]] > cost[p] + e[1]:",
      "mutated_line": "if cost[e[0]] > cost[p] * e[1]:",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] * e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "cost[e[0]] = cost[p] + e[1]",
      "mutated_line": "cost[e[0]] = cost[p] - e[1]",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] - e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "cost[e[0]] = cost[p] + e[1]",
      "mutated_line": "cost[e[0]] = cost[p] * e[1]",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] * e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "adj = [[] for _ in range(N + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 2)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "adj = [[] for _ in range(N + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 0)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "adj = [[] for _ in range(N + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 0)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "adj = [[] for _ in range(N + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + -1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "adj[i].append([i + 1, 1])",
      "mutated_line": "adj[i].append([i + 2, 1])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 2, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "adj[i].append([i + 1, 1])",
      "mutated_line": "adj[i].append([i + 0, 1])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 0, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "adj[i].append([i + 1, 1])",
      "mutated_line": "adj[i].append([i + 0, 1])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 0, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "adj[i].append([i + 1, 1])",
      "mutated_line": "adj[i].append([i + -1, 1])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + -1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "adj[i + 1].append([i, 1])",
      "mutated_line": "adj[i - 1].append([i, 1])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i - 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "adj[i + 1].append([i, 1])",
      "mutated_line": "adj[i * 1].append([i, 1])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i * 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "adj[i + 1].append([i, 1])",
      "mutated_line": "adj[i + 2].append([i, 1])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 2].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "adj[i + 1].append([i, 1])",
      "mutated_line": "adj[i + 0].append([i, 1])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 0].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "adj[i + 1].append([i, 1])",
      "mutated_line": "adj[i + 0].append([i, 1])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 0].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "adj[i + 1].append([i, 1])",
      "mutated_line": "adj[i + -1].append([i, 1])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + -1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if cost[e[0]] > cost[p] + e[1]:",
      "mutated_line": "if cost[e[1]] > cost[p] + e[1]:",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[1]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if cost[e[0]] > cost[p] + e[1]:",
      "mutated_line": "if cost[e[-1]] > cost[p] + e[1]:",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[-1]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if cost[e[0]] > cost[p] + e[1]:",
      "mutated_line": "if cost[e[1]] > cost[p] + e[1]:",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[1]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if cost[e[0]] > cost[p] + e[1]:",
      "mutated_line": "if cost[e[0]] > cost[p] + e[2]:",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[2]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if cost[e[0]] > cost[p] + e[1]:",
      "mutated_line": "if cost[e[0]] > cost[p] + e[0]:",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[0]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if cost[e[0]] > cost[p] + e[1]:",
      "mutated_line": "if cost[e[0]] > cost[p] + e[0]:",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[0]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if cost[e[0]] > cost[p] + e[1]:",
      "mutated_line": "if cost[e[0]] > cost[p] + e[-1]:",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[-1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cost[e[0]] = cost[p] + e[1]",
      "mutated_line": "cost[e[1]] = cost[p] + e[1]",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[1]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cost[e[0]] = cost[p] + e[1]",
      "mutated_line": "cost[e[-1]] = cost[p] + e[1]",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[-1]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cost[e[0]] = cost[p] + e[1]",
      "mutated_line": "cost[e[1]] = cost[p] + e[1]",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[1]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cost[e[0]] = cost[p] + e[1]",
      "mutated_line": "cost[e[0]] = cost[p] + e[2]",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[2]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cost[e[0]] = cost[p] + e[1]",
      "mutated_line": "cost[e[0]] = cost[p] + e[0]",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[0]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cost[e[0]] = cost[p] + e[1]",
      "mutated_line": "cost[e[0]] = cost[p] + e[0]",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[0]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "cost[e[0]] = cost[p] + e[1]",
      "mutated_line": "cost[e[0]] = cost[p] + e[-1]",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[-1]\n                heapq.heappush(start, [cost[e[0]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "heapq.heappush(start, [cost[e[0]], e[0]])",
      "mutated_line": "heapq.heappush(start, [cost[e[0]], e[1]])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[1]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "heapq.heappush(start, [cost[e[0]], e[0]])",
      "mutated_line": "heapq.heappush(start, [cost[e[0]], e[-1]])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[-1]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "heapq.heappush(start, [cost[e[0]], e[0]])",
      "mutated_line": "heapq.heappush(start, [cost[e[0]], e[1]])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[0]], e[1]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "heapq.heappush(start, [cost[e[0]], e[0]])",
      "mutated_line": "heapq.heappush(start, [cost[e[1]], e[0]])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[1]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "heapq.heappush(start, [cost[e[0]], e[0]])",
      "mutated_line": "heapq.heappush(start, [cost[e[-1]], e[0]])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[-1]], e[0]])\n    return cost[N]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "heapq.heappush(start, [cost[e[0]], e[0]])",
      "mutated_line": "heapq.heappush(start, [cost[e[1]], e[0]])",
      "code": "import heapq\n\ndef find_min_cost_to_reach_n(N, M, edges):\n    adj = [[] for _ in range(N + 1)]\n    for (u, v) in edges:\n        adj[u].append([v, 0])\n        adj[v].append([u, 0])\n    for i in range(1, N):\n        adj[i].append([i + 1, 1])\n        adj[i + 1].append([i, 1])\n    cost = [float('inf')] * (N + 1)\n    cost[1] = 0\n    flag = [False] * (N + 1)\n    start = [[0, 1]]\n    while start:\n        (_, p) = heapq.heappop(start)\n        if flag[p]:\n            continue\n        flag[p] = True\n        for e in adj[p]:\n            if cost[e[0]] > cost[p] + e[1]:\n                cost[e[0]] = cost[p] + e[1]\n                heapq.heappush(start, [cost[e[1]], e[0]])\n    return cost[N]"
    }
  ]
}