{
  "task_id": "taco_1684",
  "entry_point": "calculate_divisors_count",
  "mutant_count": 237,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "ans = 1",
      "mutated_line": "ans = 2",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 2\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "ans = 1",
      "mutated_line": "ans = 0",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 0\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "ans = 1",
      "mutated_line": "ans = 0",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 0\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "ans = 1",
      "mutated_line": "ans = -1",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = -1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 998244354",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244354\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 998244352",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244352\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 0",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 0\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 1",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 1\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = -998244353",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = -998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if int(c ** 0.25 + 0.0001) ** 4 == c:",
      "mutated_line": "if int(c ** 0.25 + 0.0001) ** 4 != c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 != c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = ans * (d[i] + 1) % MOD",
      "mutated_line": "ans = ans * (d[i] + 1) * MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) * MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = ans * (d[i] + 1) % MOD",
      "mutated_line": "ans = ans * (d[i] + 1) + MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) + MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "ans = ans * (skipped[i] + 1) ** 2 % MOD",
      "mutated_line": "ans = ans * (skipped[i] + 1) ** 2 * MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 * MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "ans = ans * (skipped[i] + 1) ** 2 % MOD",
      "mutated_line": "ans = ans * (skipped[i] + 1) ** 2 + MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 + MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if int(c ** 0.25 + 0.0001) ** 4 == c:",
      "mutated_line": "if int(c ** 0.25 + 0.0001) * 4 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) * 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if int(c ** 0.25 + 0.0001) ** 4 == c:",
      "mutated_line": "if int(c ** 0.25 + 0.0001) + 4 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) + 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if p not in d:",
      "mutated_line": "if p in d:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "d[p] += 4",
      "mutated_line": "d[p] -= 4",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] -= 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 != c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 != c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if bad[i] == a[j] or g == 1:",
      "mutated_line": "if bad[i] == a[j] and g == 1:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] and g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if bad[i] not in skipped:",
      "mutated_line": "if bad[i] in skipped:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "ASR",
      "lineno": 49,
      "original_line": "skipped[bad[i]] += 1",
      "mutated_line": "skipped[bad[i]] -= 1",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] -= 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = ans * (d[i] + 1) % MOD",
      "mutated_line": "ans = ans / (d[i] + 1) % MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans / (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = ans * (d[i] + 1) % MOD",
      "mutated_line": "ans = (ans + (d[i] + 1)) % MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = (ans + (d[i] + 1)) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = ans * (d[i] + 1) % MOD",
      "mutated_line": "ans = ans ** (d[i] + 1) % MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans ** (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "ans = ans * (skipped[i] + 1) ** 2 % MOD",
      "mutated_line": "ans = ans / (skipped[i] + 1) ** 2 % MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans / (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "ans = ans * (skipped[i] + 1) ** 2 % MOD",
      "mutated_line": "ans = (ans + (skipped[i] + 1) ** 2) % MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = (ans + (skipped[i] + 1) ** 2) % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "ans = ans * (skipped[i] + 1) ** 2 % MOD",
      "mutated_line": "ans = ans ** (skipped[i] + 1) ** 2 % MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans ** (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if int(c ** 0.25 + 0.0001) ** 4 == c:",
      "mutated_line": "if int(c ** 0.25 + 0.0001) ** 5 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 5 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if int(c ** 0.25 + 0.0001) ** 4 == c:",
      "mutated_line": "if int(c ** 0.25 + 0.0001) ** 3 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 3 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if int(c ** 0.25 + 0.0001) ** 4 == c:",
      "mutated_line": "if int(c ** 0.25 + 0.0001) ** 0 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 0 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if int(c ** 0.25 + 0.0001) ** 4 == c:",
      "mutated_line": "if int(c ** 0.25 + 0.0001) ** 1 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 1 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if int(c ** 0.25 + 0.0001) ** 4 == c:",
      "mutated_line": "if int(c ** 0.25 + 0.0001) ** -4 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** -4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "p = int(c ** 0.25 + 0.0001)",
      "mutated_line": "p = int(c ** 0.25 - 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 - 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "p = int(c ** 0.25 + 0.0001)",
      "mutated_line": "p = int(c ** 0.25 * 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 * 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[p] = 4",
      "mutated_line": "d[p] = 5",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 5\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[p] = 4",
      "mutated_line": "d[p] = 3",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[p] = 4",
      "mutated_line": "d[p] = 0",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 0\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[p] = 4",
      "mutated_line": "d[p] = 1",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 1\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "d[p] = 4",
      "mutated_line": "d[p] = -4",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = -4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "d[p] += 4",
      "mutated_line": "d[p] += 5",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 5\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "d[p] += 4",
      "mutated_line": "d[p] += 3",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 3\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "d[p] += 4",
      "mutated_line": "d[p] += 0",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 0\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "d[p] += 4",
      "mutated_line": "d[p] += 1",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 1\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "d[p] += 4",
      "mutated_line": "d[p] += -4",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += -4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (1 / 3) + 0.0001) * 3 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) * 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (1 / 3) + 0.0001) + 3 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) + 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if p not in d:",
      "mutated_line": "if p in d:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "d[p] += 3",
      "mutated_line": "d[p] -= 3",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] -= 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "elif int(c ** 0.5 + 0.001) ** 2 == c:",
      "mutated_line": "elif int(c ** 0.5 + 0.001) ** 2 != c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 != c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if bad[i] == a[j] or g == 1:",
      "mutated_line": "if bad[i] != a[j] or g == 1:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] != a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if bad[i] == a[j] or g == 1:",
      "mutated_line": "if bad[i] == a[j] or g != 1:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g != 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if g not in d:",
      "mutated_line": "if g in d:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "d[g] += 1",
      "mutated_line": "d[g] -= 1",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] -= 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if bad[i] // g not in d:",
      "mutated_line": "if bad[i] // g in d:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "d[bad[i] // g] += 1",
      "mutated_line": "d[bad[i] // g] -= 1",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] -= 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "skipped[bad[i]] = 1",
      "mutated_line": "skipped[bad[i]] = 2",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 2\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "skipped[bad[i]] = 1",
      "mutated_line": "skipped[bad[i]] = 0",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 0\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "skipped[bad[i]] = 1",
      "mutated_line": "skipped[bad[i]] = 0",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 0\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "skipped[bad[i]] = 1",
      "mutated_line": "skipped[bad[i]] = -1",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = -1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "skipped[bad[i]] += 1",
      "mutated_line": "skipped[bad[i]] += 2",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 2\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "skipped[bad[i]] += 1",
      "mutated_line": "skipped[bad[i]] += 0",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 0\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "skipped[bad[i]] += 1",
      "mutated_line": "skipped[bad[i]] += 0",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 0\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "skipped[bad[i]] += 1",
      "mutated_line": "skipped[bad[i]] += -1",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += -1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = ans * (d[i] + 1) % MOD",
      "mutated_line": "ans = ans * (d[i] - 1) % MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] - 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "ans = ans * (d[i] + 1) % MOD",
      "mutated_line": "ans = ans * (d[i] * 1) % MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] * 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "ans = ans * (skipped[i] + 1) ** 2 % MOD",
      "mutated_line": "ans = ans * ((skipped[i] + 1) * 2) % MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * ((skipped[i] + 1) * 2) % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "ans = ans * (skipped[i] + 1) ** 2 % MOD",
      "mutated_line": "ans = ans * (skipped[i] + 1 + 2) % MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1 + 2) % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if int(c ** 0.25 + 0.0001) ** 4 == c:",
      "mutated_line": "if int(c ** 0.25 - 0.0001) ** 4 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 - 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if int(c ** 0.25 + 0.0001) ** 4 == c:",
      "mutated_line": "if int(c ** 0.25 * 0.0001) ** 4 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 * 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "p = int(c ** 0.25 + 0.0001)",
      "mutated_line": "p = int(c * 0.25 + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c * 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "p = int(c ** 0.25 + 0.0001)",
      "mutated_line": "p = int(c + 0.25 + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c + 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p = int(c ** 0.25 + 0.0001)",
      "mutated_line": "p = int(c ** 0.25 + 1.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 1.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p = int(c ** 0.25 + 0.0001)",
      "mutated_line": "p = int(c ** 0.25 + -0.9999)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + -0.9999)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p = int(c ** 0.25 + 0.0001)",
      "mutated_line": "p = int(c ** 0.25 + 0)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p = int(c ** 0.25 + 0.0001)",
      "mutated_line": "p = int(c ** 0.25 + 1)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 1)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p = int(c ** 0.25 + 0.0001)",
      "mutated_line": "p = int(c ** 0.25 + -0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + -0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (1 / 3) + 0.0001) ** 4 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 4 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (1 / 3) + 0.0001) ** 2 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 2 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (1 / 3) + 0.0001) ** 0 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 0 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (1 / 3) + 0.0001) ** 1 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 1 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (1 / 3) + 0.0001) ** -3 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** -3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "p = int(c ** (1 / 3) + 0.0001)",
      "mutated_line": "p = int(c ** (1 / 3) - 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) - 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "p = int(c ** (1 / 3) + 0.0001)",
      "mutated_line": "p = int(c ** (1 / 3) * 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) * 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d[p] = 3",
      "mutated_line": "d[p] = 4",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d[p] = 3",
      "mutated_line": "d[p] = 2",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d[p] = 3",
      "mutated_line": "d[p] = 0",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 0\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d[p] = 3",
      "mutated_line": "d[p] = 1",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 1\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d[p] = 3",
      "mutated_line": "d[p] = -3",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = -3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "d[p] += 3",
      "mutated_line": "d[p] += 4",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 4\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "d[p] += 3",
      "mutated_line": "d[p] += 2",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 2\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "d[p] += 3",
      "mutated_line": "d[p] += 0",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 0\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "d[p] += 3",
      "mutated_line": "d[p] += 1",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 1\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "d[p] += 3",
      "mutated_line": "d[p] += -3",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += -3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "elif int(c ** 0.5 + 0.001) ** 2 == c:",
      "mutated_line": "elif int(c ** 0.5 + 0.001) * 2 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) * 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "elif int(c ** 0.5 + 0.001) ** 2 == c:",
      "mutated_line": "elif int(c ** 0.5 + 0.001) + 2 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) + 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if p not in d:",
      "mutated_line": "if p in d:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "d[p] += 2",
      "mutated_line": "d[p] -= 2",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] -= 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if bad[i] == a[j] or g == 1:",
      "mutated_line": "if bad[i] == a[j] or g == 2:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 2:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if bad[i] == a[j] or g == 1:",
      "mutated_line": "if bad[i] == a[j] or g == 0:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 0:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if bad[i] == a[j] or g == 1:",
      "mutated_line": "if bad[i] == a[j] or g == 0:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 0:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if bad[i] == a[j] or g == 1:",
      "mutated_line": "if bad[i] == a[j] or g == -1:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == -1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[g] = 1",
      "mutated_line": "d[g] = 2",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 2\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[g] = 1",
      "mutated_line": "d[g] = 0",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 0\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[g] = 1",
      "mutated_line": "d[g] = 0",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 0\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "d[g] = 1",
      "mutated_line": "d[g] = -1",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = -1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "d[g] += 1",
      "mutated_line": "d[g] += 2",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 2\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "d[g] += 1",
      "mutated_line": "d[g] += 0",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 0\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "d[g] += 1",
      "mutated_line": "d[g] += 0",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 0\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "d[g] += 1",
      "mutated_line": "d[g] += -1",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += -1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if bad[i] // g not in d:",
      "mutated_line": "if bad[i] / g not in d:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] / g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if bad[i] // g not in d:",
      "mutated_line": "if bad[i] * g not in d:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] * g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "d[bad[i] // g] = 1",
      "mutated_line": "d[bad[i] // g] = 2",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 2\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "d[bad[i] // g] = 1",
      "mutated_line": "d[bad[i] // g] = 0",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 0\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "d[bad[i] // g] = 1",
      "mutated_line": "d[bad[i] // g] = 0",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 0\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "d[bad[i] // g] = 1",
      "mutated_line": "d[bad[i] // g] = -1",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = -1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "d[bad[i] // g] += 1",
      "mutated_line": "d[bad[i] // g] += 2",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 2\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "d[bad[i] // g] += 1",
      "mutated_line": "d[bad[i] // g] += 0",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 0\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "d[bad[i] // g] += 1",
      "mutated_line": "d[bad[i] // g] += 0",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 0\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "d[bad[i] // g] += 1",
      "mutated_line": "d[bad[i] // g] += -1",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += -1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = ans * (d[i] + 1) % MOD",
      "mutated_line": "ans = ans * (d[i] + 2) % MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 2) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = ans * (d[i] + 1) % MOD",
      "mutated_line": "ans = ans * (d[i] + 0) % MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 0) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = ans * (d[i] + 1) % MOD",
      "mutated_line": "ans = ans * (d[i] + 0) % MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 0) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "ans = ans * (d[i] + 1) % MOD",
      "mutated_line": "ans = ans * (d[i] + -1) % MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + -1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "ans = ans * (skipped[i] + 1) ** 2 % MOD",
      "mutated_line": "ans = ans * (skipped[i] - 1) ** 2 % MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] - 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "ans = ans * (skipped[i] + 1) ** 2 % MOD",
      "mutated_line": "ans = ans * (skipped[i] * 1) ** 2 % MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] * 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = ans * (skipped[i] + 1) ** 2 % MOD",
      "mutated_line": "ans = ans * (skipped[i] + 1) ** 3 % MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 3 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = ans * (skipped[i] + 1) ** 2 % MOD",
      "mutated_line": "ans = ans * (skipped[i] + 1) ** 1 % MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 1 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = ans * (skipped[i] + 1) ** 2 % MOD",
      "mutated_line": "ans = ans * (skipped[i] + 1) ** 0 % MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 0 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = ans * (skipped[i] + 1) ** 2 % MOD",
      "mutated_line": "ans = ans * (skipped[i] + 1) ** 1 % MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 1 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = ans * (skipped[i] + 1) ** 2 % MOD",
      "mutated_line": "ans = ans * (skipped[i] + 1) ** -2 % MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** -2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if int(c ** 0.25 + 0.0001) ** 4 == c:",
      "mutated_line": "if int(c * 0.25 + 0.0001) ** 4 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c * 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if int(c ** 0.25 + 0.0001) ** 4 == c:",
      "mutated_line": "if int(c + 0.25 + 0.0001) ** 4 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c + 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if int(c ** 0.25 + 0.0001) ** 4 == c:",
      "mutated_line": "if int(c ** 0.25 + 1.0001) ** 4 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 1.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if int(c ** 0.25 + 0.0001) ** 4 == c:",
      "mutated_line": "if int(c ** 0.25 + -0.9999) ** 4 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + -0.9999) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if int(c ** 0.25 + 0.0001) ** 4 == c:",
      "mutated_line": "if int(c ** 0.25 + 0) ** 4 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if int(c ** 0.25 + 0.0001) ** 4 == c:",
      "mutated_line": "if int(c ** 0.25 + 1) ** 4 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 1) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if int(c ** 0.25 + 0.0001) ** 4 == c:",
      "mutated_line": "if int(c ** 0.25 + -0.0001) ** 4 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + -0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p = int(c ** 0.25 + 0.0001)",
      "mutated_line": "p = int(c ** 1.25 + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 1.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p = int(c ** 0.25 + 0.0001)",
      "mutated_line": "p = int(c ** -0.75 + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** -0.75 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p = int(c ** 0.25 + 0.0001)",
      "mutated_line": "p = int(c ** 0 + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p = int(c ** 0.25 + 0.0001)",
      "mutated_line": "p = int(c ** 1 + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 1 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p = int(c ** 0.25 + 0.0001)",
      "mutated_line": "p = int(c ** -0.25 + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** -0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (1 / 3) - 0.0001) ** 3 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) - 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (1 / 3) * 0.0001) ** 3 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) * 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "p = int(c ** (1 / 3) + 0.0001)",
      "mutated_line": "p = int(c * (1 / 3) + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c * (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "p = int(c ** (1 / 3) + 0.0001)",
      "mutated_line": "p = int(c + 1 / 3 + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c + 1 / 3 + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p = int(c ** (1 / 3) + 0.0001)",
      "mutated_line": "p = int(c ** (1 / 3) + 1.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 1.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p = int(c ** (1 / 3) + 0.0001)",
      "mutated_line": "p = int(c ** (1 / 3) + -0.9999)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + -0.9999)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p = int(c ** (1 / 3) + 0.0001)",
      "mutated_line": "p = int(c ** (1 / 3) + 0)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p = int(c ** (1 / 3) + 0.0001)",
      "mutated_line": "p = int(c ** (1 / 3) + 1)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 1)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p = int(c ** (1 / 3) + 0.0001)",
      "mutated_line": "p = int(c ** (1 / 3) + -0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + -0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif int(c ** 0.5 + 0.001) ** 2 == c:",
      "mutated_line": "elif int(c ** 0.5 + 0.001) ** 3 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 3 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif int(c ** 0.5 + 0.001) ** 2 == c:",
      "mutated_line": "elif int(c ** 0.5 + 0.001) ** 1 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 1 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif int(c ** 0.5 + 0.001) ** 2 == c:",
      "mutated_line": "elif int(c ** 0.5 + 0.001) ** 0 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 0 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif int(c ** 0.5 + 0.001) ** 2 == c:",
      "mutated_line": "elif int(c ** 0.5 + 0.001) ** 1 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 1 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif int(c ** 0.5 + 0.001) ** 2 == c:",
      "mutated_line": "elif int(c ** 0.5 + 0.001) ** -2 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** -2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "p = int(c ** 0.5 + 0.0001)",
      "mutated_line": "p = int(c ** 0.5 - 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 - 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "p = int(c ** 0.5 + 0.0001)",
      "mutated_line": "p = int(c ** 0.5 * 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 * 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "d[p] = 2",
      "mutated_line": "d[p] = 3",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "d[p] = 2",
      "mutated_line": "d[p] = 1",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 1\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "d[p] = 2",
      "mutated_line": "d[p] = 0",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 0\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "d[p] = 2",
      "mutated_line": "d[p] = 1",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 1\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "d[p] = 2",
      "mutated_line": "d[p] = -2",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = -2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "d[p] += 2",
      "mutated_line": "d[p] += 3",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 3\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "d[p] += 2",
      "mutated_line": "d[p] += 1",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 1\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "d[p] += 2",
      "mutated_line": "d[p] += 0",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 0\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "d[p] += 2",
      "mutated_line": "d[p] += 1",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 1\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "d[p] += 2",
      "mutated_line": "d[p] += -2",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += -2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "d[bad[i] // g] = 1",
      "mutated_line": "d[bad[i] / g] = 1",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] / g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "d[bad[i] // g] = 1",
      "mutated_line": "d[bad[i] * g] = 1",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] * g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "d[bad[i] // g] += 1",
      "mutated_line": "d[bad[i] / g] += 1",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] / g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "d[bad[i] // g] += 1",
      "mutated_line": "d[bad[i] * g] += 1",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] * g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = ans * (skipped[i] + 1) ** 2 % MOD",
      "mutated_line": "ans = ans * (skipped[i] + 2) ** 2 % MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 2) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = ans * (skipped[i] + 1) ** 2 % MOD",
      "mutated_line": "ans = ans * (skipped[i] + 0) ** 2 % MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 0) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = ans * (skipped[i] + 1) ** 2 % MOD",
      "mutated_line": "ans = ans * (skipped[i] + 0) ** 2 % MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 0) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ans = ans * (skipped[i] + 1) ** 2 % MOD",
      "mutated_line": "ans = ans * (skipped[i] + -1) ** 2 % MOD",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + -1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if int(c ** 0.25 + 0.0001) ** 4 == c:",
      "mutated_line": "if int(c ** 1.25 + 0.0001) ** 4 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 1.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if int(c ** 0.25 + 0.0001) ** 4 == c:",
      "mutated_line": "if int(c ** -0.75 + 0.0001) ** 4 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** -0.75 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if int(c ** 0.25 + 0.0001) ** 4 == c:",
      "mutated_line": "if int(c ** 0 + 0.0001) ** 4 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if int(c ** 0.25 + 0.0001) ** 4 == c:",
      "mutated_line": "if int(c ** 1 + 0.0001) ** 4 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 1 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if int(c ** 0.25 + 0.0001) ** 4 == c:",
      "mutated_line": "if int(c ** -0.25 + 0.0001) ** 4 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** -0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c * (1 / 3) + 0.0001) ** 3 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c * (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c + 1 / 3 + 0.0001) ** 3 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c + 1 / 3 + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (1 / 3) + 1.0001) ** 3 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 1.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (1 / 3) + -0.9999) ** 3 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + -0.9999) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (1 / 3) + 0) ** 3 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (1 / 3) + 1) ** 3 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 1) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (1 / 3) + -0.0001) ** 3 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + -0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "p = int(c ** (1 / 3) + 0.0001)",
      "mutated_line": "p = int(c ** (1 * 3) + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 * 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "p = int(c ** (1 / 3) + 0.0001)",
      "mutated_line": "p = int(c ** (1 // 3) + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 // 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "elif int(c ** 0.5 + 0.001) ** 2 == c:",
      "mutated_line": "elif int(c ** 0.5 - 0.001) ** 2 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 - 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "elif int(c ** 0.5 + 0.001) ** 2 == c:",
      "mutated_line": "elif int(c ** 0.5 * 0.001) ** 2 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 * 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "p = int(c ** 0.5 + 0.0001)",
      "mutated_line": "p = int(c * 0.5 + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c * 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "p = int(c ** 0.5 + 0.0001)",
      "mutated_line": "p = int(c + 0.5 + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c + 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p = int(c ** 0.5 + 0.0001)",
      "mutated_line": "p = int(c ** 0.5 + 1.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 1.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p = int(c ** 0.5 + 0.0001)",
      "mutated_line": "p = int(c ** 0.5 + -0.9999)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + -0.9999)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p = int(c ** 0.5 + 0.0001)",
      "mutated_line": "p = int(c ** 0.5 + 0)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p = int(c ** 0.5 + 0.0001)",
      "mutated_line": "p = int(c ** 0.5 + 1)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 1)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p = int(c ** 0.5 + 0.0001)",
      "mutated_line": "p = int(c ** 0.5 + -0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + -0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (1 * 3) + 0.0001) ** 3 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 * 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (1 // 3) + 0.0001) ** 3 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 // 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p = int(c ** (1 / 3) + 0.0001)",
      "mutated_line": "p = int(c ** (2 / 3) + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (2 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p = int(c ** (1 / 3) + 0.0001)",
      "mutated_line": "p = int(c ** (0 / 3) + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (0 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p = int(c ** (1 / 3) + 0.0001)",
      "mutated_line": "p = int(c ** (0 / 3) + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (0 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p = int(c ** (1 / 3) + 0.0001)",
      "mutated_line": "p = int(c ** (-1 / 3) + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (-1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p = int(c ** (1 / 3) + 0.0001)",
      "mutated_line": "p = int(c ** (1 / 4) + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 4) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p = int(c ** (1 / 3) + 0.0001)",
      "mutated_line": "p = int(c ** (1 / 2) + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 2) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p = int(c ** (1 / 3) + 0.0001)",
      "mutated_line": "p = int(c ** (1 / 0) + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 0) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p = int(c ** (1 / 3) + 0.0001)",
      "mutated_line": "p = int(c ** (1 / 1) + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 1) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p = int(c ** (1 / 3) + 0.0001)",
      "mutated_line": "p = int(c ** (1 / -3) + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / -3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "elif int(c ** 0.5 + 0.001) ** 2 == c:",
      "mutated_line": "elif int(c * 0.5 + 0.001) ** 2 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c * 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "elif int(c ** 0.5 + 0.001) ** 2 == c:",
      "mutated_line": "elif int(c + 0.5 + 0.001) ** 2 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c + 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif int(c ** 0.5 + 0.001) ** 2 == c:",
      "mutated_line": "elif int(c ** 0.5 + 1.001) ** 2 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 1.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif int(c ** 0.5 + 0.001) ** 2 == c:",
      "mutated_line": "elif int(c ** 0.5 + -0.999) ** 2 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + -0.999) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif int(c ** 0.5 + 0.001) ** 2 == c:",
      "mutated_line": "elif int(c ** 0.5 + 0) ** 2 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif int(c ** 0.5 + 0.001) ** 2 == c:",
      "mutated_line": "elif int(c ** 0.5 + 1) ** 2 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 1) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif int(c ** 0.5 + 0.001) ** 2 == c:",
      "mutated_line": "elif int(c ** 0.5 + -0.001) ** 2 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + -0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p = int(c ** 0.5 + 0.0001)",
      "mutated_line": "p = int(c ** 1.5 + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 1.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p = int(c ** 0.5 + 0.0001)",
      "mutated_line": "p = int(c ** -0.5 + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** -0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p = int(c ** 0.5 + 0.0001)",
      "mutated_line": "p = int(c ** 0 + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p = int(c ** 0.5 + 0.0001)",
      "mutated_line": "p = int(c ** 1 + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 1 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p = int(c ** 0.5 + 0.0001)",
      "mutated_line": "p = int(c ** -0.5 + 0.0001)",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** -0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (2 / 3) + 0.0001) ** 3 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (2 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (0 / 3) + 0.0001) ** 3 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (0 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (0 / 3) + 0.0001) ** 3 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (0 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (-1 / 3) + 0.0001) ** 3 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (-1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (1 / 4) + 0.0001) ** 3 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 4) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (1 / 2) + 0.0001) ** 3 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 2) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (1 / 0) + 0.0001) ** 3 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 0) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (1 / 1) + 0.0001) ** 3 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 1) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "elif int(c ** (1 / 3) + 0.0001) ** 3 == c:",
      "mutated_line": "elif int(c ** (1 / -3) + 0.0001) ** 3 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / -3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif int(c ** 0.5 + 0.001) ** 2 == c:",
      "mutated_line": "elif int(c ** 1.5 + 0.001) ** 2 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 1.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif int(c ** 0.5 + 0.001) ** 2 == c:",
      "mutated_line": "elif int(c ** -0.5 + 0.001) ** 2 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** -0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif int(c ** 0.5 + 0.001) ** 2 == c:",
      "mutated_line": "elif int(c ** 0 + 0.001) ** 2 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 0 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif int(c ** 0.5 + 0.001) ** 2 == c:",
      "mutated_line": "elif int(c ** 1 + 0.001) ** 2 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** 1 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "elif int(c ** 0.5 + 0.001) ** 2 == c:",
      "mutated_line": "elif int(c ** -0.5 + 0.001) ** 2 == c:",
      "code": "def calculate_divisors_count(n, a):\n    from math import gcd\n\n    def divisors(n, a):\n        d = {}\n        bad = []\n        for i in range(n):\n            c = a[i]\n            if int(c ** 0.25 + 0.0001) ** 4 == c:\n                p = int(c ** 0.25 + 0.0001)\n                if p not in d:\n                    d[p] = 4\n                else:\n                    d[p] += 4\n            elif int(c ** (1 / 3) + 0.0001) ** 3 == c:\n                p = int(c ** (1 / 3) + 0.0001)\n                if p not in d:\n                    d[p] = 3\n                else:\n                    d[p] += 3\n            elif int(c ** -0.5 + 0.001) ** 2 == c:\n                p = int(c ** 0.5 + 0.0001)\n                if p not in d:\n                    d[p] = 2\n                else:\n                    d[p] += 2\n            else:\n                bad.append(c)\n        skipped = {}\n        for i in range(len(bad)):\n            for j in range(len(a)):\n                g = gcd(bad[i], a[j])\n                if bad[i] == a[j] or g == 1:\n                    continue\n                else:\n                    if g not in d:\n                        d[g] = 1\n                    else:\n                        d[g] += 1\n                    if bad[i] // g not in d:\n                        d[bad[i] // g] = 1\n                    else:\n                        d[bad[i] // g] += 1\n                    break\n            else:\n                if bad[i] not in skipped:\n                    skipped[bad[i]] = 1\n                else:\n                    skipped[bad[i]] += 1\n        ans = 1\n        MOD = 998244353\n        for i in d:\n            ans = ans * (d[i] + 1) % MOD\n        for i in skipped:\n            ans = ans * (skipped[i] + 1) ** 2 % MOD\n        return ans\n    return divisors(n, a)"
    }
  ]
}