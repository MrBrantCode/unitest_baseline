{
  "task_id": "taco_14766",
  "entry_point": "find_good_subset_of_edges",
  "mutant_count": 128,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 5,
      "original_line": "u -= 1",
      "mutated_line": "u += 1",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u += 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "v -= 1",
      "mutated_line": "v += 1",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v += 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "t = -1",
      "mutated_line": "t = +1",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = +1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if d.count(1) % 2 == 1:",
      "mutated_line": "if d.count(1) % 2 != 1:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 != 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans = [False] * m",
      "mutated_line": "ans = [False] / m",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] / m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans = [False] * m",
      "mutated_line": "ans = [False] + m",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] + m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "ans = [False] * m",
      "mutated_line": "ans = [False] ** m",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] ** m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "vis = [False] * n",
      "mutated_line": "vis = [False] / n",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] / n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "vis = [False] * n",
      "mutated_line": "vis = [False] + n",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] + n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "vis = [False] * n",
      "mutated_line": "vis = [False] ** n",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] ** n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ed = [(-1, -1)] * n",
      "mutated_line": "ed = [(-1, -1)] / n",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] / n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ed = [(-1, -1)] * n",
      "mutated_line": "ed = [(-1, -1)] + n",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] + n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "ed = [(-1, -1)] * n",
      "mutated_line": "ed = [(-1, -1)] ** n",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] ** n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while len(stk) > 0:",
      "mutated_line": "while len(stk) >= 0:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) >= 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while len(stk) > 0:",
      "mutated_line": "while len(stk) <= 0:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) <= 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while len(stk) > 0:",
      "mutated_line": "while len(stk) != 0:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) != 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if k == 0:",
      "mutated_line": "if k != 0:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k != 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "u -= 1",
      "mutated_line": "u -= 2",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 2\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 0\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "u -= 1",
      "mutated_line": "u -= 0",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 0\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "u -= 1",
      "mutated_line": "u -= -1",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= -1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "v -= 1",
      "mutated_line": "v -= 2",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 2\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 0\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "v -= 1",
      "mutated_line": "v -= 0",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 0\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "v -= 1",
      "mutated_line": "v -= -1",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= -1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "t = -1",
      "mutated_line": "t = -2",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -2\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "t = -1",
      "mutated_line": "t = -0",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -0\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "t = -1",
      "mutated_line": "t = -0",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -0\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "t = -1",
      "mutated_line": "t = --1",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = --1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if d.count(1) % 2 == 1:",
      "mutated_line": "if d.count(1) * 2 == 1:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) * 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if d.count(1) % 2 == 1:",
      "mutated_line": "if d.count(1) + 2 == 1:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) + 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d.count(1) % 2 == 1:",
      "mutated_line": "if d.count(1) % 2 == 2:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 2:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d.count(1) % 2 == 1:",
      "mutated_line": "if d.count(1) % 2 == 0:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 0:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d.count(1) % 2 == 1:",
      "mutated_line": "if d.count(1) % 2 == 0:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 0:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d.count(1) % 2 == 1:",
      "mutated_line": "if d.count(1) % 2 == -1:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == -1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if -1 not in d:",
      "mutated_line": "if -1 in d:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "rets = [d[u] == 1 or u == t for u in range(n)]",
      "mutated_line": "rets = [d[u] == 1 and u == t for u in range(n)]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 and u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while len(stk) > 0:",
      "mutated_line": "while len(stk) > 1:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 1:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while len(stk) > 0:",
      "mutated_line": "while len(stk) > -1:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > -1:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while len(stk) > 0:",
      "mutated_line": "while len(stk) > 1:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 1:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "vis[u] = True",
      "mutated_line": "vis[u] = False",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = False\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "k = ans.count(True)",
      "mutated_line": "k = ans.count(False)",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(False)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if k == 0:",
      "mutated_line": "if k == 1:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 1:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if k == 0:",
      "mutated_line": "if k == -1:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == -1:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if k == 0:",
      "mutated_line": "if k == 1:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 1:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d.count(1) % 2 == 1:",
      "mutated_line": "if d.count(1) % 3 == 1:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 3 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d.count(1) % 2 == 1:",
      "mutated_line": "if d.count(1) % 1 == 1:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 1 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d.count(1) % 2 == 1:",
      "mutated_line": "if d.count(1) % 0 == 1:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 0 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d.count(1) % 2 == 1:",
      "mutated_line": "if d.count(1) % 1 == 1:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 1 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d.count(1) % 2 == 1:",
      "mutated_line": "if d.count(1) % -2 == 1:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % -2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "if -1 not in d:",
      "mutated_line": "if +1 not in d:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if +1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return +1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "t = d.index(-1)",
      "mutated_line": "t = d.index(+1)",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(+1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = [False] * m",
      "mutated_line": "ans = [True] * m",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [True] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "vis = [False] * n",
      "mutated_line": "vis = [True] * n",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [True] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "rets = [d[u] == 1 or u == t for u in range(n)]",
      "mutated_line": "rets = [d[u] != 1 or u == t for u in range(n)]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] != 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "rets = [d[u] == 1 or u == t for u in range(n)]",
      "mutated_line": "rets = [d[u] == 1 or u != t for u in range(n)]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u != t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stk = [[0, iter(gph[0])]]",
      "mutated_line": "stk = [[1, iter(gph[0])]]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[1, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stk = [[0, iter(gph[0])]]",
      "mutated_line": "stk = [[-1, iter(gph[0])]]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[-1, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stk = [[0, iter(gph[0])]]",
      "mutated_line": "stk = [[1, iter(gph[0])]]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[1, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "u = stk[-1][0]",
      "mutated_line": "u = stk[-1][1]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][1]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "u = stk[-1][0]",
      "mutated_line": "u = stk[-1][-1]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][-1]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "u = stk[-1][0]",
      "mutated_line": "u = stk[-1][1]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][1]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while False:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 0, []",
      "mutated_line": "return (1, [])",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (1, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 0, []",
      "mutated_line": "return (-1, [])",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (-1, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 0, []",
      "mutated_line": "return (1, [])",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (1, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "edge_indices = [i + 1 for i in range(m) if ans[i]]",
      "mutated_line": "edge_indices = [i - 1 for i in range(m) if ans[i]]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i - 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "edge_indices = [i + 1 for i in range(m) if ans[i]]",
      "mutated_line": "edge_indices = [i * 1 for i in range(m) if ans[i]]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i * 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d.count(1) % 2 == 1:",
      "mutated_line": "if d.count(2) % 2 == 1:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(2) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d.count(1) % 2 == 1:",
      "mutated_line": "if d.count(0) % 2 == 1:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(0) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d.count(1) % 2 == 1:",
      "mutated_line": "if d.count(0) % 2 == 1:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(0) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if d.count(1) % 2 == 1:",
      "mutated_line": "if d.count(-1) % 2 == 1:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(-1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if -1 not in d:",
      "mutated_line": "if -2 not in d:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -2 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if -1 not in d:",
      "mutated_line": "if -0 not in d:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -0 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if -1 not in d:",
      "mutated_line": "if -0 not in d:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -0 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if -1 not in d:",
      "mutated_line": "if --1 not in d:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if --1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -2\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -0\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -0\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return --1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "t = d.index(-1)",
      "mutated_line": "t = d.index(-2)",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-2)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "t = d.index(-1)",
      "mutated_line": "t = d.index(-0)",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-0)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "t = d.index(-1)",
      "mutated_line": "t = d.index(-0)",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-0)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "t = d.index(-1)",
      "mutated_line": "t = d.index(--1)",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(--1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "ed = [(-1, -1)] * n",
      "mutated_line": "ed = [(+1, -1)] * n",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(+1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "ed = [(-1, -1)] * n",
      "mutated_line": "ed = [(-1, +1)] * n",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, +1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "rets = [d[u] == 1 or u == t for u in range(n)]",
      "mutated_line": "rets = [d[u] == 2 or u == t for u in range(n)]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 2 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "rets = [d[u] == 1 or u == t for u in range(n)]",
      "mutated_line": "rets = [d[u] == 0 or u == t for u in range(n)]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 0 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "rets = [d[u] == 1 or u == t for u in range(n)]",
      "mutated_line": "rets = [d[u] == 0 or u == t for u in range(n)]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 0 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "rets = [d[u] == 1 or u == t for u in range(n)]",
      "mutated_line": "rets = [d[u] == -1 or u == t for u in range(n)]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == -1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "u = stk[-1][0]",
      "mutated_line": "u = stk[+1][0]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[+1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "if p >= 0 and rets[u]:",
      "mutated_line": "if p >= 0 or rets[u]:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 or rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "edge_indices = [i + 1 for i in range(m) if ans[i]]",
      "mutated_line": "edge_indices = [i + 2 for i in range(m) if ans[i]]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 2 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "edge_indices = [i + 1 for i in range(m) if ans[i]]",
      "mutated_line": "edge_indices = [i + 0 for i in range(m) if ans[i]]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 0 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "edge_indices = [i + 1 for i in range(m) if ans[i]]",
      "mutated_line": "edge_indices = [i + 0 for i in range(m) if ans[i]]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 0 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "edge_indices = [i + 1 for i in range(m) if ans[i]]",
      "mutated_line": "edge_indices = [i + -1 for i in range(m) if ans[i]]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + -1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ed = [(-1, -1)] * n",
      "mutated_line": "ed = [(-2, -1)] * n",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-2, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ed = [(-1, -1)] * n",
      "mutated_line": "ed = [(-0, -1)] * n",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-0, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ed = [(-1, -1)] * n",
      "mutated_line": "ed = [(-0, -1)] * n",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-0, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ed = [(-1, -1)] * n",
      "mutated_line": "ed = [(--1, -1)] * n",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(--1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ed = [(-1, -1)] * n",
      "mutated_line": "ed = [(-1, -2)] * n",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -2)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ed = [(-1, -1)] * n",
      "mutated_line": "ed = [(-1, -0)] * n",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -0)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ed = [(-1, -1)] * n",
      "mutated_line": "ed = [(-1, -0)] * n",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -0)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ed = [(-1, -1)] * n",
      "mutated_line": "ed = [(-1, --1)] * n",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, --1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stk = [[0, iter(gph[0])]]",
      "mutated_line": "stk = [[0, iter(gph[1])]]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[1])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stk = [[0, iter(gph[0])]]",
      "mutated_line": "stk = [[0, iter(gph[-1])]]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[-1])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "stk = [[0, iter(gph[0])]]",
      "mutated_line": "stk = [[0, iter(gph[1])]]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[1])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "u = stk[-1][0]",
      "mutated_line": "u = stk[-2][0]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-2][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "u = stk[-1][0]",
      "mutated_line": "u = stk[-0][0]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-0][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "u = stk[-1][0]",
      "mutated_line": "u = stk[-0][0]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-0][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "u = stk[-1][0]",
      "mutated_line": "u = stk[--1][0]",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[--1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if p >= 0 and rets[u]:",
      "mutated_line": "if p > 0 and rets[u]:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p > 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if p >= 0 and rets[u]:",
      "mutated_line": "if p < 0 and rets[u]:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p < 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if p >= 0 and rets[u]:",
      "mutated_line": "if p == 0 and rets[u]:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p == 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans[e] = True",
      "mutated_line": "ans[e] = False",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = False\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(v, i) = next(stk[-1][1])",
      "mutated_line": "(v, i) = next(stk[-1][2])",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][2])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(v, i) = next(stk[-1][1])",
      "mutated_line": "(v, i) = next(stk[-1][0])",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][0])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(v, i) = next(stk[-1][1])",
      "mutated_line": "(v, i) = next(stk[-1][0])",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][0])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(v, i) = next(stk[-1][1])",
      "mutated_line": "(v, i) = next(stk[-1][-1])",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][-1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if p >= 0 and rets[u]:",
      "mutated_line": "if p >= 1 and rets[u]:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 1 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if p >= 0 and rets[u]:",
      "mutated_line": "if p >= -1 and rets[u]:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= -1 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if p >= 0 and rets[u]:",
      "mutated_line": "if p >= 1 and rets[u]:",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 1 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "(v, i) = next(stk[-1][1])",
      "mutated_line": "(v, i) = next(stk[+1][1])",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[+1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(v, i) = next(stk[-1][1])",
      "mutated_line": "(v, i) = next(stk[-2][1])",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-2][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(v, i) = next(stk[-1][1])",
      "mutated_line": "(v, i) = next(stk[-0][1])",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-0][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(v, i) = next(stk[-1][1])",
      "mutated_line": "(v, i) = next(stk[-0][1])",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[-0][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "(v, i) = next(stk[-1][1])",
      "mutated_line": "(v, i) = next(stk[--1][1])",
      "code": "def find_good_subset_of_edges(n, m, d, edges):\n    gph = [[] for _ in range(n)]\n    for i in range(m):\n        (u, v) = edges[i]\n        u -= 1\n        v -= 1\n        gph[u].append((v, i))\n        gph[v].append((u, i))\n    t = -1\n    if d.count(1) % 2 == 1:\n        if -1 not in d:\n            return -1\n        t = d.index(-1)\n    ans = [False] * m\n    vis = [False] * n\n    ed = [(-1, -1)] * n\n    rets = [d[u] == 1 or u == t for u in range(n)]\n    stk = [[0, iter(gph[0])]]\n    while len(stk) > 0:\n        u = stk[-1][0]\n        vis[u] = True\n        try:\n            while True:\n                (v, i) = next(stk[--1][1])\n                if not vis[v]:\n                    ed[v] = (u, i)\n                    stk.append([v, iter(gph[v])])\n                    break\n        except StopIteration:\n            (p, e) = ed[u]\n            if p >= 0 and rets[u]:\n                rets[p] = not rets[p]\n                ans[e] = True\n            stk.pop()\n    k = ans.count(True)\n    if k == 0:\n        return (0, [])\n    else:\n        edge_indices = [i + 1 for i in range(m) if ans[i]]\n        return (k, edge_indices)"
    }
  ]
}