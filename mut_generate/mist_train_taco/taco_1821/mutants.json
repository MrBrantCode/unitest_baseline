{
  "task_id": "taco_1821",
  "entry_point": "min_operations_to_equalize",
  "mutant_count": 69,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "ans += numbers[0] - numbers[1]",
      "mutated_line": "ans -= numbers[0] - numbers[1]",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans -= numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "numbers[1] += ans",
      "mutated_line": "numbers[1] -= ans",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] -= ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "numbers[2] += ans",
      "mutated_line": "numbers[2] -= ans",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] -= ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "ans += (numbers[0] - numbers[2]) // 2",
      "mutated_line": "ans -= (numbers[0] - numbers[2]) // 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans -= (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans -= (numbers[0] - numbers[2]) % 2 * 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans -= (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 1\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = -1\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 1\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "ans += numbers[0] - numbers[1]",
      "mutated_line": "ans += numbers[0] + numbers[1]",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] + numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "ans += numbers[0] - numbers[1]",
      "mutated_line": "ans += numbers[0] * numbers[1]",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] * numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "ans += (numbers[0] - numbers[2]) // 2",
      "mutated_line": "ans += (numbers[0] - numbers[2]) / 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) / 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "ans += (numbers[0] - numbers[2]) // 2",
      "mutated_line": "ans += (numbers[0] - numbers[2]) * 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) * 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans += (numbers[0] - numbers[2]) % 2 / 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 / 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans += (numbers[0] - numbers[2]) % 2 + 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 + 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans += ((numbers[0] - numbers[2]) % 2) ** 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += ((numbers[0] - numbers[2]) % 2) ** 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "numbers[1] += ans",
      "mutated_line": "",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[2] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "numbers[1] += ans",
      "mutated_line": "numbers[0] += ans",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[0] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "numbers[1] += ans",
      "mutated_line": "numbers[0] += ans",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[0] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "numbers[1] += ans",
      "mutated_line": "numbers[-1] += ans",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[-1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "numbers[2] += ans",
      "mutated_line": "numbers[3] += ans",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[3] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "numbers[2] += ans",
      "mutated_line": "numbers[1] += ans",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[1] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "numbers[2] += ans",
      "mutated_line": "numbers[0] += ans",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[0] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "numbers[2] += ans",
      "mutated_line": "numbers[1] += ans",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[1] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "numbers[2] += ans",
      "mutated_line": "numbers[-2] += ans",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[-2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "ans += (numbers[0] - numbers[2]) // 2",
      "mutated_line": "ans += (numbers[0] + numbers[2]) // 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] + numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "ans += (numbers[0] - numbers[2]) // 2",
      "mutated_line": "ans += numbers[0] * numbers[2] // 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += numbers[0] * numbers[2] // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans += (numbers[0] - numbers[2]) // 2",
      "mutated_line": "ans += (numbers[0] - numbers[2]) // 3",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 3\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans += (numbers[0] - numbers[2]) // 2",
      "mutated_line": "ans += (numbers[0] - numbers[2]) // 1",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 1\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans += (numbers[0] - numbers[2]) // 2",
      "mutated_line": "ans += (numbers[0] - numbers[2]) // 0",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 0\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans += (numbers[0] - numbers[2]) // 2",
      "mutated_line": "ans += (numbers[0] - numbers[2]) // 1",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 1\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans += (numbers[0] - numbers[2]) // 2",
      "mutated_line": "ans += (numbers[0] - numbers[2]) // -2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // -2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans += (numbers[0] - numbers[2]) * 2 * 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) * 2 * 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans += (numbers[0] - numbers[2] + 2) * 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2] + 2) * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans += (numbers[0] - numbers[2]) % 2 * 3",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 3\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans += (numbers[0] - numbers[2]) % 2 * 1",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans += (numbers[0] - numbers[2]) % 2 * 0",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans += (numbers[0] - numbers[2]) % 2 * 1",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans += (numbers[0] - numbers[2]) % 2 * -2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * -2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "numbers.sort(reverse=True)",
      "mutated_line": "numbers.sort(reverse=False)",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=False)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ans += numbers[0] - numbers[1]",
      "mutated_line": "ans += numbers[1] - numbers[1]",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[1] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ans += numbers[0] - numbers[1]",
      "mutated_line": "ans += numbers[-1] - numbers[1]",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[-1] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ans += numbers[0] - numbers[1]",
      "mutated_line": "ans += numbers[1] - numbers[1]",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[1] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ans += numbers[0] - numbers[1]",
      "mutated_line": "ans += numbers[0] - numbers[2]",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[2]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ans += numbers[0] - numbers[1]",
      "mutated_line": "ans += numbers[0] - numbers[0]",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[0]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ans += numbers[0] - numbers[1]",
      "mutated_line": "ans += numbers[0] - numbers[0]",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[0]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "ans += numbers[0] - numbers[1]",
      "mutated_line": "ans += numbers[0] - numbers[-1]",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[-1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans += (numbers[0] + numbers[2]) % 2 * 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] + numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans += numbers[0] * numbers[2] % 2 * 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += numbers[0] * numbers[2] % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans += (numbers[0] - numbers[2]) % 3 * 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 3 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans += (numbers[0] - numbers[2]) % 1 * 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 1 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans += (numbers[0] - numbers[2]) % 0 * 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 0 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans += (numbers[0] - numbers[2]) % 1 * 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 1 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans += (numbers[0] - numbers[2]) % -2 * 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % -2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans += (numbers[0] - numbers[2]) // 2",
      "mutated_line": "ans += (numbers[1] - numbers[2]) // 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[1] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans += (numbers[0] - numbers[2]) // 2",
      "mutated_line": "ans += (numbers[-1] - numbers[2]) // 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[-1] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans += (numbers[0] - numbers[2]) // 2",
      "mutated_line": "ans += (numbers[1] - numbers[2]) // 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[1] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans += (numbers[0] - numbers[2]) // 2",
      "mutated_line": "ans += (numbers[0] - numbers[3]) // 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[3]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans += (numbers[0] - numbers[2]) // 2",
      "mutated_line": "ans += (numbers[0] - numbers[1]) // 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[1]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans += (numbers[0] - numbers[2]) // 2",
      "mutated_line": "ans += (numbers[0] - numbers[0]) // 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[0]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans += (numbers[0] - numbers[2]) // 2",
      "mutated_line": "ans += (numbers[0] - numbers[1]) // 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[1]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans += (numbers[0] - numbers[2]) // 2",
      "mutated_line": "ans += (numbers[0] - numbers[-2]) // 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[-2]) // 2\n    ans += (numbers[0] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans += (numbers[1] - numbers[2]) % 2 * 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[1] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans += (numbers[-1] - numbers[2]) % 2 * 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[-1] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans += (numbers[1] - numbers[2]) % 2 * 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[1] - numbers[2]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans += (numbers[0] - numbers[3]) % 2 * 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[3]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans += (numbers[0] - numbers[1]) % 2 * 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[1]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans += (numbers[0] - numbers[0]) % 2 * 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[0]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans += (numbers[0] - numbers[1]) % 2 * 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[1]) % 2 * 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += (numbers[0] - numbers[2]) % 2 * 2",
      "mutated_line": "ans += (numbers[0] - numbers[-2]) % 2 * 2",
      "code": "def min_operations_to_equalize(A, B, C):\n    numbers = [A, B, C]\n    numbers.sort(reverse=True)\n    ans = 0\n    ans += numbers[0] - numbers[1]\n    numbers[1] += ans\n    numbers[2] += ans\n    ans += (numbers[0] - numbers[2]) // 2\n    ans += (numbers[0] - numbers[-2]) % 2 * 2\n    return ans"
    }
  ]
}