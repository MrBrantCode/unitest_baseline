{
  "task_id": "taco_11033",
  "entry_point": "max_total_reward",
  "mutant_count": 34,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p = 0",
      "mutated_line": "p = 1",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 1\n    ans = 0\n    for i in range(M + 1):\n        while p < N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p = 0",
      "mutated_line": "p = -1",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = -1\n    ans = 0\n    for i in range(M + 1):\n        while p < N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "p = 0",
      "mutated_line": "p = 1",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 1\n    ans = 0\n    for i in range(M + 1):\n        while p < N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 1\n    for i in range(M + 1):\n        while p < N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = -1\n    for i in range(M + 1):\n        while p < N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 1\n    for i in range(M + 1):\n        while p < N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(M + 1):",
      "mutated_line": "for i in range(M - 1):",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M - 1):\n        while p < N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(M + 1):",
      "mutated_line": "for i in range(M * 1):",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M * 1):\n        while p < N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "while p < N and jobs[p][0] <= i:",
      "mutated_line": "while p < N or jobs[p][0] <= i:",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + 1):\n        while p < N or jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "p += 1",
      "mutated_line": "p -= 1",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + 1):\n        while p < N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p -= 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "ans += -heapq.heappop(can)",
      "mutated_line": "ans -= -heapq.heappop(can)",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + 1):\n        while p < N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 1\n        if can:\n            ans -= -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(M + 1):",
      "mutated_line": "for i in range(M + 2):",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + 2):\n        while p < N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(M + 1):",
      "mutated_line": "for i in range(M + 0):",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + 0):\n        while p < N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(M + 1):",
      "mutated_line": "for i in range(M + 0):",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + 0):\n        while p < N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(M + 1):",
      "mutated_line": "for i in range(M + -1):",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + -1):\n        while p < N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while p < N and jobs[p][0] <= i:",
      "mutated_line": "while p <= N and jobs[p][0] <= i:",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + 1):\n        while p <= N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while p < N and jobs[p][0] <= i:",
      "mutated_line": "while p >= N and jobs[p][0] <= i:",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + 1):\n        while p >= N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while p < N and jobs[p][0] <= i:",
      "mutated_line": "while p != N and jobs[p][0] <= i:",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + 1):\n        while p != N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while p < N and jobs[p][0] <= i:",
      "mutated_line": "while p < N and jobs[p][0] < i:",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + 1):\n        while p < N and jobs[p][0] < i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while p < N and jobs[p][0] <= i:",
      "mutated_line": "while p < N and jobs[p][0] > i:",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + 1):\n        while p < N and jobs[p][0] > i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while p < N and jobs[p][0] <= i:",
      "mutated_line": "while p < N and jobs[p][0] == i:",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + 1):\n        while p < N and jobs[p][0] == i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p += 1",
      "mutated_line": "p += 2",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + 1):\n        while p < N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 2\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p += 1",
      "mutated_line": "p += 0",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + 1):\n        while p < N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 0\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p += 1",
      "mutated_line": "p += 0",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + 1):\n        while p < N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 0\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "p += 1",
      "mutated_line": "p += -1",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + 1):\n        while p < N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p += -1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "ans += -heapq.heappop(can)",
      "mutated_line": "ans += +heapq.heappop(can)",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + 1):\n        while p < N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 1\n        if can:\n            ans += +heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "heapq.heappush(can, -jobs[p][1])",
      "mutated_line": "heapq.heappush(can, +jobs[p][1])",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + 1):\n        while p < N and jobs[p][0] <= i:\n            heapq.heappush(can, +jobs[p][1])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while p < N and jobs[p][0] <= i:",
      "mutated_line": "while p < N and jobs[p][1] <= i:",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + 1):\n        while p < N and jobs[p][1] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while p < N and jobs[p][0] <= i:",
      "mutated_line": "while p < N and jobs[p][-1] <= i:",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + 1):\n        while p < N and jobs[p][-1] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "while p < N and jobs[p][0] <= i:",
      "mutated_line": "while p < N and jobs[p][1] <= i:",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + 1):\n        while p < N and jobs[p][1] <= i:\n            heapq.heappush(can, -jobs[p][1])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heapq.heappush(can, -jobs[p][1])",
      "mutated_line": "heapq.heappush(can, -jobs[p][2])",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + 1):\n        while p < N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][2])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heapq.heappush(can, -jobs[p][1])",
      "mutated_line": "heapq.heappush(can, -jobs[p][0])",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + 1):\n        while p < N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][0])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heapq.heappush(can, -jobs[p][1])",
      "mutated_line": "heapq.heappush(can, -jobs[p][0])",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + 1):\n        while p < N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][0])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heapq.heappush(can, -jobs[p][1])",
      "mutated_line": "heapq.heappush(can, -jobs[p][-1])",
      "code": "import heapq\n\ndef max_total_reward(N, M, jobs):\n    jobs.sort()\n    can = []\n    p = 0\n    ans = 0\n    for i in range(M + 1):\n        while p < N and jobs[p][0] <= i:\n            heapq.heappush(can, -jobs[p][-1])\n            p += 1\n        if can:\n            ans += -heapq.heappop(can)\n    return ans"
    }
  ]
}