{
  "task_id": "taco_12234",
  "entry_point": "minimum_edge_reversal",
  "mutant_count": 66,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dist = [float('inf')] * (n + 1)",
      "mutated_line": "dist = [float('inf')] / (n + 1)",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] / (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dist = [float('inf')] * (n + 1)",
      "mutated_line": "dist = [float('inf')] + (n + 1)",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] + (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dist = [float('inf')] * (n + 1)",
      "mutated_line": "dist = [float('inf')] ** (n + 1)",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] ** (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist[src] = 0",
      "mutated_line": "dist[src] = 1",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 1\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist[src] = 0",
      "mutated_line": "dist[src] = -1",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = -1\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist[src] = 0",
      "mutated_line": "dist[src] = 1",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 1\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if (edge[1], edge[0]) not in edges:",
      "mutated_line": "if (edge[1], edge[0]) in edges:",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dist = [float('inf')] * (n + 1)",
      "mutated_line": "dist = [float('inf')] * (n - 1)",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n - 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dist = [float('inf')] * (n + 1)",
      "mutated_line": "dist = [float('inf')] * (n * 1)",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n * 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "return dist[dst] if dist[dst] != float('inf') else -1",
      "mutated_line": "return dist[dst] if dist[dst] == float('inf') else -1",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] == float('inf') else -1"
    },
    {
      "operator": "UOI",
      "lineno": 35,
      "original_line": "return dist[dst] if dist[dst] != float('inf') else -1",
      "mutated_line": "return dist[dst] if dist[dst] != float('inf') else +1",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else +1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dist = [float('inf')] * (n + 1)",
      "mutated_line": "dist = [float('inf')] * (n + 2)",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 2)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dist = [float('inf')] * (n + 1)",
      "mutated_line": "dist = [float('inf')] * (n + 0)",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 0)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dist = [float('inf')] * (n + 1)",
      "mutated_line": "dist = [float('inf')] * (n + 0)",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 0)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dist = [float('inf')] * (n + 1)",
      "mutated_line": "dist = [float('inf')] * (n + -1)",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + -1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "pq = [(0, src)]",
      "mutated_line": "pq = [(1, src)]",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(1, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "pq = [(0, src)]",
      "mutated_line": "pq = [(-1, src)]",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(-1, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "pq = [(0, src)]",
      "mutated_line": "pq = [(1, src)]",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(1, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if node_dist + neib_dist < dist[neib]:",
      "mutated_line": "if node_dist + neib_dist <= dist[neib]:",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist <= dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if node_dist + neib_dist < dist[neib]:",
      "mutated_line": "if node_dist + neib_dist >= dist[neib]:",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist >= dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if node_dist + neib_dist < dist[neib]:",
      "mutated_line": "if node_dist + neib_dist != dist[neib]:",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist != dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return dist[dst] if dist[dst] != float('inf') else -1",
      "mutated_line": "return dist[dst] if dist[dst] != float('inf') else -2",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -2"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return dist[dst] if dist[dst] != float('inf') else -1",
      "mutated_line": "return dist[dst] if dist[dst] != float('inf') else -0",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -0"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return dist[dst] if dist[dst] != float('inf') else -1",
      "mutated_line": "return dist[dst] if dist[dst] != float('inf') else -0",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -0"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return dist[dst] if dist[dst] != float('inf') else -1",
      "mutated_line": "return dist[dst] if dist[dst] != float('inf') else --1",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else --1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "adj[edge[0]].append((edge[1], 0))",
      "mutated_line": "adj[edge[0]].append((edge[1], 1))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 1))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "adj[edge[0]].append((edge[1], 0))",
      "mutated_line": "adj[edge[0]].append((edge[1], -1))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], -1))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "adj[edge[0]].append((edge[1], 0))",
      "mutated_line": "adj[edge[0]].append((edge[1], 1))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 1))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "adj[edge[0]].append((edge[1], 1))",
      "mutated_line": "adj[edge[0]].append((edge[1], 2))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 2))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "adj[edge[0]].append((edge[1], 1))",
      "mutated_line": "adj[edge[0]].append((edge[1], 0))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 0))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "adj[edge[0]].append((edge[1], 1))",
      "mutated_line": "adj[edge[0]].append((edge[1], 0))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 0))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "adj[edge[0]].append((edge[1], 1))",
      "mutated_line": "adj[edge[0]].append((edge[1], -1))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], -1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dist = [float('inf')] * (n + 1)",
      "mutated_line": "dist = [float('')] * (n + 1)",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if node_dist + neib_dist < dist[neib]:",
      "mutated_line": "if node_dist - neib_dist < dist[neib]:",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist - neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if node_dist + neib_dist < dist[neib]:",
      "mutated_line": "if node_dist * neib_dist < dist[neib]:",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist * neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dist[neib] = node_dist + neib_dist",
      "mutated_line": "dist[neib] = node_dist - neib_dist",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist - neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dist[neib] = node_dist + neib_dist",
      "mutated_line": "dist[neib] = node_dist * neib_dist",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist * neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return dist[dst] if dist[dst] != float('inf') else -1",
      "mutated_line": "return dist[dst] if dist[dst] != float('') else -1",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (edge[1], edge[0]) not in edges:",
      "mutated_line": "if (edge[2], edge[0]) not in edges:",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[2], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (edge[1], edge[0]) not in edges:",
      "mutated_line": "if (edge[0], edge[0]) not in edges:",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[0], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (edge[1], edge[0]) not in edges:",
      "mutated_line": "if (edge[0], edge[0]) not in edges:",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[0], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (edge[1], edge[0]) not in edges:",
      "mutated_line": "if (edge[-1], edge[0]) not in edges:",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[-1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (edge[1], edge[0]) not in edges:",
      "mutated_line": "if (edge[1], edge[1]) not in edges:",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[1]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (edge[1], edge[0]) not in edges:",
      "mutated_line": "if (edge[1], edge[-1]) not in edges:",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[-1]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if (edge[1], edge[0]) not in edges:",
      "mutated_line": "if (edge[1], edge[1]) not in edges:",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[1]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "adj[edge[0]].append((edge[1], 0))",
      "mutated_line": "adj[edge[0]].append((edge[2], 0))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[2], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "adj[edge[0]].append((edge[1], 0))",
      "mutated_line": "adj[edge[0]].append((edge[0], 0))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[0], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "adj[edge[0]].append((edge[1], 0))",
      "mutated_line": "adj[edge[0]].append((edge[0], 0))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[0], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "adj[edge[0]].append((edge[1], 0))",
      "mutated_line": "adj[edge[0]].append((edge[-1], 0))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[-1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "adj[edge[0]].append((edge[1], 1))",
      "mutated_line": "adj[edge[0]].append((edge[2], 1))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[2], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "adj[edge[0]].append((edge[1], 1))",
      "mutated_line": "adj[edge[0]].append((edge[0], 1))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[0], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "adj[edge[0]].append((edge[1], 1))",
      "mutated_line": "adj[edge[0]].append((edge[0], 1))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[0], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "adj[edge[0]].append((edge[1], 1))",
      "mutated_line": "adj[edge[0]].append((edge[-1], 1))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[-1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "reversed_edges.add((edge[1], edge[0]))",
      "mutated_line": "reversed_edges.add((edge[2], edge[0]))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[2], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "reversed_edges.add((edge[1], edge[0]))",
      "mutated_line": "reversed_edges.add((edge[0], edge[0]))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[0], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "reversed_edges.add((edge[1], edge[0]))",
      "mutated_line": "reversed_edges.add((edge[0], edge[0]))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[0], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "reversed_edges.add((edge[1], edge[0]))",
      "mutated_line": "reversed_edges.add((edge[-1], edge[0]))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[-1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "reversed_edges.add((edge[1], edge[0]))",
      "mutated_line": "reversed_edges.add((edge[1], edge[1]))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[1]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "reversed_edges.add((edge[1], edge[0]))",
      "mutated_line": "reversed_edges.add((edge[1], edge[-1]))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[-1]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "reversed_edges.add((edge[1], edge[0]))",
      "mutated_line": "reversed_edges.add((edge[1], edge[1]))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[1]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "adj[edge[0]].append((edge[1], 0))",
      "mutated_line": "adj[edge[1]].append((edge[1], 0))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[1]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "adj[edge[0]].append((edge[1], 0))",
      "mutated_line": "adj[edge[-1]].append((edge[1], 0))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[-1]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "adj[edge[0]].append((edge[1], 0))",
      "mutated_line": "adj[edge[1]].append((edge[1], 0))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[1]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[0]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "adj[edge[0]].append((edge[1], 1))",
      "mutated_line": "adj[edge[1]].append((edge[1], 1))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[1]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "adj[edge[0]].append((edge[1], 1))",
      "mutated_line": "adj[edge[-1]].append((edge[1], 1))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[-1]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "adj[edge[0]].append((edge[1], 1))",
      "mutated_line": "adj[edge[1]].append((edge[1], 1))",
      "code": "from typing import List, Tuple\nimport heapq as h\nfrom collections import defaultdict\n\ndef minimum_edge_reversal(edges: List[Tuple[int, int]], n: int, src: int, dst: int) -> int:\n    adj = defaultdict(list)\n    edges = set(edges)\n    reversed_edges = set()\n    for edge in edges:\n        if (edge[1], edge[0]) not in edges:\n            reversed_edges.add((edge[1], edge[0]))\n    for edge in edges:\n        adj[edge[0]].append((edge[1], 0))\n    for edge in reversed_edges:\n        adj[edge[1]].append((edge[1], 1))\n    dist = [float('inf')] * (n + 1)\n    dist[src] = 0\n    pq = [(0, src)]\n    while pq:\n        (node_dist, node) = h.heappop(pq)\n        for (neib, neib_dist) in adj[node]:\n            if node_dist + neib_dist < dist[neib]:\n                dist[neib] = node_dist + neib_dist\n                h.heappush(pq, (dist[neib], neib))\n    return dist[dst] if dist[dst] != float('inf') else -1"
    }
  ]
}