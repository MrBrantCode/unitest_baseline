{
  "task_id": "taco_6144",
  "entry_point": "count_different_arrays",
  "mutant_count": 189,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "numZ = 0",
      "mutated_line": "numZ = 1",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 1\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "numZ = 0",
      "mutated_line": "numZ = -1",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = -1\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "numZ = 0",
      "mutated_line": "numZ = 1",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 1\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "answer = 0",
      "mutated_line": "answer = 1",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 1\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "answer = 0",
      "mutated_line": "answer = -1",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = -1\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "answer = 0",
      "mutated_line": "answer = 1",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 1\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "p = 1000000007",
      "mutated_line": "p = 1000000008",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000008\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "p = 1000000007",
      "mutated_line": "p = 1000000006",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000006\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "p = 1000000007",
      "mutated_line": "p = 0",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 0\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "p = 1000000007",
      "mutated_line": "p = 1",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "p = 1000000007",
      "mutated_line": "p = -1000000007",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = -1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "N = N - numZ",
      "mutated_line": "N = N + numZ",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N + numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "N = N - numZ",
      "mutated_line": "N = N * numZ",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N * numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if numZ > 0:",
      "mutated_line": "if numZ >= 0:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ >= 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if numZ > 0:",
      "mutated_line": "if numZ <= 0:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ <= 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if numZ > 0:",
      "mutated_line": "if numZ != 0:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ != 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "fact = [1]",
      "mutated_line": "fact = [2]",
      "code": "def count_different_arrays(N, K, A):\n    fact = [2]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "fact = [1]",
      "mutated_line": "fact = [0]",
      "code": "def count_different_arrays(N, K, A):\n    fact = [0]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "fact = [1]",
      "mutated_line": "fact = [0]",
      "code": "def count_different_arrays(N, K, A):\n    fact = [0]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "fact = [1]",
      "mutated_line": "fact = [-1]",
      "code": "def count_different_arrays(N, K, A):\n    fact = [-1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(1, 100001):",
      "mutated_line": "for i in range(2, 100001):",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(2, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(1, 100001):",
      "mutated_line": "for i in range(0, 100001):",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(0, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(1, 100001):",
      "mutated_line": "for i in range(0, 100001):",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(0, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(1, 100001):",
      "mutated_line": "for i in range(-1, 100001):",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(-1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(1, 100001):",
      "mutated_line": "for i in range(1, 100002):",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100002):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(1, 100001):",
      "mutated_line": "for i in range(1, 100000):",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100000):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(1, 100001):",
      "mutated_line": "for i in range(1, 0):",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 0):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(1, 100001):",
      "mutated_line": "for i in range(1, 1):",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 1):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "for i in range(1, 100001):",
      "mutated_line": "for i in range(1, -100001):",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, -100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "x = 1",
      "mutated_line": "x = 2",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 2\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "x = 1",
      "mutated_line": "x = 0",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 0\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "x = 1",
      "mutated_line": "x = 0",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 0\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "x = 1",
      "mutated_line": "x = -1",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = -1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while b > 0:",
      "mutated_line": "while b >= 0:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b >= 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while b > 0:",
      "mutated_line": "while b <= 0:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b <= 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while b > 0:",
      "mutated_line": "while b != 0:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b != 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p",
      "mutated_line": "return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) * p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) * p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p",
      "mutated_line": "return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) + p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) + p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if A[j] == 0:",
      "mutated_line": "if A[j] != 0:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] != 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "numZ += 1",
      "mutated_line": "numZ -= 1",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ -= 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if numZ > 0:",
      "mutated_line": "if numZ > 1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 1:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if numZ > 0:",
      "mutated_line": "if numZ > -1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > -1:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if numZ > 0:",
      "mutated_line": "if numZ > 1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 1:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if N > K:",
      "mutated_line": "if N >= K:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N >= K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if N > K:",
      "mutated_line": "if N <= K:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N <= K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if N > K:",
      "mutated_line": "if N != K:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N != K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "elif N > K:",
      "mutated_line": "elif N >= K:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N >= K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "elif N > K:",
      "mutated_line": "elif N <= K:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N <= K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "elif N > K:",
      "mutated_line": "elif N != K:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N != K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "fact.append(i * fact[i - 1] % 1000000007)",
      "mutated_line": "fact.append(i * fact[i - 1] * 1000000007)",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] * 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "fact.append(i * fact[i - 1] % 1000000007)",
      "mutated_line": "fact.append(i * fact[i - 1] + 1000000007)",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] + 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while b > 0:",
      "mutated_line": "while b > 1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 1:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while b > 0:",
      "mutated_line": "while b > -1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > -1:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while b > 0:",
      "mutated_line": "while b > 1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 1:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 2 != 1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 != 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y = y * y",
      "mutated_line": "y = y / y",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y / y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y = y * y",
      "mutated_line": "y = y + y",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y + y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y = y * y",
      "mutated_line": "y = y ** y",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y ** y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if y > p:",
      "mutated_line": "if y >= p:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y >= p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if y > p:",
      "mutated_line": "if y <= p:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y <= p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if y > p:",
      "mutated_line": "if y != p:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y != p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "b = b // 2",
      "mutated_line": "b = b / 2",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b / 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "b = b // 2",
      "mutated_line": "b = b * 2",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b * 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return power(N, p - 2, p)",
      "mutated_line": "return power(N, p + 2, p)",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p + 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "return power(N, p - 2, p)",
      "mutated_line": "return power(N, p * 2, p)",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p * 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p",
      "mutated_line": "return fact[N] / (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] / (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p",
      "mutated_line": "return (fact[N] + inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return (fact[N] + inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p",
      "mutated_line": "return fact[N] ** (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] ** (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if A[j] == 0:",
      "mutated_line": "if A[j] == 1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 1:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if A[j] == 0:",
      "mutated_line": "if A[j] == -1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == -1:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if A[j] == 0:",
      "mutated_line": "if A[j] == 1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 1:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "numZ += 1",
      "mutated_line": "numZ += 2",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 2\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "numZ += 1",
      "mutated_line": "numZ += 0",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 0\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "numZ += 1",
      "mutated_line": "numZ += 0",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 0\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "numZ += 1",
      "mutated_line": "numZ += -1",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += -1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while temp >= 0:",
      "mutated_line": "while temp > 0:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp > 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while temp >= 0:",
      "mutated_line": "while temp < 0:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp < 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while temp >= 0:",
      "mutated_line": "while temp == 0:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp == 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "temp -= 1",
      "mutated_line": "temp += 1",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp += 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "while temp >= 0:",
      "mutated_line": "while temp > 0:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp > 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "while temp >= 0:",
      "mutated_line": "while temp < 0:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp < 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "while temp >= 0:",
      "mutated_line": "while temp == 0:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp == 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ASR",
      "lineno": 46,
      "original_line": "temp -= 1",
      "mutated_line": "temp += 1",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp += 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "while temp >= 0:",
      "mutated_line": "while temp > 0:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp > 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "while temp >= 0:",
      "mutated_line": "while temp < 0:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp < 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "while temp >= 0:",
      "mutated_line": "while temp == 0:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp == 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "temp -= 2",
      "mutated_line": "temp += 2",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp += 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "while temp >= 0:",
      "mutated_line": "while temp > 0:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp > 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "while temp >= 0:",
      "mutated_line": "while temp < 0:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp < 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "while temp >= 0:",
      "mutated_line": "while temp == 0:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp == 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ASR",
      "lineno": 56,
      "original_line": "temp -= 2",
      "mutated_line": "temp += 2",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp += 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "fact.append(i * fact[i - 1] % 1000000007)",
      "mutated_line": "fact.append(i / fact[i - 1] % 1000000007)",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i / fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "fact.append(i * fact[i - 1] % 1000000007)",
      "mutated_line": "fact.append((i + fact[i - 1]) % 1000000007)",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append((i + fact[i - 1]) % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "fact.append(i * fact[i - 1] % 1000000007)",
      "mutated_line": "fact.append(i ** fact[i - 1] % 1000000007)",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i ** fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "fact.append(i * fact[i - 1] % 1000000007)",
      "mutated_line": "fact.append(i * fact[i - 1] % 1000000008)",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000008)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "fact.append(i * fact[i - 1] % 1000000007)",
      "mutated_line": "fact.append(i * fact[i - 1] % 1000000006)",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000006)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "fact.append(i * fact[i - 1] % 1000000007)",
      "mutated_line": "fact.append(i * fact[i - 1] % 0)",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 0)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "fact.append(i * fact[i - 1] % 1000000007)",
      "mutated_line": "fact.append(i * fact[i - 1] % 1)",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "fact.append(i * fact[i - 1] % 1000000007)",
      "mutated_line": "fact.append(i * fact[i - 1] % -1000000007)",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % -1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b * 2 == 1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b * 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b + 2 == 1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b + 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 2 == 2:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 2:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 2 == 0:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 0:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 2 == 0:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 0:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 2 == -1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == -1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "x = x * y",
      "mutated_line": "x = x / y",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x / y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "x = x * y",
      "mutated_line": "x = x + y",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x + y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "x = x * y",
      "mutated_line": "x = x ** y",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x ** y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x > p:",
      "mutated_line": "if x >= p:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x >= p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x > p:",
      "mutated_line": "if x <= p:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x <= p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x > p:",
      "mutated_line": "if x != p:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x != p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "y = y % p",
      "mutated_line": "y = y * p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y * p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "y = y % p",
      "mutated_line": "y = y + p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y + p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "b = b // 2",
      "mutated_line": "b = b // 3",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 3\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "b = b // 2",
      "mutated_line": "b = b // 1",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 1\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "b = b // 2",
      "mutated_line": "b = b // 0",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 0\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "b = b // 2",
      "mutated_line": "b = b // 1",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 1\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "b = b // 2",
      "mutated_line": "b = b // -2",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // -2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return power(N, p - 2, p)",
      "mutated_line": "return power(N, p - 3, p)",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 3, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return power(N, p - 2, p)",
      "mutated_line": "return power(N, p - 1, p)",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 1, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return power(N, p - 2, p)",
      "mutated_line": "return power(N, p - 0, p)",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 0, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return power(N, p - 2, p)",
      "mutated_line": "return power(N, p - 1, p)",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 1, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return power(N, p - 2, p)",
      "mutated_line": "return power(N, p - -2, p)",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - -2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p",
      "mutated_line": "return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) * p) % p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) * p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p",
      "mutated_line": "return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) + p) % p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) + p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "while temp >= 0:",
      "mutated_line": "while temp >= 1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 1:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "while temp >= 0:",
      "mutated_line": "while temp >= -1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= -1:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "while temp >= 0:",
      "mutated_line": "while temp >= 1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 1:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "answer = (answer + combination(N, temp, p)) % p",
      "mutated_line": "answer = (answer + combination(N, temp, p)) * p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) * p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "answer = (answer + combination(N, temp, p)) % p",
      "mutated_line": "answer = answer + combination(N, temp, p) + p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = answer + combination(N, temp, p) + p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "temp -= 1",
      "mutated_line": "temp -= 2",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 2\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "temp -= 1",
      "mutated_line": "temp -= 0",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 0\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "temp -= 1",
      "mutated_line": "temp -= 0",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 0\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "temp -= 1",
      "mutated_line": "temp -= -1",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= -1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "while temp >= 0:",
      "mutated_line": "while temp >= 1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 1:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "while temp >= 0:",
      "mutated_line": "while temp >= -1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= -1:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "while temp >= 0:",
      "mutated_line": "while temp >= 1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 1:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "answer = (answer + combination(N, temp, p)) % p",
      "mutated_line": "answer = (answer + combination(N, temp, p)) * p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) * p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "answer = (answer + combination(N, temp, p)) % p",
      "mutated_line": "answer = answer + combination(N, temp, p) + p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = answer + combination(N, temp, p) + p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "temp -= 1",
      "mutated_line": "temp -= 2",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 2\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "temp -= 1",
      "mutated_line": "temp -= 0",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 0\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "temp -= 1",
      "mutated_line": "temp -= 0",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 0\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "temp -= 1",
      "mutated_line": "temp -= -1",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= -1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "while temp >= 0:",
      "mutated_line": "while temp >= 1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 1:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "while temp >= 0:",
      "mutated_line": "while temp >= -1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= -1:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "while temp >= 0:",
      "mutated_line": "while temp >= 1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 1:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "answer = (answer + combination(N, temp, p)) % p",
      "mutated_line": "answer = (answer + combination(N, temp, p)) * p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) * p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "answer = (answer + combination(N, temp, p)) % p",
      "mutated_line": "answer = answer + combination(N, temp, p) + p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = answer + combination(N, temp, p) + p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "temp -= 2",
      "mutated_line": "temp -= 3",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 3\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "temp -= 2",
      "mutated_line": "temp -= 1",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 1\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "temp -= 2",
      "mutated_line": "temp -= 0",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 0\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "temp -= 2",
      "mutated_line": "temp -= 1",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 1\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "temp -= 2",
      "mutated_line": "temp -= -2",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= -2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "while temp >= 0:",
      "mutated_line": "while temp >= 1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 1:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "while temp >= 0:",
      "mutated_line": "while temp >= -1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= -1:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "while temp >= 0:",
      "mutated_line": "while temp >= 1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 1:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "answer = (answer + combination(N, temp, p)) % p",
      "mutated_line": "answer = (answer + combination(N, temp, p)) * p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) * p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "answer = (answer + combination(N, temp, p)) % p",
      "mutated_line": "answer = answer + combination(N, temp, p) + p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = answer + combination(N, temp, p) + p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "temp -= 2",
      "mutated_line": "temp -= 3",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 3\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "temp -= 2",
      "mutated_line": "temp -= 1",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "temp -= 2",
      "mutated_line": "temp -= 0",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 0\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "temp -= 2",
      "mutated_line": "temp -= 1",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 1\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "temp -= 2",
      "mutated_line": "temp -= -2",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= -2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 3 == 1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 3 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 1 == 1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 1 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 0 == 1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 0 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % 1 == 1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 1 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if b % 2 == 1:",
      "mutated_line": "if b % -2 == 1:",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % -2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x = x % p",
      "mutated_line": "x = x * p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x * p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x = x % p",
      "mutated_line": "x = x + p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x + p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p",
      "mutated_line": "return fact[N] * (inverse(fact[R], p) / inverse(fact[N - R], p) % p) % p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) / inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p",
      "mutated_line": "return fact[N] * ((inverse(fact[R], p) + inverse(fact[N - R], p)) % p) % p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * ((inverse(fact[R], p) + inverse(fact[N - R], p)) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p",
      "mutated_line": "return fact[N] * (inverse(fact[R], p) ** inverse(fact[N - R], p) % p) % p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) ** inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "answer = (answer + combination(N, temp, p)) % p",
      "mutated_line": "answer = (answer - combination(N, temp, p)) % p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer - combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "answer = (answer + combination(N, temp, p)) % p",
      "mutated_line": "answer = answer * combination(N, temp, p) % p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = answer * combination(N, temp, p) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "answer = (answer + combination(N, temp, p)) % p",
      "mutated_line": "answer = (answer - combination(N, temp, p)) % p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer - combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "answer = (answer + combination(N, temp, p)) % p",
      "mutated_line": "answer = answer * combination(N, temp, p) % p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = answer * combination(N, temp, p) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "answer = (answer + combination(N, temp, p)) % p",
      "mutated_line": "answer = (answer - combination(N, temp, p)) % p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer - combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "answer = (answer + combination(N, temp, p)) % p",
      "mutated_line": "answer = answer * combination(N, temp, p) % p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = answer * combination(N, temp, p) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "answer = (answer + combination(N, temp, p)) % p",
      "mutated_line": "answer = (answer - combination(N, temp, p)) % p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer - combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "answer = (answer + combination(N, temp, p)) % p",
      "mutated_line": "answer = answer * combination(N, temp, p) % p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = answer * combination(N, temp, p) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "fact.append(i * fact[i - 1] % 1000000007)",
      "mutated_line": "fact.append(i * fact[i + 1] % 1000000007)",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i + 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "fact.append(i * fact[i - 1] % 1000000007)",
      "mutated_line": "fact.append(i * fact[i * 1] % 1000000007)",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i * 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "fact.append(i * fact[i - 1] % 1000000007)",
      "mutated_line": "fact.append(i * fact[i - 2] % 1000000007)",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 2] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "fact.append(i * fact[i - 1] % 1000000007)",
      "mutated_line": "fact.append(i * fact[i - 0] % 1000000007)",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 0] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "fact.append(i * fact[i - 1] % 1000000007)",
      "mutated_line": "fact.append(i * fact[i - 0] % 1000000007)",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 0] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "fact.append(i * fact[i - 1] % 1000000007)",
      "mutated_line": "fact.append(i * fact[i - -1] % 1000000007)",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - -1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p",
      "mutated_line": "return fact[N] * (inverse(fact[R], p) * inverse(fact[N + R], p) % p) % p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N + R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return fact[N] * (inverse(fact[R], p) * inverse(fact[N - R], p) % p) % p",
      "mutated_line": "return fact[N] * (inverse(fact[R], p) * inverse(fact[N * R], p) % p) % p",
      "code": "def count_different_arrays(N, K, A):\n    fact = [1]\n    for i in range(1, 100001):\n        fact.append(i * fact[i - 1] % 1000000007)\n\n    def power(a, b, p):\n        x = 1\n        y = a\n        while b > 0:\n            if b % 2 == 1:\n                x = x * y\n                if x > p:\n                    x = x % p\n            y = y * y\n            if y > p:\n                y = y % p\n            b = b // 2\n        return x\n\n    def inverse(N, p):\n        return power(N, p - 2, p)\n\n    def combination(N, R, p):\n        return fact[N] * (inverse(fact[R], p) * inverse(fact[N * R], p) % p) % p\n    numZ = 0\n    answer = 0\n    p = 1000000007\n    for j in range(len(A)):\n        if A[j] == 0:\n            numZ += 1\n    N = N - numZ\n    if numZ > 0:\n        if N > K:\n            temp = K\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n        else:\n            temp = N\n            while temp >= 0:\n                answer = (answer + combination(N, temp, p)) % p\n                temp -= 1\n    elif N > K:\n        temp = K\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    else:\n        temp = N\n        while temp >= 0:\n            answer = (answer + combination(N, temp, p)) % p\n            temp -= 2\n    return answer"
    }
  ]
}