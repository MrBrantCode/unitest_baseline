{
  "task_id": "taco_4600",
  "entry_point": "calculate_minimal_coverage",
  "mutant_count": 59,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "while abs(ok - ng) > 1:",
      "mutated_line": "while abs(ok - ng) >= 1:",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) >= 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "while abs(ok - ng) > 1:",
      "mutated_line": "while abs(ok - ng) <= 1:",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) <= 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "while abs(ok - ng) > 1:",
      "mutated_line": "while abs(ok - ng) != 1:",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) != 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "while abs(ok - ng) > 1:",
      "mutated_line": "while abs(ok - ng) > 2:",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 2:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "while abs(ok - ng) > 1:",
      "mutated_line": "while abs(ok - ng) > 0:",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 0:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "while abs(ok - ng) > 1:",
      "mutated_line": "while abs(ok - ng) > 0:",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 0:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "while abs(ok - ng) > 1:",
      "mutated_line": "while abs(ok - ng) > -1:",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > -1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mid = (ok + ng) // 2",
      "mutated_line": "mid = (ok + ng) / 2",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) / 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mid = (ok + ng) // 2",
      "mutated_line": "mid = (ok + ng) * 2",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) * 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "bit = (1 << n + 1) - 1",
      "mutated_line": "bit = (1 << n + 1) + 1",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) + 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "bit = (1 << n + 1) - 1",
      "mutated_line": "bit = (1 << n + 1) * 1",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) * 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "return dp != 0",
      "mutated_line": "return dp == 0",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp == 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)",
      "mutated_line": "ans = Bisect_Int(max(A) * 2 - 1, -1, is_ok)",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 - 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)",
      "mutated_line": "ans = Bisect_Int(max(A) * 2 * 1, -1, is_ok)",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 * 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)",
      "mutated_line": "ans = Bisect_Int(max(A) * 2 + 1, +1, is_ok)",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, +1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "while abs(ok - ng) > 1:",
      "mutated_line": "while abs(ok + ng) > 1:",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok + ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "while abs(ok - ng) > 1:",
      "mutated_line": "while abs(ok * ng) > 1:",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok * ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mid = (ok + ng) // 2",
      "mutated_line": "mid = (ok - ng) // 2",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok - ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "mid = (ok + ng) // 2",
      "mutated_line": "mid = ok * ng // 2",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = ok * ng // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mid = (ok + ng) // 2",
      "mutated_line": "mid = (ok + ng) // 3",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 3\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mid = (ok + ng) // 2",
      "mutated_line": "mid = (ok + ng) // 1",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 1\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mid = (ok + ng) // 2",
      "mutated_line": "mid = (ok + ng) // 0",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 0\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mid = (ok + ng) // 2",
      "mutated_line": "mid = (ok + ng) // 1",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 1\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "mid = (ok + ng) // 2",
      "mutated_line": "mid = (ok + ng) // -2",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // -2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "bit = (1 << n + 1) - 1",
      "mutated_line": "bit = (1 << n + 1) - 2",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 2\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "bit = (1 << n + 1) - 1",
      "mutated_line": "bit = (1 << n + 1) - 0",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 0\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "bit = (1 << n + 1) - 1",
      "mutated_line": "bit = (1 << n + 1) - 0",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 0\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "bit = (1 << n + 1) - 1",
      "mutated_line": "bit = (1 << n + 1) - -1",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - -1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dp = dp << a | dp >> a",
      "mutated_line": "dp = dp << a & dp >> a",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a & dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dp = dp << a | dp >> a",
      "mutated_line": "dp = dp << a ^ dp >> a",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a ^ dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return dp != 0",
      "mutated_line": "return dp != 1",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 1\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return dp != 0",
      "mutated_line": "return dp != -1",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != -1\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return dp != 0",
      "mutated_line": "return dp != 1",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 1\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)",
      "mutated_line": "ans = Bisect_Int(max(A) / 2 + 1, -1, is_ok)",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) / 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)",
      "mutated_line": "ans = Bisect_Int(max(A) + 2 + 1, -1, is_ok)",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) + 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)",
      "mutated_line": "ans = Bisect_Int(max(A) ** 2 + 1, -1, is_ok)",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) ** 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)",
      "mutated_line": "ans = Bisect_Int(max(A) * 2 + 2, -1, is_ok)",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 2, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)",
      "mutated_line": "ans = Bisect_Int(max(A) * 2 + 0, -1, is_ok)",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 0, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)",
      "mutated_line": "ans = Bisect_Int(max(A) * 2 + 0, -1, is_ok)",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 0, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)",
      "mutated_line": "ans = Bisect_Int(max(A) * 2 + -1, -1, is_ok)",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + -1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)",
      "mutated_line": "ans = Bisect_Int(max(A) * 2 + 1, -2, is_ok)",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -2, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)",
      "mutated_line": "ans = Bisect_Int(max(A) * 2 + 1, -0, is_ok)",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -0, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)",
      "mutated_line": "ans = Bisect_Int(max(A) * 2 + 1, -0, is_ok)",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -0, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)",
      "mutated_line": "ans = Bisect_Int(max(A) * 2 + 1, --1, is_ok)",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, --1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "bit = (1 << n + 1) - 1",
      "mutated_line": "bit = (2 << n + 1) - 1",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (2 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "bit = (1 << n + 1) - 1",
      "mutated_line": "bit = (0 << n + 1) - 1",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (0 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "bit = (1 << n + 1) - 1",
      "mutated_line": "bit = (0 << n + 1) - 1",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (0 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "bit = (1 << n + 1) - 1",
      "mutated_line": "bit = (-1 << n + 1) - 1",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (-1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "bit = (1 << n + 1) - 1",
      "mutated_line": "bit = (1 << n - 1) - 1",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n - 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "bit = (1 << n + 1) - 1",
      "mutated_line": "bit = (1 << n * 1) - 1",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n * 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)",
      "mutated_line": "ans = Bisect_Int(max(A) * 3 + 1, -1, is_ok)",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 3 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)",
      "mutated_line": "ans = Bisect_Int(max(A) * 1 + 1, -1, is_ok)",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 1 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)",
      "mutated_line": "ans = Bisect_Int(max(A) * 0 + 1, -1, is_ok)",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 0 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)",
      "mutated_line": "ans = Bisect_Int(max(A) * 1 + 1, -1, is_ok)",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 1 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)",
      "mutated_line": "ans = Bisect_Int(max(A) * -2 + 1, -1, is_ok)",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * -2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "bit = (1 << n + 1) - 1",
      "mutated_line": "bit = (1 << n + 2) - 1",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 2) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "bit = (1 << n + 1) - 1",
      "mutated_line": "bit = (1 << n + 0) - 1",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 0) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "bit = (1 << n + 1) - 1",
      "mutated_line": "bit = (1 << n + 0) - 1",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + 0) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "bit = (1 << n + 1) - 1",
      "mutated_line": "bit = (1 << n + -1) - 1",
      "code": "def calculate_minimal_coverage(test_cases):\n\n    def Bisect_Int(ok, ng, is_ok):\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) // 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    results = []\n    for (N, A) in test_cases:\n\n        def is_ok(n):\n            bit = (1 << n + -1) - 1\n            dp = bit\n            for a in A:\n                dp = dp << a | dp >> a\n                dp &= bit\n            return dp != 0\n        ans = Bisect_Int(max(A) * 2 + 1, -1, is_ok)\n        results.append(ans)\n    return results"
    }
  ]
}