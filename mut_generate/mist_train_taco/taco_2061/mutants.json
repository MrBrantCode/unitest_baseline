{
  "task_id": "taco_2061",
  "entry_point": "shortest_bridge_distance",
  "mutant_count": 115,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "found = False",
      "mutated_line": "found = True",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = True\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "steps = 0",
      "mutated_line": "steps = 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 1\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "steps = 0",
      "mutated_line": "steps = -1",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = -1\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "steps = 0",
      "mutated_line": "steps = 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 1\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "ASR",
      "lineno": 46,
      "original_line": "steps += 1",
      "mutated_line": "steps -= 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps -= 1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "steps += 1",
      "mutated_line": "steps += 2",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 2"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "steps += 1",
      "mutated_line": "steps += 0",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 0"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "steps += 1",
      "mutated_line": "steps += 0",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 0"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "steps += 1",
      "mutated_line": "steps += -1",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(1, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(1, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(-1, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(-1, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(1, 1), (1, 0), (0, -1), (-1, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(1, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 2), (1, 0), (0, -1), (-1, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 2), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 0), (1, 0), (0, -1), (-1, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 0), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 0), (1, 0), (0, -1), (-1, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 0), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, -1), (1, 0), (0, -1), (-1, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, -1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 1), (2, 0), (0, -1), (-1, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (2, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 1), (0, 0), (0, -1), (-1, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (0, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 1), (0, 0), (0, -1), (-1, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (0, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 1), (-1, 0), (0, -1), (-1, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (-1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 1), (1, 1), (0, -1), (-1, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 1), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 1), (1, -1), (0, -1), (-1, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, -1), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 1), (1, 1), (0, -1), (-1, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 1), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 1), (1, 0), (1, -1), (-1, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (1, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 1), (1, 0), (-1, -1), (-1, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (-1, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 1), (1, 0), (1, -1), (-1, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (1, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 1), (1, 0), (0, +1), (-1, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, +1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 1), (1, 0), (0, -1), (+1, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (+1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 1)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 1)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, -1)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, -1)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 1)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 1)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if A[i][j] == 1:",
      "mutated_line": "if A[i][j] != 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] != 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(m, n) = (len(A), len(A[0]))",
      "mutated_line": "(m, n) = (len(A), len(A[1]))",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[1]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(m, n) = (len(A), len(A[0]))",
      "mutated_line": "(m, n) = (len(A), len(A[-1]))",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[-1]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "(m, n) = (len(A), len(A[0]))",
      "mutated_line": "(m, n) = (len(A), len(A[1]))",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[1]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 1), (1, 0), (0, -2), (-1, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -2), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 1), (1, 0), (0, -0), (-1, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -0), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 1), (1, 0), (0, -0), (-1, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -0), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 1), (1, 0), (0, --1), (-1, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, --1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 1), (1, 0), (0, -1), (-2, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-2, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 1), (1, 0), (0, -1), (-0, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-0, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 1), (1, 0), (0, -1), (-0, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-0, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
      "mutated_line": "dirs = [(0, 1), (1, 0), (0, -1), (--1, 0)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (--1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if A[i][j] == 1:",
      "mutated_line": "if A[i][j] == 2:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 2:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if A[i][j] == 1:",
      "mutated_line": "if A[i][j] == 0:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 0:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if A[i][j] == 1:",
      "mutated_line": "if A[i][j] == 0:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 0:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if A[i][j] == 1:",
      "mutated_line": "if A[i][j] == -1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == -1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "A[i][j] = 2",
      "mutated_line": "A[i][j] = 3",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 3\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "A[i][j] = 2",
      "mutated_line": "A[i][j] = 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 1\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "A[i][j] = 2",
      "mutated_line": "A[i][j] = 0",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 0\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "A[i][j] = 2",
      "mutated_line": "A[i][j] = 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 1\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "A[i][j] = 2",
      "mutated_line": "A[i][j] = -2",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = -2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "found = True",
      "mutated_line": "found = False",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = False\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if 0 <= ni < m or 0 <= nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m or 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "(ni, nj) = (i + di, j + dj)",
      "mutated_line": "(ni, nj) = (i - di, j + dj)",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i - di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "(ni, nj) = (i + di, j + dj)",
      "mutated_line": "(ni, nj) = (i * di, j + dj)",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i * di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "(ni, nj) = (i + di, j + dj)",
      "mutated_line": "(ni, nj) = (i + di, j - dj)",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j - dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "(ni, nj) = (i + di, j + dj)",
      "mutated_line": "(ni, nj) = (i + di, j * dj)",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j * dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if 0 < ni < m and 0 <= nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 < ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if 0 > ni < m and 0 <= nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 > ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if 0 == ni < m and 0 <= nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 == ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if 0 <= ni < m and 0 < nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 < nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if 0 <= ni < m and 0 > nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 > nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if 0 <= ni < m and 0 == nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 == nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if A[ni][nj] == 0:",
      "mutated_line": "if A[ni][nj] != 0:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] != 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if 0 <= ni < m or 0 <= nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m or 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if 1 <= ni < m and 0 <= nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 1 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if -1 <= ni < m and 0 <= nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if -1 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if 1 <= ni < m and 0 <= nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 1 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if 0 <= ni < m and 1 <= nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 1 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if 0 <= ni < m and -1 <= nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and -1 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if 0 <= ni < m and 1 <= nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 1 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if A[ni][nj] == 0:",
      "mutated_line": "if A[ni][nj] == 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 1:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if A[ni][nj] == 0:",
      "mutated_line": "if A[ni][nj] == -1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == -1:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if A[ni][nj] == 0:",
      "mutated_line": "if A[ni][nj] == 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 1:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "A[ni][nj] = 2",
      "mutated_line": "A[ni][nj] = 3",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 3\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "A[ni][nj] = 2",
      "mutated_line": "A[ni][nj] = 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 1\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "A[ni][nj] = 2",
      "mutated_line": "A[ni][nj] = 0",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 0\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "A[ni][nj] = 2",
      "mutated_line": "A[ni][nj] = 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 1\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "A[ni][nj] = 2",
      "mutated_line": "A[ni][nj] = -2",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = -2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "elif A[ni][nj] == 1:",
      "mutated_line": "elif A[ni][nj] != 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] != 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "(ni, nj) = (ci + di, cj + dj)",
      "mutated_line": "(ni, nj) = (ci - di, cj + dj)",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci - di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "(ni, nj) = (ci + di, cj + dj)",
      "mutated_line": "(ni, nj) = (ci * di, cj + dj)",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci * di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "(ni, nj) = (ci + di, cj + dj)",
      "mutated_line": "(ni, nj) = (ci + di, cj - dj)",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj - dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "(ni, nj) = (ci + di, cj + dj)",
      "mutated_line": "(ni, nj) = (ci + di, cj * dj)",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj * dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if 0 < ni < m and 0 <= nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 < ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if 0 > ni < m and 0 <= nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 > ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if 0 == ni < m and 0 <= nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 == ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if 0 <= ni < m and 0 < nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 < nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if 0 <= ni < m and 0 > nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 > nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if 0 <= ni < m and 0 == nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 == nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if A[ni][nj] == 1:",
      "mutated_line": "if A[ni][nj] != 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] != 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "elif A[ni][nj] == 1:",
      "mutated_line": "elif A[ni][nj] == 2:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 2:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "elif A[ni][nj] == 1:",
      "mutated_line": "elif A[ni][nj] == 0:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 0:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "elif A[ni][nj] == 1:",
      "mutated_line": "elif A[ni][nj] == 0:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 0:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "elif A[ni][nj] == 1:",
      "mutated_line": "elif A[ni][nj] == -1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == -1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if 1 <= ni < m and 0 <= nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 1 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if -1 <= ni < m and 0 <= nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if -1 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if 1 <= ni < m and 0 <= nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 1 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if 0 <= ni < m and 1 <= nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 1 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if 0 <= ni < m and -1 <= nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and -1 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if 0 <= ni < m and 0 <= nj < n:",
      "mutated_line": "if 0 <= ni < m and 1 <= nj < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 1 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if A[ni][nj] == 1:",
      "mutated_line": "if A[ni][nj] == 2:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 2:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if A[ni][nj] == 1:",
      "mutated_line": "if A[ni][nj] == 0:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 0:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if A[ni][nj] == 1:",
      "mutated_line": "if A[ni][nj] == 0:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 0:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if A[ni][nj] == 1:",
      "mutated_line": "if A[ni][nj] == -1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == -1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "A[ni][nj] = 2",
      "mutated_line": "A[ni][nj] = 3",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 3\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "A[ni][nj] = 2",
      "mutated_line": "A[ni][nj] = 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 1\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "A[ni][nj] = 2",
      "mutated_line": "A[ni][nj] = 0",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 0\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "A[ni][nj] = 2",
      "mutated_line": "A[ni][nj] = 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 1\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "A[ni][nj] = 2",
      "mutated_line": "A[ni][nj] = -2",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = -2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif A[ni][nj] == 0:",
      "mutated_line": "elif A[ni][nj] != 0:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] != 0:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif A[ni][nj] == 0:",
      "mutated_line": "elif A[ni][nj] == 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 1:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif A[ni][nj] == 0:",
      "mutated_line": "elif A[ni][nj] == -1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == -1:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif A[ni][nj] == 0:",
      "mutated_line": "elif A[ni][nj] == 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_bridge_distance(A: List[List[int]]) -> int:\n    (m, n) = (len(A), len(A[0]))\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = deque()\n    boundary = set()\n    found = False\n    for i in range(m):\n        for j in range(n):\n            if A[i][j] == 1:\n                A[i][j] = 2\n                queue.append((i, j))\n                while queue:\n                    (ci, cj) = queue.popleft()\n                    for (di, dj) in dirs:\n                        (ni, nj) = (ci + di, cj + dj)\n                        if 0 <= ni < m and 0 <= nj < n:\n                            if A[ni][nj] == 1:\n                                A[ni][nj] = 2\n                                queue.append((ni, nj))\n                            elif A[ni][nj] == 1:\n                                boundary.add((ci, cj))\n                found = True\n                break\n        if found:\n            break\n    queue = deque(boundary)\n    steps = 0\n    while queue:\n        for _ in range(len(queue)):\n            (i, j) = queue.popleft()\n            for (di, dj) in dirs:\n                (ni, nj) = (i + di, j + dj)\n                if 0 <= ni < m and 0 <= nj < n:\n                    if A[ni][nj] == 0:\n                        A[ni][nj] = 2\n                        queue.append((ni, nj))\n                    elif A[ni][nj] == 1:\n                        return steps\n        steps += 1"
    }
  ]
}