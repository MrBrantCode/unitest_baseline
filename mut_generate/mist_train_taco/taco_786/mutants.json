{
  "task_id": "taco_786",
  "entry_point": "reconstruct_initial_matrix",
  "mutant_count": 114,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "p = [[0] * m for _ in range(n)]",
      "mutated_line": "p = [[0] / m for _ in range(n)]",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] / m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "p = [[0] * m for _ in range(n)]",
      "mutated_line": "p = [[0] + m for _ in range(n)]",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] + m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "p = [[0] * m for _ in range(n)]",
      "mutated_line": "p = [[0] ** m for _ in range(n)]",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] ** m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if t[0] == 1:",
      "mutated_line": "if t[0] != 1:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] != 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "for t in operations[::-1]:",
      "mutated_line": "for t in operations[::+1]:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::+1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if t[0] == 1:",
      "mutated_line": "if t[0] == 2:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 2:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if t[0] == 1:",
      "mutated_line": "if t[0] == 0:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 0:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if t[0] == 1:",
      "mutated_line": "if t[0] == 0:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 0:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if t[0] == 1:",
      "mutated_line": "if t[0] == -1:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == -1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "j = t[1] - 1",
      "mutated_line": "j = t[1] + 1",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] + 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "j = t[1] - 1",
      "mutated_line": "j = t[1] * 1",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] * 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "elif t[0] == 2:",
      "mutated_line": "elif t[0] != 2:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] != 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "p = [[0] * m for _ in range(n)]",
      "mutated_line": "p = [[1] * m for _ in range(n)]",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[1] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "p = [[0] * m for _ in range(n)]",
      "mutated_line": "p = [[-1] * m for _ in range(n)]",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[-1] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "p = [[0] * m for _ in range(n)]",
      "mutated_line": "p = [[1] * m for _ in range(n)]",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[1] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for t in operations[::-1]:",
      "mutated_line": "for t in operations[::-2]:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-2]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for t in operations[::-1]:",
      "mutated_line": "for t in operations[::-0]:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-0]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for t in operations[::-1]:",
      "mutated_line": "for t in operations[::-0]:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-0]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for t in operations[::-1]:",
      "mutated_line": "for t in operations[::--1]:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::--1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if t[0] == 1:",
      "mutated_line": "if t[1] == 1:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[1] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if t[0] == 1:",
      "mutated_line": "if t[-1] == 1:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[-1] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if t[0] == 1:",
      "mutated_line": "if t[1] == 1:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[1] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "j = t[1] - 1",
      "mutated_line": "j = t[1] - 2",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 2\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "j = t[1] - 1",
      "mutated_line": "j = t[1] - 0",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 0\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "j = t[1] - 1",
      "mutated_line": "j = t[1] - 0",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 0\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "j = t[1] - 1",
      "mutated_line": "j = t[1] - -1",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - -1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p[j].insert(0, p[j].pop())",
      "mutated_line": "p[j].insert(1, p[j].pop())",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(1, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p[j].insert(0, p[j].pop())",
      "mutated_line": "p[j].insert(-1, p[j].pop())",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(-1, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "p[j].insert(0, p[j].pop())",
      "mutated_line": "p[j].insert(1, p[j].pop())",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(1, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif t[0] == 2:",
      "mutated_line": "elif t[0] == 3:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 3:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif t[0] == 2:",
      "mutated_line": "elif t[0] == 1:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 1:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif t[0] == 2:",
      "mutated_line": "elif t[0] == 0:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 0:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif t[0] == 2:",
      "mutated_line": "elif t[0] == 1:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 1:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif t[0] == 2:",
      "mutated_line": "elif t[0] == -2:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == -2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "j = t[1] - 1",
      "mutated_line": "j = t[1] + 1",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] + 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "j = t[1] - 1",
      "mutated_line": "j = t[1] * 1",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] * 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "elif t[0] == 3:",
      "mutated_line": "elif t[0] != 3:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] != 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "j = t[1] - 1",
      "mutated_line": "j = t[2] - 1",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[2] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "j = t[1] - 1",
      "mutated_line": "j = t[0] - 1",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[0] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "j = t[1] - 1",
      "mutated_line": "j = t[0] - 1",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[0] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "j = t[1] - 1",
      "mutated_line": "j = t[-1] - 1",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[-1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif t[0] == 2:",
      "mutated_line": "elif t[1] == 2:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[1] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif t[0] == 2:",
      "mutated_line": "elif t[-1] == 2:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[-1] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif t[0] == 2:",
      "mutated_line": "elif t[1] == 2:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[1] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "j = t[1] - 1",
      "mutated_line": "j = t[1] - 2",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 2\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "j = t[1] - 1",
      "mutated_line": "j = t[1] - 0",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 0\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "j = t[1] - 1",
      "mutated_line": "j = t[1] - 0",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 0\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "j = t[1] - 1",
      "mutated_line": "j = t[1] - -1",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - -1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n + 1, 0, -1):",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n + 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n * 1, 0, -1):",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n * 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 1, -1):",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 1, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, -1, -1):",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, -1, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 1, -1):",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 1, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 0, +1):",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, +1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "elif t[0] == 3:",
      "mutated_line": "elif t[0] == 4:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 4:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "elif t[0] == 3:",
      "mutated_line": "elif t[0] == 2:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 2:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "elif t[0] == 3:",
      "mutated_line": "elif t[0] == 0:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 0:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "elif t[0] == 3:",
      "mutated_line": "elif t[0] == 1:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 1:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "elif t[0] == 3:",
      "mutated_line": "elif t[0] == -3:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == -3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "j = t[1] - 1",
      "mutated_line": "j = t[2] - 1",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[2] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "j = t[1] - 1",
      "mutated_line": "j = t[0] - 1",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[0] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "j = t[1] - 1",
      "mutated_line": "j = t[0] - 1",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[0] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "j = t[1] - 1",
      "mutated_line": "j = t[-1] - 1",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[-1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "s = p[-1][j]",
      "mutated_line": "s = p[+1][j]",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[+1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 2, 0, -1):",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 2, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 0, 0, -1):",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 0, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 0, 0, -1):",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 0, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - -1, 0, -1):",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - -1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 0, -2):",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -2):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 0, -0):",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -0):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 0, -0):",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -0):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(n - 1, 0, -1):",
      "mutated_line": "for i in range(n - 1, 0, --1):",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, --1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[0][j] = s",
      "mutated_line": "p[1][j] = s",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[1][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[0][j] = s",
      "mutated_line": "p[-1][j] = s",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[-1][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p[0][j] = s",
      "mutated_line": "p[1][j] = s",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[1][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "elif t[0] == 3:",
      "mutated_line": "elif t[1] == 3:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[1] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "elif t[0] == 3:",
      "mutated_line": "elif t[-1] == 3:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[-1] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "elif t[0] == 3:",
      "mutated_line": "elif t[1] == 3:",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[1] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[1] + 1, t[2] - 1, t[3])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] + 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[1] * 1, t[2] - 1, t[3])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] * 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[1] - 1, t[2] + 1, t[3])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] + 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[1] - 1, t[2] * 1, t[3])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] * 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "s = p[-1][j]",
      "mutated_line": "s = p[-2][j]",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-2][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "s = p[-1][j]",
      "mutated_line": "s = p[-0][j]",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-0][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "s = p[-1][j]",
      "mutated_line": "s = p[-0][j]",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-0][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "s = p[-1][j]",
      "mutated_line": "s = p[--1][j]",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[--1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "p[i][j] = p[i - 1][j]",
      "mutated_line": "p[i][j] = p[i + 1][j]",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i + 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "p[i][j] = p[i - 1][j]",
      "mutated_line": "p[i][j] = p[i * 1][j]",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i * 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[1] - 2, t[2] - 1, t[3])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 2, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[1] - 0, t[2] - 1, t[3])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 0, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[1] - 0, t[2] - 1, t[3])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 0, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[1] - -1, t[2] - 1, t[3])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - -1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[1] - 1, t[2] - 2, t[3])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 2, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[1] - 1, t[2] - 0, t[3])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 0, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[1] - 1, t[2] - 0, t[3])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 0, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[1] - 1, t[2] - -1, t[3])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - -1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[1] - 1, t[2] - 1, t[4])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[4])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[1] - 1, t[2] - 1, t[2])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[2])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[1] - 1, t[2] - 1, t[0])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[0])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[1] - 1, t[2] - 1, t[1])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[1])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[1] - 1, t[2] - 1, t[-3])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[-3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[i][j] = p[i - 1][j]",
      "mutated_line": "p[i][j] = p[i - 2][j]",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 2][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[i][j] = p[i - 1][j]",
      "mutated_line": "p[i][j] = p[i - 0][j]",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 0][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[i][j] = p[i - 1][j]",
      "mutated_line": "p[i][j] = p[i - 0][j]",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 0][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "p[i][j] = p[i - 1][j]",
      "mutated_line": "p[i][j] = p[i - -1][j]",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - -1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[2] - 1, t[2] - 1, t[3])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[2] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[0] - 1, t[2] - 1, t[3])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[0] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[0] - 1, t[2] - 1, t[3])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[0] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[-1] - 1, t[2] - 1, t[3])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[-1] - 1, t[2] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[1] - 1, t[3] - 1, t[3])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[3] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[1] - 1, t[1] - 1, t[3])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[1] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[1] - 1, t[0] - 1, t[3])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[0] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[1] - 1, t[1] - 1, t[3])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[1] - 1, t[3])\n            p[r][c] = x\n    return p"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "r, c, x = t[1] - 1, t[2] - 1, t[3]",
      "mutated_line": "(r, c, x) = (t[1] - 1, t[-2] - 1, t[3])",
      "code": "def reconstruct_initial_matrix(n, m, q, operations):\n    p = [[0] * m for _ in range(n)]\n    for t in operations[::-1]:\n        if t[0] == 1:\n            j = t[1] - 1\n            p[j].insert(0, p[j].pop())\n        elif t[0] == 2:\n            j = t[1] - 1\n            s = p[-1][j]\n            for i in range(n - 1, 0, -1):\n                p[i][j] = p[i - 1][j]\n            p[0][j] = s\n        elif t[0] == 3:\n            (r, c, x) = (t[1] - 1, t[-2] - 1, t[3])\n            p[r][c] = x\n    return p"
    }
  ]
}