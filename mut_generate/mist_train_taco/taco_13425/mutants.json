{
  "task_id": "taco_13425",
  "entry_point": "find_cheapest_transportation_cost",
  "mutant_count": 162,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 5,
      "original_line": "s -= 1",
      "mutated_line": "s += 1",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s += 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "ASR",
      "lineno": 6,
      "original_line": "d -= 1",
      "mutated_line": "d += 1",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d += 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 * 20",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 * 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 + 20",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 + 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "s -= 1",
      "mutated_line": "s -= 2",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 2\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "s -= 1",
      "mutated_line": "s -= 0",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 0\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "s -= 1",
      "mutated_line": "s -= 0",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 0\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "s -= 1",
      "mutated_line": "s -= -1",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= -1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d -= 1",
      "mutated_line": "d -= 2",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 2\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d -= 1",
      "mutated_line": "d -= 0",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 0\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d -= 1",
      "mutated_line": "d -= 0",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 0\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "d -= 1",
      "mutated_line": "d -= -1",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= -1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "a -= 1",
      "mutated_line": "a += 1",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a += 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "b -= 1",
      "mutated_line": "b += 1",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b += 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "cost = [INF] * (n * (c + 1))",
      "mutated_line": "cost = [INF] / (n * (c + 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] / (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "cost = [INF] * (n * (c + 1))",
      "mutated_line": "cost = [INF] + n * (c + 1)",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] + n * (c + 1)\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "cost = [INF] * (n * (c + 1))",
      "mutated_line": "cost = [INF] ** (n * (c + 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] ** (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 11 ** 20",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 11 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 9 ** 20",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 9 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 0 ** 20",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 0 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 1 ** 20",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 1 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = -10 ** 20",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = -10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 21",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 21\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 19",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 19\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 0",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 0\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 1",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 1\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** -20",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** -20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a -= 1",
      "mutated_line": "a -= 2",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 2\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a -= 1",
      "mutated_line": "a -= 0",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 0\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a -= 1",
      "mutated_line": "a -= 0",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 0\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a -= 1",
      "mutated_line": "a -= -1",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= -1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b -= 1",
      "mutated_line": "b -= 2",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 2\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b -= 1",
      "mutated_line": "b -= 0",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 0\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b -= 1",
      "mutated_line": "b -= 0",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 0\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b -= 1",
      "mutated_line": "b -= -1",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= -1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "cost = [INF] * (n * (c + 1))",
      "mutated_line": "cost = [INF] * (n / (c + 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n / (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "cost = [INF] * (n * (c + 1))",
      "mutated_line": "cost = [INF] * (n + (c + 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n + (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "cost = [INF] * (n * (c + 1))",
      "mutated_line": "cost = [INF] * n ** (c + 1)",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * n ** (c + 1)\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return cost[d + n * c]",
      "mutated_line": "return cost[d - n * c]",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d - n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return cost[d + n * c]",
      "mutated_line": "return cost[d * (n * c)]",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d * (n * c)]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in range(c + 1):",
      "mutated_line": "for i in range(c - 1):",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c - 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in range(c + 1):",
      "mutated_line": "for i in range(c * 1):",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c * 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if i != c:",
      "mutated_line": "if i == c:",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i == c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "cost = [INF] * (n * (c + 1))",
      "mutated_line": "cost = [INF] * (n * (c - 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c - 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "cost = [INF] * (n * (c + 1))",
      "mutated_line": "cost = [INF] * (n * (c * 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c * 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(que, (0, s))",
      "mutated_line": "heappush(que, (1, s))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (1, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(que, (0, s))",
      "mutated_line": "heappush(que, (-1, s))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (-1, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "heappush(que, (0, s))",
      "mutated_line": "heappush(que, (1, s))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (1, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if cost[to] > total + fee:",
      "mutated_line": "if cost[to] >= total + fee:",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] >= total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if cost[to] > total + fee:",
      "mutated_line": "if cost[to] <= total + fee:",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] <= total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if cost[to] > total + fee:",
      "mutated_line": "if cost[to] != total + fee:",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] != total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return cost[d + n * c]",
      "mutated_line": "return cost[d + n / c]",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n / c]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return cost[d + n * c]",
      "mutated_line": "return cost[d + (n + c)]",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + (n + c)]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return cost[d + n * c]",
      "mutated_line": "return cost[d + n ** c]",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n ** c]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "edges = [[] for _ in range(n * (c + 1))]",
      "mutated_line": "edges = [[] for _ in range(n / (c + 1))]",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n / (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "edges = [[] for _ in range(n * (c + 1))]",
      "mutated_line": "edges = [[] for _ in range(n + (c + 1))]",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n + (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "edges = [[] for _ in range(n * (c + 1))]",
      "mutated_line": "edges = [[] for _ in range(n ** (c + 1))]",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n ** (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(c + 1):",
      "mutated_line": "for i in range(c + 2):",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 2):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(c + 1):",
      "mutated_line": "for i in range(c + 0):",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 0):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(c + 1):",
      "mutated_line": "for i in range(c + 0):",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 0):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(c + 1):",
      "mutated_line": "for i in range(c + -1):",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + -1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "edges[d + i * n].append((d + (i + 1) * n, 0))",
      "mutated_line": "edges[d + i * n].append((d - (i + 1) * n, 0))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d - (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "edges[d + i * n].append((d + (i + 1) * n, 0))",
      "mutated_line": "edges[d + i * n].append((d * ((i + 1) * n), 0))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d * ((i + 1) * n), 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "edges[d + i * n].append((d + (i + 1) * n, 0))",
      "mutated_line": "edges[d + i * n].append((d + (i + 1) * n, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 1))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "edges[d + i * n].append((d + (i + 1) * n, 0))",
      "mutated_line": "edges[d + i * n].append((d + (i + 1) * n, -1))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, -1))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "edges[d + i * n].append((d + (i + 1) * n, 0))",
      "mutated_line": "edges[d + i * n].append((d + (i + 1) * n, 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 1))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "cost = [INF] * (n * (c + 1))",
      "mutated_line": "cost = [INF] * (n * (c + 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 2))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "cost = [INF] * (n * (c + 1))",
      "mutated_line": "cost = [INF] * (n * (c + 0))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 0))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "cost = [INF] * (n * (c + 1))",
      "mutated_line": "cost = [INF] * (n * (c + 0))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 0))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "cost = [INF] * (n * (c + 1))",
      "mutated_line": "cost = [INF] * (n * (c + -1))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + -1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if cost[to] > total + fee:",
      "mutated_line": "if cost[to] > total - fee:",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total - fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if cost[to] > total + fee:",
      "mutated_line": "if cost[to] > total * fee:",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total * fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "cost[to] = total + fee",
      "mutated_line": "cost[to] = total - fee",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total - fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "cost[to] = total + fee",
      "mutated_line": "cost[to] = total * fee",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total * fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "edges = [[] for _ in range(n * (c + 1))]",
      "mutated_line": "edges = [[] for _ in range(n * (c - 1))]",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c - 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "edges = [[] for _ in range(n * (c + 1))]",
      "mutated_line": "edges = [[] for _ in range(n * (c * 1))]",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c * 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "edges[a + i * n].append((b + i * n, f))",
      "mutated_line": "edges[a + i * n].append((b - i * n, f))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b - i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "edges[a + i * n].append((b + i * n, f))",
      "mutated_line": "edges[a + i * n].append((b * (i * n), f))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b * (i * n), f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "edges[b + i * n].append((a + i * n, f))",
      "mutated_line": "edges[b + i * n].append((a - i * n, f))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a - i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "edges[b + i * n].append((a + i * n, f))",
      "mutated_line": "edges[b + i * n].append((a * (i * n), f))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a * (i * n), f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "edges[d + i * n].append((d + (i + 1) * n, 0))",
      "mutated_line": "edges[d - i * n].append((d + (i + 1) * n, 0))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d - i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "edges[d + i * n].append((d + (i + 1) * n, 0))",
      "mutated_line": "edges[d * (i * n)].append((d + (i + 1) * n, 0))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d * (i * n)].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "edges[d + i * n].append((d + (i + 1) * n, 0))",
      "mutated_line": "edges[d + i * n].append((d + (i + 1) / n, 0))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) / n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "edges[d + i * n].append((d + (i + 1) * n, 0))",
      "mutated_line": "edges[d + i * n].append((d + (i + 1 + n), 0))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1 + n), 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "edges[d + i * n].append((d + (i + 1) * n, 0))",
      "mutated_line": "edges[d + i * n].append((d + (i + 1) ** n, 0))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) ** n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edges = [[] for _ in range(n * (c + 1))]",
      "mutated_line": "edges = [[] for _ in range(n * (c + 2))]",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 2))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edges = [[] for _ in range(n * (c + 1))]",
      "mutated_line": "edges = [[] for _ in range(n * (c + 0))]",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 0))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edges = [[] for _ in range(n * (c + 1))]",
      "mutated_line": "edges = [[] for _ in range(n * (c + 0))]",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 0))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edges = [[] for _ in range(n * (c + 1))]",
      "mutated_line": "edges = [[] for _ in range(n * (c + -1))]",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + -1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "edges[a + i * n].append((b + i * n, f))",
      "mutated_line": "edges[a - i * n].append((b + i * n, f))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a - i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "edges[a + i * n].append((b + i * n, f))",
      "mutated_line": "edges[a * (i * n)].append((b + i * n, f))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a * (i * n)].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "edges[a + i * n].append((b + i * n, f))",
      "mutated_line": "edges[a + i * n].append((b + i / n, f))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i / n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "edges[a + i * n].append((b + i * n, f))",
      "mutated_line": "edges[a + i * n].append((b + (i + n), f))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + (i + n), f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "edges[a + i * n].append((b + i * n, f))",
      "mutated_line": "edges[a + i * n].append((b + i ** n, f))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i ** n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "edges[b + i * n].append((a + i * n, f))",
      "mutated_line": "edges[b - i * n].append((a + i * n, f))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b - i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "edges[b + i * n].append((a + i * n, f))",
      "mutated_line": "edges[b * (i * n)].append((a + i * n, f))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b * (i * n)].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "edges[b + i * n].append((a + i * n, f))",
      "mutated_line": "edges[b + i * n].append((a + i / n, f))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i / n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "edges[b + i * n].append((a + i * n, f))",
      "mutated_line": "edges[b + i * n].append((a + (i + n), f))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + (i + n), f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "edges[b + i * n].append((a + i * n, f))",
      "mutated_line": "edges[b + i * n].append((a + i ** n, f))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i ** n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "edges[a + i * n].append((b + (i + 1) * n, f // 2))",
      "mutated_line": "edges[a + i * n].append((b - (i + 1) * n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b - (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "edges[a + i * n].append((b + (i + 1) * n, f // 2))",
      "mutated_line": "edges[a + i * n].append((b * ((i + 1) * n), f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b * ((i + 1) * n), f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "edges[a + i * n].append((b + (i + 1) * n, f // 2))",
      "mutated_line": "edges[a + i * n].append((b + (i + 1) * n, f / 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f / 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "edges[a + i * n].append((b + (i + 1) * n, f // 2))",
      "mutated_line": "edges[a + i * n].append((b + (i + 1) * n, f * 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f * 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "edges[b + i * n].append((a + (i + 1) * n, f // 2))",
      "mutated_line": "edges[b + i * n].append((a - (i + 1) * n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a - (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "edges[b + i * n].append((a + (i + 1) * n, f // 2))",
      "mutated_line": "edges[b + i * n].append((a * ((i + 1) * n), f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a * ((i + 1) * n), f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "edges[b + i * n].append((a + (i + 1) * n, f // 2))",
      "mutated_line": "edges[b + i * n].append((a + (i + 1) * n, f / 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f / 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "edges[b + i * n].append((a + (i + 1) * n, f // 2))",
      "mutated_line": "edges[b + i * n].append((a + (i + 1) * n, f * 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f * 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "edges[d + i * n].append((d + (i + 1) * n, 0))",
      "mutated_line": "edges[d + i / n].append((d + (i + 1) * n, 0))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i / n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "edges[d + i * n].append((d + (i + 1) * n, 0))",
      "mutated_line": "edges[d + (i + n)].append((d + (i + 1) * n, 0))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + (i + n)].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "edges[d + i * n].append((d + (i + 1) * n, 0))",
      "mutated_line": "edges[d + i ** n].append((d + (i + 1) * n, 0))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i ** n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "edges[d + i * n].append((d + (i + 1) * n, 0))",
      "mutated_line": "edges[d + i * n].append((d + (i - 1) * n, 0))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i - 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "edges[d + i * n].append((d + (i + 1) * n, 0))",
      "mutated_line": "edges[d + i * n].append((d + i * 1 * n, 0))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + i * 1 * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "heappush(que, (total + fee, to))",
      "mutated_line": "heappush(que, (total - fee, to))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total - fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "heappush(que, (total + fee, to))",
      "mutated_line": "heappush(que, (total * fee, to))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total * fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "edges[a + i * n].append((b + i * n, f))",
      "mutated_line": "edges[a + i / n].append((b + i * n, f))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i / n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "edges[a + i * n].append((b + i * n, f))",
      "mutated_line": "edges[a + (i + n)].append((b + i * n, f))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + (i + n)].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "edges[a + i * n].append((b + i * n, f))",
      "mutated_line": "edges[a + i ** n].append((b + i * n, f))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i ** n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "edges[b + i * n].append((a + i * n, f))",
      "mutated_line": "edges[b + i / n].append((a + i * n, f))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i / n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "edges[b + i * n].append((a + i * n, f))",
      "mutated_line": "edges[b + (i + n)].append((a + i * n, f))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + (i + n)].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "edges[b + i * n].append((a + i * n, f))",
      "mutated_line": "edges[b + i ** n].append((a + i * n, f))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i ** n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "edges[a + i * n].append((b + (i + 1) * n, f // 2))",
      "mutated_line": "edges[a - i * n].append((b + (i + 1) * n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a - i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "edges[a + i * n].append((b + (i + 1) * n, f // 2))",
      "mutated_line": "edges[a * (i * n)].append((b + (i + 1) * n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a * (i * n)].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "edges[a + i * n].append((b + (i + 1) * n, f // 2))",
      "mutated_line": "edges[a + i * n].append((b + (i + 1) / n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) / n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "edges[a + i * n].append((b + (i + 1) * n, f // 2))",
      "mutated_line": "edges[a + i * n].append((b + (i + 1 + n), f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1 + n), f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "edges[a + i * n].append((b + (i + 1) * n, f // 2))",
      "mutated_line": "edges[a + i * n].append((b + (i + 1) ** n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) ** n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "edges[a + i * n].append((b + (i + 1) * n, f // 2))",
      "mutated_line": "edges[a + i * n].append((b + (i + 1) * n, f // 3))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 3))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "edges[a + i * n].append((b + (i + 1) * n, f // 2))",
      "mutated_line": "edges[a + i * n].append((b + (i + 1) * n, f // 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 1))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "edges[a + i * n].append((b + (i + 1) * n, f // 2))",
      "mutated_line": "edges[a + i * n].append((b + (i + 1) * n, f // 0))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 0))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "edges[a + i * n].append((b + (i + 1) * n, f // 2))",
      "mutated_line": "edges[a + i * n].append((b + (i + 1) * n, f // 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 1))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "edges[a + i * n].append((b + (i + 1) * n, f // 2))",
      "mutated_line": "edges[a + i * n].append((b + (i + 1) * n, f // -2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // -2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "edges[b + i * n].append((a + (i + 1) * n, f // 2))",
      "mutated_line": "edges[b - i * n].append((a + (i + 1) * n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b - i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "edges[b + i * n].append((a + (i + 1) * n, f // 2))",
      "mutated_line": "edges[b * (i * n)].append((a + (i + 1) * n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b * (i * n)].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "edges[b + i * n].append((a + (i + 1) * n, f // 2))",
      "mutated_line": "edges[b + i * n].append((a + (i + 1) / n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) / n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "edges[b + i * n].append((a + (i + 1) * n, f // 2))",
      "mutated_line": "edges[b + i * n].append((a + (i + 1 + n), f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1 + n), f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "edges[b + i * n].append((a + (i + 1) * n, f // 2))",
      "mutated_line": "edges[b + i * n].append((a + (i + 1) ** n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) ** n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "edges[b + i * n].append((a + (i + 1) * n, f // 2))",
      "mutated_line": "edges[b + i * n].append((a + (i + 1) * n, f // 3))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 3))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "edges[b + i * n].append((a + (i + 1) * n, f // 2))",
      "mutated_line": "edges[b + i * n].append((a + (i + 1) * n, f // 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 1))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "edges[b + i * n].append((a + (i + 1) * n, f // 2))",
      "mutated_line": "edges[b + i * n].append((a + (i + 1) * n, f // 0))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 0))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "edges[b + i * n].append((a + (i + 1) * n, f // 2))",
      "mutated_line": "edges[b + i * n].append((a + (i + 1) * n, f // 1))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 1))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "edges[b + i * n].append((a + (i + 1) * n, f // 2))",
      "mutated_line": "edges[b + i * n].append((a + (i + 1) * n, f // -2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // -2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "edges[d + i * n].append((d + (i + 1) * n, 0))",
      "mutated_line": "edges[d + i * n].append((d + (i + 2) * n, 0))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 2) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "edges[d + i * n].append((d + (i + 1) * n, 0))",
      "mutated_line": "edges[d + i * n].append((d + (i + 0) * n, 0))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 0) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "edges[d + i * n].append((d + (i + 1) * n, 0))",
      "mutated_line": "edges[d + i * n].append((d + (i + 0) * n, 0))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 0) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "edges[d + i * n].append((d + (i + 1) * n, 0))",
      "mutated_line": "edges[d + i * n].append((d + (i + -1) * n, 0))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + -1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "edges[a + i * n].append((b + (i + 1) * n, f // 2))",
      "mutated_line": "edges[a + i / n].append((b + (i + 1) * n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i / n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "edges[a + i * n].append((b + (i + 1) * n, f // 2))",
      "mutated_line": "edges[a + (i + n)].append((b + (i + 1) * n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + (i + n)].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "edges[a + i * n].append((b + (i + 1) * n, f // 2))",
      "mutated_line": "edges[a + i ** n].append((b + (i + 1) * n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i ** n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "edges[a + i * n].append((b + (i + 1) * n, f // 2))",
      "mutated_line": "edges[a + i * n].append((b + (i - 1) * n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i - 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "edges[a + i * n].append((b + (i + 1) * n, f // 2))",
      "mutated_line": "edges[a + i * n].append((b + i * 1 * n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + i * 1 * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "edges[b + i * n].append((a + (i + 1) * n, f // 2))",
      "mutated_line": "edges[b + i / n].append((a + (i + 1) * n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i / n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "edges[b + i * n].append((a + (i + 1) * n, f // 2))",
      "mutated_line": "edges[b + (i + n)].append((a + (i + 1) * n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + (i + n)].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "edges[b + i * n].append((a + (i + 1) * n, f // 2))",
      "mutated_line": "edges[b + i ** n].append((a + (i + 1) * n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i ** n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "edges[b + i * n].append((a + (i + 1) * n, f // 2))",
      "mutated_line": "edges[b + i * n].append((a + (i - 1) * n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i - 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "edges[b + i * n].append((a + (i + 1) * n, f // 2))",
      "mutated_line": "edges[b + i * n].append((a + i * 1 * n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + i * 1 * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "edges[a + i * n].append((b + (i + 1) * n, f // 2))",
      "mutated_line": "edges[a + i * n].append((b + (i + 2) * n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 2) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "edges[a + i * n].append((b + (i + 1) * n, f // 2))",
      "mutated_line": "edges[a + i * n].append((b + (i + 0) * n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 0) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "edges[a + i * n].append((b + (i + 1) * n, f // 2))",
      "mutated_line": "edges[a + i * n].append((b + (i + 0) * n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 0) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "edges[a + i * n].append((b + (i + 1) * n, f // 2))",
      "mutated_line": "edges[a + i * n].append((b + (i + -1) * n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + -1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "edges[b + i * n].append((a + (i + 1) * n, f // 2))",
      "mutated_line": "edges[b + i * n].append((a + (i + 2) * n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 2) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "edges[b + i * n].append((a + (i + 1) * n, f // 2))",
      "mutated_line": "edges[b + i * n].append((a + (i + 0) * n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 0) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "edges[b + i * n].append((a + (i + 1) * n, f // 2))",
      "mutated_line": "edges[b + i * n].append((a + (i + 0) * n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + 0) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "edges[b + i * n].append((a + (i + 1) * n, f // 2))",
      "mutated_line": "edges[b + i * n].append((a + (i + -1) * n, f // 2))",
      "code": "from heapq import heappush, heappop\n\ndef find_cheapest_transportation_cost(c, n, m, s, d, routes):\n    INF = 10 ** 20\n    s -= 1\n    d -= 1\n    edges = [[] for _ in range(n * (c + 1))]\n    for (a, b, f) in routes:\n        a -= 1\n        b -= 1\n        for i in range(c + 1):\n            edges[a + i * n].append((b + i * n, f))\n            edges[b + i * n].append((a + i * n, f))\n            if i != c:\n                edges[a + i * n].append((b + (i + 1) * n, f // 2))\n                edges[b + i * n].append((a + (i + -1) * n, f // 2))\n    for i in range(c):\n        edges[d + i * n].append((d + (i + 1) * n, 0))\n    cost = [INF] * (n * (c + 1))\n    que = []\n    heappush(que, (0, s))\n    while que:\n        (total, point) = heappop(que)\n        for (to, fee) in edges[point]:\n            if cost[to] > total + fee:\n                cost[to] = total + fee\n                heappush(que, (total + fee, to))\n    return cost[d + n * c]"
    }
  ]
}