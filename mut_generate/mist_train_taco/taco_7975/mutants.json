{
  "task_id": "taco_7975",
  "entry_point": "fraction_comp",
  "mutant_count": 186,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "Vec = namedtuple('Vec', 'x y index')",
      "mutated_line": "Vec = namedtuple('', 'x y index')",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "Vec = namedtuple('Vec', 'x y index')",
      "mutated_line": "Vec = namedtuple('Vec', '')",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', '')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "Fraction = namedtuple('Fraction', 'num denom')",
      "mutated_line": "Fraction = namedtuple('', 'num denom')",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "Fraction = namedtuple('Fraction', 'num denom')",
      "mutated_line": "Fraction = namedtuple('Fraction', '')",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', '')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return a.num * b.denom > b.num * a.denom",
      "mutated_line": "return a.num * b.denom >= b.num * a.denom",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom >= b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return a.num * b.denom > b.num * a.denom",
      "mutated_line": "return a.num * b.denom <= b.num * a.denom",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom <= b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return a.num * b.denom > b.num * a.denom",
      "mutated_line": "return a.num * b.denom != b.num * a.denom",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom != b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "result = v.x / sqrt(v.x * v.x + v.y * v.y)",
      "mutated_line": "result = v.x * sqrt(v.x * v.x + v.y * v.y)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x * sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "result = v.x / sqrt(v.x * v.x + v.y * v.y)",
      "mutated_line": "result = v.x // sqrt(v.x * v.x + v.y * v.y)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x // sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if v.y < 0:",
      "mutated_line": "if v.y <= 0:",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y <= 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if v.y < 0:",
      "mutated_line": "if v.y >= 0:",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y >= 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if v.y < 0:",
      "mutated_line": "if v.y != 0:",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y != 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 * x2 + y1 * y2) * (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) * (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 * x2 + y1 * y2) // (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) // (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return a.num * b.denom > b.num * a.denom",
      "mutated_line": "return a.num / b.denom > b.num * a.denom",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num / b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return a.num * b.denom > b.num * a.denom",
      "mutated_line": "return a.num + b.denom > b.num * a.denom",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num + b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return a.num * b.denom > b.num * a.denom",
      "mutated_line": "return a.num ** b.denom > b.num * a.denom",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num ** b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return a.num * b.denom > b.num * a.denom",
      "mutated_line": "return a.num * b.denom > b.num / a.denom",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num / a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return a.num * b.denom > b.num * a.denom",
      "mutated_line": "return a.num * b.denom > b.num + a.denom",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num + a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return a.num * b.denom > b.num * a.denom",
      "mutated_line": "return a.num * b.denom > b.num ** a.denom",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num ** a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if v.y < 0:",
      "mutated_line": "if v.y < 1:",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 1:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if v.y < 0:",
      "mutated_line": "if v.y < -1:",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < -1:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if v.y < 0:",
      "mutated_line": "if v.y < 1:",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 1:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "result = -2 - result",
      "mutated_line": "result = -2 + result",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 + result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "result = -2 - result",
      "mutated_line": "result = -2 * result",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 * result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 * x2 - y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 - y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = x1 * x2 * (y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = x1 * x2 * (y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) / sqrt(x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) / sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) + sqrt(x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) + sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 * x2 + y1 * y2) / sqrt(x1 * x1 + y1 * y1) ** sqrt(x2 * x2 + y2 * y2)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / sqrt(x1 * x1 + y1 * y1) ** sqrt(x2 * x2 + y2 * y2)\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 1",
      "mutated_line": "sign = -1 if x1 * x2 + y1 * y2 <= 0 else 1",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 <= 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 1",
      "mutated_line": "sign = -1 if x1 * x2 + y1 * y2 >= 0 else 1",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 >= 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 1",
      "mutated_line": "sign = -1 if x1 * x2 + y1 * y2 != 0 else 1",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 != 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 1",
      "mutated_line": "sign = +1 if x1 * x2 + y1 * y2 < 0 else 1",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = +1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 1",
      "mutated_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 2",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 2\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 1",
      "mutated_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 0",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 0\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 1",
      "mutated_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 0",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 0\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 1",
      "mutated_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else -1",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else -1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign / (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign / (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign + (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign + (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign ** (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign ** (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) / (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) / (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, x1 * x1 + y1 * y1 + (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, x1 * x1 + y1 * y1 + (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) ** (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) ** (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "ans = (points[0].index + 1, points[n - 1].index + 1)",
      "mutated_line": "ans = (points[0].index - 1, points[n - 1].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index - 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "ans = (points[0].index + 1, points[n - 1].index + 1)",
      "mutated_line": "ans = (points[0].index * 1, points[n - 1].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index * 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "ans = (points[0].index + 1, points[n - 1].index + 1)",
      "mutated_line": "ans = (points[0].index + 1, points[n - 1].index - 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index - 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "ans = (points[0].index + 1, points[n - 1].index + 1)",
      "mutated_line": "ans = (points[0].index + 1, points[n - 1].index * 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index * 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n + 1):",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n + 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n * 1):",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n * 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "result = v.x / sqrt(v.x * v.x + v.y * v.y)",
      "mutated_line": "result = v.x / sqrt(v.x * v.x - v.y * v.y)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x - v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "result = v.x / sqrt(v.x * v.x + v.y * v.y)",
      "mutated_line": "result = v.x / sqrt(v.x * v.x * (v.y * v.y))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x * (v.y * v.y))\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "result = -2 - result",
      "mutated_line": "result = +2 - result",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = +2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 / x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 / x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 + x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 + x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 ** x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 ** x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 * x2 + y1 / y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 / y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 * x2 + (y1 + y2)) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + (y1 + y2)) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 * x2 + y1 ** y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 ** y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 1",
      "mutated_line": "sign = -1 if x1 * x2 - y1 * y2 < 0 else 1",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 - y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 1",
      "mutated_line": "sign = -1 if x1 * x2 * (y1 * y2) < 0 else 1",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 * (y1 * y2) < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 1",
      "mutated_line": "sign = -1 if x1 * x2 + y1 * y2 < 1 else 1",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 1 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 1",
      "mutated_line": "sign = -1 if x1 * x2 + y1 * y2 < -1 else 1",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < -1 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 1",
      "mutated_line": "sign = -1 if x1 * x2 + y1 * y2 < 1 else 1",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 1 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 1",
      "mutated_line": "sign = -2 if x1 * x2 + y1 * y2 < 0 else 1",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -2 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 1",
      "mutated_line": "sign = -0 if x1 * x2 + y1 * y2 < 0 else 1",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -0 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 1",
      "mutated_line": "sign = -0 if x1 * x2 + y1 * y2 < 0 else 1",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -0 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 1",
      "mutated_line": "sign = --1 if x1 * x2 + y1 * y2 < 0 else 1",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = --1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * ((x1 * x2 + y1 * y2) * 2), (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * ((x1 * x2 + y1 * y2) * 2), (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 * y2 + 2), (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2 + 2), (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 - y1 * y1) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 - y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, x1 * x1 * (y1 * y1) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, x1 * x1 * (y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 - y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 - y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 * (y2 * y2)))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 * (y2 * y2)))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans = (points[0].index + 1, points[n - 1].index + 1)",
      "mutated_line": "ans = (points[0].index + 2, points[n - 1].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 2, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans = (points[0].index + 1, points[n - 1].index + 1)",
      "mutated_line": "ans = (points[0].index + 0, points[n - 1].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 0, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans = (points[0].index + 1, points[n - 1].index + 1)",
      "mutated_line": "ans = (points[0].index + 0, points[n - 1].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 0, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans = (points[0].index + 1, points[n - 1].index + 1)",
      "mutated_line": "ans = (points[0].index + -1, points[n - 1].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + -1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans = (points[0].index + 1, points[n - 1].index + 1)",
      "mutated_line": "ans = (points[0].index + 1, points[n - 1].index + 2)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 2)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans = (points[0].index + 1, points[n - 1].index + 1)",
      "mutated_line": "ans = (points[0].index + 1, points[n - 1].index + 0)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 0)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans = (points[0].index + 1, points[n - 1].index + 1)",
      "mutated_line": "ans = (points[0].index + 1, points[n - 1].index + 0)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 0)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans = (points[0].index + 1, points[n - 1].index + 1)",
      "mutated_line": "ans = (points[0].index + 1, points[n - 1].index + -1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + -1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "minAngleCos = angle(points[0], points[n - 1])",
      "mutated_line": "minAngleCos = angle(points[1], points[n - 1])",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[1], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "minAngleCos = angle(points[0], points[n - 1])",
      "mutated_line": "minAngleCos = angle(points[-1], points[n - 1])",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[-1], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "minAngleCos = angle(points[0], points[n - 1])",
      "mutated_line": "minAngleCos = angle(points[1], points[n - 1])",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[1], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "minAngleCos = angle(points[0], points[n - 1])",
      "mutated_line": "minAngleCos = angle(points[0], points[n + 1])",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n + 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "minAngleCos = angle(points[0], points[n - 1])",
      "mutated_line": "minAngleCos = angle(points[0], points[n * 1])",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n * 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 2):",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 2):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 0):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 0):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - -1):",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - -1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "result = v.x / sqrt(v.x * v.x + v.y * v.y)",
      "mutated_line": "result = v.x / sqrt(v.x / v.x + v.y * v.y)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x / v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "result = v.x / sqrt(v.x * v.x + v.y * v.y)",
      "mutated_line": "result = v.x / sqrt(v.x + v.x + v.y * v.y)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x + v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "result = v.x / sqrt(v.x * v.x + v.y * v.y)",
      "mutated_line": "result = v.x / sqrt(v.x ** v.x + v.y * v.y)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x ** v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "result = v.x / sqrt(v.x * v.x + v.y * v.y)",
      "mutated_line": "result = v.x / sqrt(v.x * v.x + v.y / v.y)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y / v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "result = v.x / sqrt(v.x * v.x + v.y * v.y)",
      "mutated_line": "result = v.x / sqrt(v.x * v.x + (v.y + v.y))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + (v.y + v.y))\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "result = v.x / sqrt(v.x * v.x + v.y * v.y)",
      "mutated_line": "result = v.x / sqrt(v.x * v.x + v.y ** v.y)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y ** v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "result = -2 - result",
      "mutated_line": "result = -3 - result",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -3 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "result = -2 - result",
      "mutated_line": "result = -1 - result",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -1 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "result = -2 - result",
      "mutated_line": "result = -0 - result",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -0 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "result = -2 - result",
      "mutated_line": "result = -1 - result",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -1 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "result = -2 - result",
      "mutated_line": "result = --2 - result",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = --2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 - y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 - y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 * (y1 * y1)) * sqrt(x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 * (y1 * y1)) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 - y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 - y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 * (y2 * y2)))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 * (y2 * y2)))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 1",
      "mutated_line": "sign = -1 if x1 / x2 + y1 * y2 < 0 else 1",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 / x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 1",
      "mutated_line": "sign = -1 if x1 + x2 + y1 * y2 < 0 else 1",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 + x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 1",
      "mutated_line": "sign = -1 if x1 ** x2 + y1 * y2 < 0 else 1",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 ** x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 1",
      "mutated_line": "sign = -1 if x1 * x2 + y1 / y2 < 0 else 1",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 / y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 1",
      "mutated_line": "sign = -1 if x1 * x2 + (y1 + y2) < 0 else 1",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + (y1 + y2) < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "sign = -1 if x1 * x2 + y1 * y2 < 0 else 1",
      "mutated_line": "sign = -1 if x1 * x2 + y1 ** y2 < 0 else 1",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 ** y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 - y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 - y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 * (y1 * y2)) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 * (y1 * y2)) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 3, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 3, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 1, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 1, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 0, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 0, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 1, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 1, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** -2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** -2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 / x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 / x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 + x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 + x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 ** x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 ** x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 / y1) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 / y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + (y1 + y1)) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + (y1 + y1)) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 ** y1) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 ** y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 / x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 / x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 + x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 + x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 ** x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 ** x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 / y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 / y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + (y2 + y2)))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + (y2 + y2)))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 ** y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 ** y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "minAngleCos = angle(points[0], points[n - 1])",
      "mutated_line": "minAngleCos = angle(points[0], points[n - 2])",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 2])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "minAngleCos = angle(points[0], points[n - 1])",
      "mutated_line": "minAngleCos = angle(points[0], points[n - 0])",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 0])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "minAngleCos = angle(points[0], points[n - 1])",
      "mutated_line": "minAngleCos = angle(points[0], points[n - 0])",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 0])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "minAngleCos = angle(points[0], points[n - 1])",
      "mutated_line": "minAngleCos = angle(points[0], points[n - -1])",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - -1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "currAngleCos = angle(points[i], points[i + 1])",
      "mutated_line": "currAngleCos = angle(points[i], points[i - 1])",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i - 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "currAngleCos = angle(points[i], points[i + 1])",
      "mutated_line": "currAngleCos = angle(points[i], points[i * 1])",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i * 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = (points[i].index + 1, points[i + 1].index + 1)",
      "mutated_line": "ans = (points[i].index - 1, points[i + 1].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index - 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = (points[i].index + 1, points[i + 1].index + 1)",
      "mutated_line": "ans = (points[i].index * 1, points[i + 1].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index * 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = (points[i].index + 1, points[i + 1].index + 1)",
      "mutated_line": "ans = (points[i].index + 1, points[i + 1].index - 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index - 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = (points[i].index + 1, points[i + 1].index + 1)",
      "mutated_line": "ans = (points[i].index + 1, points[i + 1].index * 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index * 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 / x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 / x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 + x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 + x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 ** x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 ** x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 / y1) * sqrt(x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 / y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + (y1 + y1)) * sqrt(x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + (y1 + y1)) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 ** y1) * sqrt(x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 ** y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 / x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 / x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 + x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 + x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 ** x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 ** x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 / y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 / y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + (y2 + y2)))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + (y2 + y2)))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))",
      "mutated_line": "result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 ** y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 ** y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 / x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 / x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 + x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 + x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 ** x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 ** x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 / y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 / y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + (y1 + y2)) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + (y1 + y2)) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "mutated_line": "return Fraction(sign * (x1 * x2 + y1 ** y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 ** y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans = (points[0].index + 1, points[n - 1].index + 1)",
      "mutated_line": "ans = (points[1].index + 1, points[n - 1].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[1].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans = (points[0].index + 1, points[n - 1].index + 1)",
      "mutated_line": "ans = (points[-1].index + 1, points[n - 1].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[-1].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans = (points[0].index + 1, points[n - 1].index + 1)",
      "mutated_line": "ans = (points[1].index + 1, points[n - 1].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[1].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "ans = (points[0].index + 1, points[n - 1].index + 1)",
      "mutated_line": "ans = (points[0].index + 1, points[n + 1].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n + 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "ans = (points[0].index + 1, points[n - 1].index + 1)",
      "mutated_line": "ans = (points[0].index + 1, points[n * 1].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n * 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "currAngleCos = angle(points[i], points[i + 1])",
      "mutated_line": "currAngleCos = angle(points[i], points[i + 2])",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 2])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "currAngleCos = angle(points[i], points[i + 1])",
      "mutated_line": "currAngleCos = angle(points[i], points[i + 0])",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 0])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "currAngleCos = angle(points[i], points[i + 1])",
      "mutated_line": "currAngleCos = angle(points[i], points[i + 0])",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 0])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "currAngleCos = angle(points[i], points[i + 1])",
      "mutated_line": "currAngleCos = angle(points[i], points[i + -1])",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + -1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = (points[i].index + 1, points[i + 1].index + 1)",
      "mutated_line": "ans = (points[i].index + 2, points[i + 1].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 2, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = (points[i].index + 1, points[i + 1].index + 1)",
      "mutated_line": "ans = (points[i].index + 0, points[i + 1].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 0, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = (points[i].index + 1, points[i + 1].index + 1)",
      "mutated_line": "ans = (points[i].index + 0, points[i + 1].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 0, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = (points[i].index + 1, points[i + 1].index + 1)",
      "mutated_line": "ans = (points[i].index + -1, points[i + 1].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + -1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = (points[i].index + 1, points[i + 1].index + 1)",
      "mutated_line": "ans = (points[i].index + 1, points[i + 1].index + 2)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 2)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = (points[i].index + 1, points[i + 1].index + 1)",
      "mutated_line": "ans = (points[i].index + 1, points[i + 1].index + 0)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = (points[i].index + 1, points[i + 1].index + 1)",
      "mutated_line": "ans = (points[i].index + 1, points[i + 1].index + 0)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 0)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = (points[i].index + 1, points[i + 1].index + 1)",
      "mutated_line": "ans = (points[i].index + 1, points[i + 1].index + -1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + -1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans = (points[0].index + 1, points[n - 1].index + 1)",
      "mutated_line": "ans = (points[0].index + 1, points[n - 2].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 2].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans = (points[0].index + 1, points[n - 1].index + 1)",
      "mutated_line": "ans = (points[0].index + 1, points[n - 0].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 0].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans = (points[0].index + 1, points[n - 1].index + 1)",
      "mutated_line": "ans = (points[0].index + 1, points[n - 0].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 0].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans = (points[0].index + 1, points[n - 1].index + 1)",
      "mutated_line": "ans = (points[0].index + 1, points[n - -1].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - -1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = (points[i].index + 1, points[i + 1].index + 1)",
      "mutated_line": "ans = (points[i].index + 1, points[i - 1].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i - 1].index + 1)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = (points[i].index + 1, points[i + 1].index + 1)",
      "mutated_line": "ans = (points[i].index + 1, points[i * 1].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i * 1].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = (points[i].index + 1, points[i + 1].index + 1)",
      "mutated_line": "ans = (points[i].index + 1, points[i + 2].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 2].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = (points[i].index + 1, points[i + 1].index + 1)",
      "mutated_line": "ans = (points[i].index + 1, points[i + 0].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 0].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = (points[i].index + 1, points[i + 1].index + 1)",
      "mutated_line": "ans = (points[i].index + 1, points[i + 0].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + 0].index + 1)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = (points[i].index + 1, points[i + 1].index + 1)",
      "mutated_line": "ans = (points[i].index + 1, points[i + -1].index + 1)",
      "code": "from collections import namedtuple\nfrom math import sqrt\nfrom functools import cmp_to_key\nVec = namedtuple('Vec', 'x y index')\nFraction = namedtuple('Fraction', 'num denom')\n\ndef fraction_comp(a, b):\n    return a.num * b.denom > b.num * a.denom\n\ndef angle_comp(v):\n    result = v.x / sqrt(v.x * v.x + v.y * v.y)\n    if v.y < 0:\n        result = -2 - result\n    return result\n\ndef angle(v1, v2):\n    (x1, y1) = (v1.x, v1.y)\n    (x2, y2) = (v2.x, v2.y)\n    result = (x1 * x2 + y1 * y2) / (sqrt(x1 * x1 + y1 * y1) * sqrt(x2 * x2 + y2 * y2))\n    sign = -1 if x1 * x2 + y1 * y2 < 0 else 1\n    return Fraction(sign * (x1 * x2 + y1 * y2) ** 2, (x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n\ndef find_min_angle_pair(vectors):\n    n = len(vectors)\n    points = [Vec(x, y, i) for (i, (x, y)) in enumerate(vectors)]\n    points.sort(key=angle_comp)\n    points.reverse()\n    ans = (points[0].index + 1, points[n - 1].index + 1)\n    minAngleCos = angle(points[0], points[n - 1])\n    for i in range(n - 1):\n        currAngleCos = angle(points[i], points[i + 1])\n        if fraction_comp(currAngleCos, minAngleCos):\n            minAngleCos = currAngleCos\n            ans = (points[i].index + 1, points[i + -1].index + 1)\n    return ans"
    }
  ]
}