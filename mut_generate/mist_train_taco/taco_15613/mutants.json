{
  "task_id": "taco_15613",
  "entry_point": "find_city_with_smallest_reach",
  "mutant_count": 33,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "result_city = -1",
      "mutated_line": "result_city = +1",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = +1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "min_reachable_count = float('inf')",
      "mutated_line": "min_reachable_count = float('')",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "result_city = -1",
      "mutated_line": "result_city = -2",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -2\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "result_city = -1",
      "mutated_line": "result_city = -0",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -0\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "result_city = -1",
      "mutated_line": "result_city = -0",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -0\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "result_city = -1",
      "mutated_line": "result_city = --1",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = --1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dist = [distance_threshold + 1] * n",
      "mutated_line": "dist = [distance_threshold + 1] / n",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] / n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dist = [distance_threshold + 1] * n",
      "mutated_line": "dist = [distance_threshold + 1] + n",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] + n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dist = [distance_threshold + 1] * n",
      "mutated_line": "dist = [distance_threshold + 1] ** n",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] ** n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if reachable_count <= min_reachable_count:",
      "mutated_line": "if reachable_count < min_reachable_count:",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count < min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if reachable_count <= min_reachable_count:",
      "mutated_line": "if reachable_count > min_reachable_count:",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count > min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if reachable_count <= min_reachable_count:",
      "mutated_line": "if reachable_count == min_reachable_count:",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count == min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if d > dist[u]:",
      "mutated_line": "if d >= dist[u]:",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d >= dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if d > dist[u]:",
      "mutated_line": "if d <= dist[u]:",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d <= dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if d > dist[u]:",
      "mutated_line": "if d != dist[u]:",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d != dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dist = [distance_threshold + 1] * n",
      "mutated_line": "dist = [distance_threshold - 1] * n",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold - 1] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dist = [distance_threshold + 1] * n",
      "mutated_line": "dist = [distance_threshold * 1] * n",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold * 1] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "hp = [(0, x)]",
      "mutated_line": "hp = [(1, x)]",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] * n\n        hp = [(1, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "hp = [(0, x)]",
      "mutated_line": "hp = [(-1, x)]",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] * n\n        hp = [(-1, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "hp = [(0, x)]",
      "mutated_line": "hp = [(1, x)]",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] * n\n        hp = [(1, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if d + w < dist[v]:",
      "mutated_line": "if d + w <= dist[v]:",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w <= dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if d + w < dist[v]:",
      "mutated_line": "if d + w >= dist[v]:",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w >= dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if d + w < dist[v]:",
      "mutated_line": "if d + w != dist[v]:",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w != dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dist = [distance_threshold + 1] * n",
      "mutated_line": "dist = [distance_threshold + 2] * n",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 2] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dist = [distance_threshold + 1] * n",
      "mutated_line": "dist = [distance_threshold + 0] * n",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 0] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dist = [distance_threshold + 1] * n",
      "mutated_line": "dist = [distance_threshold + 0] * n",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 0] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dist = [distance_threshold + 1] * n",
      "mutated_line": "dist = [distance_threshold + -1] * n",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + -1] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if d + w < dist[v]:",
      "mutated_line": "if d - w < dist[v]:",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d - w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if d + w < dist[v]:",
      "mutated_line": "if d * w < dist[v]:",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d * w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dist[v] = d + w",
      "mutated_line": "dist[v] = d - w",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d - w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dist[v] = d + w",
      "mutated_line": "dist[v] = d * w",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d * w\n                    heapq.heappush(hp, (d + w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "heapq.heappush(hp, (d + w, v))",
      "mutated_line": "heapq.heappush(hp, (d - w, v))",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d - w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "heapq.heappush(hp, (d + w, v))",
      "mutated_line": "heapq.heappush(hp, (d * w, v))",
      "code": "import heapq\n\ndef find_city_with_smallest_reach(n, edges, distance_threshold):\n    adj = [[] for _ in range(n)]\n    for (u, v, w) in edges:\n        adj[u].append((w, v))\n        adj[v].append((w, u))\n    min_reachable_count = float('inf')\n    result_city = -1\n    for x in range(n):\n        vis = {x}\n        dist = [distance_threshold + 1] * n\n        hp = [(0, x)]\n        while hp:\n            (d, u) = heapq.heappop(hp)\n            if d > dist[u]:\n                continue\n            for (w, v) in adj[u]:\n                if d + w < dist[v]:\n                    vis.add(v)\n                    dist[v] = d + w\n                    heapq.heappush(hp, (d * w, v))\n        reachable_count = len(vis)\n        if reachable_count <= min_reachable_count:\n            min_reachable_count = reachable_count\n            result_city = x\n    return result_city"
    }
  ]
}