{
  "task_id": "taco_830",
  "entry_point": "find_max_mod",
  "mutant_count": 25,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if l <= math.ceil(r / 2):",
      "mutated_line": "if l < math.ceil(r / 2):",
      "code": "import math\n\ndef find_max_mod(l, r):\n    if l < math.ceil(r / 2):\n        return math.ceil(r / 2) - 1\n    else:\n        return r % l"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if l <= math.ceil(r / 2):",
      "mutated_line": "if l > math.ceil(r / 2):",
      "code": "import math\n\ndef find_max_mod(l, r):\n    if l > math.ceil(r / 2):\n        return math.ceil(r / 2) - 1\n    else:\n        return r % l"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if l <= math.ceil(r / 2):",
      "mutated_line": "if l == math.ceil(r / 2):",
      "code": "import math\n\ndef find_max_mod(l, r):\n    if l == math.ceil(r / 2):\n        return math.ceil(r / 2) - 1\n    else:\n        return r % l"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.ceil(r / 2) - 1",
      "mutated_line": "return math.ceil(r / 2) + 1",
      "code": "import math\n\ndef find_max_mod(l, r):\n    if l <= math.ceil(r / 2):\n        return math.ceil(r / 2) + 1\n    else:\n        return r % l"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.ceil(r / 2) - 1",
      "mutated_line": "return math.ceil(r / 2) * 1",
      "code": "import math\n\ndef find_max_mod(l, r):\n    if l <= math.ceil(r / 2):\n        return math.ceil(r / 2) * 1\n    else:\n        return r % l"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return r % l",
      "mutated_line": "return r * l",
      "code": "import math\n\ndef find_max_mod(l, r):\n    if l <= math.ceil(r / 2):\n        return math.ceil(r / 2) - 1\n    else:\n        return r * l"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return r % l",
      "mutated_line": "return r + l",
      "code": "import math\n\ndef find_max_mod(l, r):\n    if l <= math.ceil(r / 2):\n        return math.ceil(r / 2) - 1\n    else:\n        return r + l"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "if l <= math.ceil(r / 2):",
      "mutated_line": "if l <= math.ceil(r * 2):",
      "code": "import math\n\ndef find_max_mod(l, r):\n    if l <= math.ceil(r * 2):\n        return math.ceil(r / 2) - 1\n    else:\n        return r % l"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "if l <= math.ceil(r / 2):",
      "mutated_line": "if l <= math.ceil(r // 2):",
      "code": "import math\n\ndef find_max_mod(l, r):\n    if l <= math.ceil(r // 2):\n        return math.ceil(r / 2) - 1\n    else:\n        return r % l"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.ceil(r / 2) - 1",
      "mutated_line": "return math.ceil(r / 2) - 2",
      "code": "import math\n\ndef find_max_mod(l, r):\n    if l <= math.ceil(r / 2):\n        return math.ceil(r / 2) - 2\n    else:\n        return r % l"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.ceil(r / 2) - 1",
      "mutated_line": "return math.ceil(r / 2) - 0",
      "code": "import math\n\ndef find_max_mod(l, r):\n    if l <= math.ceil(r / 2):\n        return math.ceil(r / 2) - 0\n    else:\n        return r % l"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.ceil(r / 2) - 1",
      "mutated_line": "return math.ceil(r / 2) - 0",
      "code": "import math\n\ndef find_max_mod(l, r):\n    if l <= math.ceil(r / 2):\n        return math.ceil(r / 2) - 0\n    else:\n        return r % l"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.ceil(r / 2) - 1",
      "mutated_line": "return math.ceil(r / 2) - -1",
      "code": "import math\n\ndef find_max_mod(l, r):\n    if l <= math.ceil(r / 2):\n        return math.ceil(r / 2) - -1\n    else:\n        return r % l"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if l <= math.ceil(r / 2):",
      "mutated_line": "if l <= math.ceil(r / 3):",
      "code": "import math\n\ndef find_max_mod(l, r):\n    if l <= math.ceil(r / 3):\n        return math.ceil(r / 2) - 1\n    else:\n        return r % l"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if l <= math.ceil(r / 2):",
      "mutated_line": "if l <= math.ceil(r / 1):",
      "code": "import math\n\ndef find_max_mod(l, r):\n    if l <= math.ceil(r / 1):\n        return math.ceil(r / 2) - 1\n    else:\n        return r % l"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if l <= math.ceil(r / 2):",
      "mutated_line": "if l <= math.ceil(r / 0):",
      "code": "import math\n\ndef find_max_mod(l, r):\n    if l <= math.ceil(r / 0):\n        return math.ceil(r / 2) - 1\n    else:\n        return r % l"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if l <= math.ceil(r / 2):",
      "mutated_line": "if l <= math.ceil(r / 1):",
      "code": "import math\n\ndef find_max_mod(l, r):\n    if l <= math.ceil(r / 1):\n        return math.ceil(r / 2) - 1\n    else:\n        return r % l"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if l <= math.ceil(r / 2):",
      "mutated_line": "if l <= math.ceil(r / -2):",
      "code": "import math\n\ndef find_max_mod(l, r):\n    if l <= math.ceil(r / -2):\n        return math.ceil(r / 2) - 1\n    else:\n        return r % l"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.ceil(r / 2) - 1",
      "mutated_line": "return math.ceil(r * 2) - 1",
      "code": "import math\n\ndef find_max_mod(l, r):\n    if l <= math.ceil(r / 2):\n        return math.ceil(r * 2) - 1\n    else:\n        return r % l"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.ceil(r / 2) - 1",
      "mutated_line": "return math.ceil(r // 2) - 1",
      "code": "import math\n\ndef find_max_mod(l, r):\n    if l <= math.ceil(r / 2):\n        return math.ceil(r // 2) - 1\n    else:\n        return r % l"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.ceil(r / 2) - 1",
      "mutated_line": "return math.ceil(r / 3) - 1",
      "code": "import math\n\ndef find_max_mod(l, r):\n    if l <= math.ceil(r / 2):\n        return math.ceil(r / 3) - 1\n    else:\n        return r % l"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.ceil(r / 2) - 1",
      "mutated_line": "return math.ceil(r / 1) - 1",
      "code": "import math\n\ndef find_max_mod(l, r):\n    if l <= math.ceil(r / 2):\n        return math.ceil(r / 1) - 1\n    else:\n        return r % l"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.ceil(r / 2) - 1",
      "mutated_line": "return math.ceil(r / 0) - 1",
      "code": "import math\n\ndef find_max_mod(l, r):\n    if l <= math.ceil(r / 2):\n        return math.ceil(r / 0) - 1\n    else:\n        return r % l"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.ceil(r / 2) - 1",
      "mutated_line": "return math.ceil(r / 1) - 1",
      "code": "import math\n\ndef find_max_mod(l, r):\n    if l <= math.ceil(r / 2):\n        return math.ceil(r / 1) - 1\n    else:\n        return r % l"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.ceil(r / 2) - 1",
      "mutated_line": "return math.ceil(r / -2) - 1",
      "code": "import math\n\ndef find_max_mod(l, r):\n    if l <= math.ceil(r / 2):\n        return math.ceil(r / -2) - 1\n    else:\n        return r % l"
    }
  ]
}