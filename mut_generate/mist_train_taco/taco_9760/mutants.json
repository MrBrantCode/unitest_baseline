{
  "task_id": "taco_9760",
  "entry_point": "find_optimal_companions",
  "mutant_count": 155,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "phase = 1",
      "mutated_line": "phase = 2",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 2\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "phase = 1",
      "mutated_line": "phase = 0",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 0\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "phase = 1",
      "mutated_line": "phase = 0",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 0\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "phase = 1",
      "mutated_line": "phase = -1",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = -1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "phase = -1",
      "mutated_line": "phase = +1",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = +1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "result = (-10000000000.0, ())",
      "mutated_line": "result = (+10000000000.0, ())",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (+10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "search(0, 0, 0, 0)",
      "mutated_line": "search(1, 0, 0, 0)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(1, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "search(0, 0, 0, 0)",
      "mutated_line": "search(-1, 0, 0, 0)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(-1, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "search(0, 0, 0, 0)",
      "mutated_line": "search(1, 0, 0, 0)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(1, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "search(0, 0, 0, 0)",
      "mutated_line": "search(0, 1, 0, 0)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 1, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "search(0, 0, 0, 0)",
      "mutated_line": "search(0, -1, 0, 0)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, -1, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "search(0, 0, 0, 0)",
      "mutated_line": "search(0, 1, 0, 0)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 1, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "search(0, 0, 0, 0)",
      "mutated_line": "search(0, 0, 1, 0)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 1, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "search(0, 0, 0, 0)",
      "mutated_line": "search(0, 0, -1, 0)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, -1, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "search(0, 0, 0, 0)",
      "mutated_line": "search(0, 0, 1, 0)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 1, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "search(0, 0, 0, 0)",
      "mutated_line": "search(0, 0, 0, 1)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 1)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "search(0, 0, 0, 0)",
      "mutated_line": "search(0, 0, 0, -1)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, -1)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "search(0, 0, 0, 0)",
      "mutated_line": "search(0, 0, 0, 1)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 1)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "phase = -1",
      "mutated_line": "phase = -2",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -2\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "phase = -1",
      "mutated_line": "phase = -0",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -0\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "phase = -1",
      "mutated_line": "phase = -0",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -0\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "phase = -1",
      "mutated_line": "phase = --1",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = --1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "search(n - 1, 0, 0, 0)",
      "mutated_line": "search(n + 1, 0, 0, 0)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n + 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "search(n - 1, 0, 0, 0)",
      "mutated_line": "search(n * 1, 0, 0, 0)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n * 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "search(n - 1, 0, 0, 0)",
      "mutated_line": "search(n - 1, 1, 0, 0)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 1, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "search(n - 1, 0, 0, 0)",
      "mutated_line": "search(n - 1, -1, 0, 0)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, -1, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "search(n - 1, 0, 0, 0)",
      "mutated_line": "search(n - 1, 1, 0, 0)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 1, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "search(n - 1, 0, 0, 0)",
      "mutated_line": "search(n - 1, 0, 1, 0)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 1, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "search(n - 1, 0, 0, 0)",
      "mutated_line": "search(n - 1, 0, -1, 0)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, -1, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "search(n - 1, 0, 0, 0)",
      "mutated_line": "search(n - 1, 0, 1, 0)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 1, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "search(n - 1, 0, 0, 0)",
      "mutated_line": "search(n - 1, 0, 0, 1)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 1)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "search(n - 1, 0, 0, 0)",
      "mutated_line": "search(n - 1, 0, 0, -1)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, -1)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "search(n - 1, 0, 0, 0)",
      "mutated_line": "search(n - 1, 0, 0, 1)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 1)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if result[1]:",
      "mutated_line": "if result[2]:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[2]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if result[1]:",
      "mutated_line": "if result[0]:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[0]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if result[1]:",
      "mutated_line": "if result[0]:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[0]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if result[1]:",
      "mutated_line": "if result[-1]:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[-1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return \"Impossible\"",
      "mutated_line": "return ''",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return ''"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "result = (-10000000000.0, ())",
      "mutated_line": "result = (-10000000001.0, ())",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000001.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "result = (-10000000000.0, ())",
      "mutated_line": "result = (-9999999999.0, ())",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-9999999999.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "result = (-10000000000.0, ())",
      "mutated_line": "result = (-0, ())",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "result = (-10000000000.0, ())",
      "mutated_line": "result = (-1, ())",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-1, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "result = (-10000000000.0, ())",
      "mutated_line": "result = (--10000000000.0, ())",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (--10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if pos == n >> 1 if phase == 1 else pos < n >> 1:",
      "mutated_line": "if pos == n >> 1 if phase != 1 else pos < n >> 1:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase != 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if pos == n >> 1 if phase == 1 else pos < n >> 1:",
      "mutated_line": "if pos != n >> 1 if phase == 1 else pos < n >> 1:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos != n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if pos == n >> 1 if phase == 1 else pos < n >> 1:",
      "mutated_line": "if pos == n >> 1 if phase == 1 else pos <= n >> 1:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos <= n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if pos == n >> 1 if phase == 1 else pos < n >> 1:",
      "mutated_line": "if pos == n >> 1 if phase == 1 else pos >= n >> 1:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos >= n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if pos == n >> 1 if phase == 1 else pos < n >> 1:",
      "mutated_line": "if pos == n >> 1 if phase == 1 else pos != n >> 1:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos != n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if phase == 1:",
      "mutated_line": "if phase != 1:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase != 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "stack[-1] = 'LW'",
      "mutated_line": "stack[-1] = ''",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = ''\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stack[-1] = 'MW'",
      "mutated_line": "stack[-1] = ''",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = ''\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "search(n - 1, 0, 0, 0)",
      "mutated_line": "search(n - 2, 0, 0, 0)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 2, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "search(n - 1, 0, 0, 0)",
      "mutated_line": "search(n - 0, 0, 0, 0)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 0, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "search(n - 1, 0, 0, 0)",
      "mutated_line": "search(n - 0, 0, 0, 0)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 0, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "search(n - 1, 0, 0, 0)",
      "mutated_line": "search(n - -1, 0, 0, 0)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - -1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return result[1]",
      "mutated_line": "return result[2]",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[2]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return result[1]",
      "mutated_line": "return result[0]",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[0]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return result[1]",
      "mutated_line": "return result[0]",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[0]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return result[1]",
      "mutated_line": "return result[-1]",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[-1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if pos == n >> 1 if phase == 1 else pos < n >> 1:",
      "mutated_line": "if pos == n >> 1 if phase == 2 else pos < n >> 1:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 2 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if pos == n >> 1 if phase == 1 else pos < n >> 1:",
      "mutated_line": "if pos == n >> 1 if phase == 0 else pos < n >> 1:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 0 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if pos == n >> 1 if phase == 1 else pos < n >> 1:",
      "mutated_line": "if pos == n >> 1 if phase == 0 else pos < n >> 1:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 0 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if pos == n >> 1 if phase == 1 else pos < n >> 1:",
      "mutated_line": "if pos == n >> 1 if phase == -1 else pos < n >> 1:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == -1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if phase == 1:",
      "mutated_line": "if phase == 2:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 2:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if phase == 1:",
      "mutated_line": "if phase == 0:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 0:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if phase == 1:",
      "mutated_line": "if phase == 0:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 0:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if phase == 1:",
      "mutated_line": "if phase == -1:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == -1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "LCR",
      "lineno": 14,
      "original_line": "if seq is not None and l + first_l > result[0]:",
      "mutated_line": "if seq is not None or l + first_l > result[0]:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None or l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "stack.append('LM')",
      "mutated_line": "stack.append('')",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)",
      "mutated_line": "search(pos - phase, l + tasks[pos][0], m + tasks[pos][1], w)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos - phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)",
      "mutated_line": "search(pos * phase, l + tasks[pos][0], m + tasks[pos][1], w)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos * phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)",
      "mutated_line": "search(pos + phase, l - tasks[pos][0], m + tasks[pos][1], w)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l - tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)",
      "mutated_line": "search(pos + phase, l * tasks[pos][0], m + tasks[pos][1], w)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l * tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)",
      "mutated_line": "search(pos + phase, l + tasks[pos][0], m - tasks[pos][1], w)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m - tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)",
      "mutated_line": "search(pos + phase, l + tasks[pos][0], m * tasks[pos][1], w)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m * tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "stack[-1] = 'LW'",
      "mutated_line": "stack[+1] = 'LW'",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[+1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])",
      "mutated_line": "search(pos - phase, l + tasks[pos][0], m, w + tasks[pos][2])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos - phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])",
      "mutated_line": "search(pos * phase, l + tasks[pos][0], m, w + tasks[pos][2])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos * phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])",
      "mutated_line": "search(pos + phase, l - tasks[pos][0], m, w + tasks[pos][2])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l - tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])",
      "mutated_line": "search(pos + phase, l * tasks[pos][0], m, w + tasks[pos][2])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l * tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])",
      "mutated_line": "search(pos + phase, l + tasks[pos][0], m, w - tasks[pos][2])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w - tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])",
      "mutated_line": "search(pos + phase, l + tasks[pos][0], m, w * tasks[pos][2])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w * tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "stack[-1] = 'MW'",
      "mutated_line": "stack[+1] = 'MW'",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[+1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])",
      "mutated_line": "search(pos - phase, l, m + tasks[pos][1], w + tasks[pos][2])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos - phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])",
      "mutated_line": "search(pos * phase, l, m + tasks[pos][1], w + tasks[pos][2])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos * phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])",
      "mutated_line": "search(pos + phase, l, m - tasks[pos][1], w + tasks[pos][2])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m - tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])",
      "mutated_line": "search(pos + phase, l, m * tasks[pos][1], w + tasks[pos][2])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m * tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])",
      "mutated_line": "search(pos + phase, l, m + tasks[pos][1], w - tasks[pos][2])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w - tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])",
      "mutated_line": "search(pos + phase, l, m + tasks[pos][1], w * tasks[pos][2])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w * tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if pos == n >> 1 if phase == 1 else pos < n >> 1:",
      "mutated_line": "if pos == n >> 2 if phase == 1 else pos < n >> 1:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 2 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if pos == n >> 1 if phase == 1 else pos < n >> 1:",
      "mutated_line": "if pos == n >> 0 if phase == 1 else pos < n >> 1:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 0 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if pos == n >> 1 if phase == 1 else pos < n >> 1:",
      "mutated_line": "if pos == n >> 0 if phase == 1 else pos < n >> 1:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 0 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if pos == n >> 1 if phase == 1 else pos < n >> 1:",
      "mutated_line": "if pos == n >> -1 if phase == 1 else pos < n >> 1:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> -1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if pos == n >> 1 if phase == 1 else pos < n >> 1:",
      "mutated_line": "if pos == n >> 1 if phase == 1 else pos < n >> 2:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 2:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if pos == n >> 1 if phase == 1 else pos < n >> 1:",
      "mutated_line": "if pos == n >> 1 if phase == 1 else pos < n >> 0:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 0:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if pos == n >> 1 if phase == 1 else pos < n >> 1:",
      "mutated_line": "if pos == n >> 1 if phase == 1 else pos < n >> 0:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 0:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if pos == n >> 1 if phase == 1 else pos < n >> 1:",
      "mutated_line": "if pos == n >> 1 if phase == 1 else pos < n >> -1:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> -1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if seq is not None and l + first_l > result[0]:",
      "mutated_line": "if seq is None and l + first_l > result[0]:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if seq is not None and l + first_l > result[0]:",
      "mutated_line": "if seq is not None and l + first_l >= result[0]:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l >= result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if seq is not None and l + first_l > result[0]:",
      "mutated_line": "if seq is not None and l + first_l <= result[0]:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l <= result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if seq is not None and l + first_l > result[0]:",
      "mutated_line": "if seq is not None and l + first_l != result[0]:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l != result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "stack[-1] = 'LW'",
      "mutated_line": "stack[-2] = 'LW'",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-2] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "stack[-1] = 'LW'",
      "mutated_line": "stack[-0] = 'LW'",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-0] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "stack[-1] = 'LW'",
      "mutated_line": "stack[-0] = 'LW'",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-0] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "stack[-1] = 'LW'",
      "mutated_line": "stack[--1] = 'LW'",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[--1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stack[-1] = 'MW'",
      "mutated_line": "stack[-2] = 'MW'",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-2] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stack[-1] = 'MW'",
      "mutated_line": "stack[-0] = 'MW'",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-0] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stack[-1] = 'MW'",
      "mutated_line": "stack[-0] = 'MW'",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-0] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "stack[-1] = 'MW'",
      "mutated_line": "stack[--1] = 'MW'",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[--1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "middle[(m - l, w - l)] = (stack[:], l)",
      "mutated_line": "middle[m + l, w - l] = (stack[:], l)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m + l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "middle[(m - l, w - l)] = (stack[:], l)",
      "mutated_line": "middle[m * l, w - l] = (stack[:], l)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m * l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "middle[(m - l, w - l)] = (stack[:], l)",
      "mutated_line": "middle[m - l, w + l] = (stack[:], l)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w + l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "middle[(m - l, w - l)] = (stack[:], l)",
      "mutated_line": "middle[m - l, w * l] = (stack[:], l)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w * l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(seq, first_l) = middle.get((l - m, l - w), (None, None))",
      "mutated_line": "(seq, first_l) = middle.get((l + m, l - w), (None, None))",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l + m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(seq, first_l) = middle.get((l - m, l - w), (None, None))",
      "mutated_line": "(seq, first_l) = middle.get((l * m, l - w), (None, None))",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l * m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(seq, first_l) = middle.get((l - m, l - w), (None, None))",
      "mutated_line": "(seq, first_l) = middle.get((l - m, l + w), (None, None))",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l + w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "(seq, first_l) = middle.get((l - m, l - w), (None, None))",
      "mutated_line": "(seq, first_l) = middle.get((l - m, l * w), (None, None))",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l * w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if seq is not None and l + first_l > result[0]:",
      "mutated_line": "if seq is not None and l - first_l > result[0]:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l - first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if seq is not None and l + first_l > result[0]:",
      "mutated_line": "if seq is not None and l * first_l > result[0]:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l * first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "result = (l + first_l, seq + stack[::-1])",
      "mutated_line": "result = (l - first_l, seq + stack[::-1])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l - first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "result = (l + first_l, seq + stack[::-1])",
      "mutated_line": "result = (l * first_l, seq + stack[::-1])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l * first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "result = (l + first_l, seq + stack[::-1])",
      "mutated_line": "result = (l + first_l, seq - stack[::-1])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq - stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "result = (l + first_l, seq + stack[::-1])",
      "mutated_line": "result = (l + first_l, seq * stack[::-1])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq * stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)",
      "mutated_line": "search(pos + phase, l + tasks[pos][1], m + tasks[pos][1], w)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][1], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)",
      "mutated_line": "search(pos + phase, l + tasks[pos][-1], m + tasks[pos][1], w)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][-1], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)",
      "mutated_line": "search(pos + phase, l + tasks[pos][1], m + tasks[pos][1], w)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][1], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)",
      "mutated_line": "search(pos + phase, l + tasks[pos][0], m + tasks[pos][2], w)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][2], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)",
      "mutated_line": "search(pos + phase, l + tasks[pos][0], m + tasks[pos][0], w)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][0], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)",
      "mutated_line": "search(pos + phase, l + tasks[pos][0], m + tasks[pos][0], w)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][0], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)",
      "mutated_line": "search(pos + phase, l + tasks[pos][0], m + tasks[pos][-1], w)",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][-1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])",
      "mutated_line": "search(pos + phase, l + tasks[pos][1], m, w + tasks[pos][2])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][1], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])",
      "mutated_line": "search(pos + phase, l + tasks[pos][-1], m, w + tasks[pos][2])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][-1], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])",
      "mutated_line": "search(pos + phase, l + tasks[pos][1], m, w + tasks[pos][2])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][1], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])",
      "mutated_line": "search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][3])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][3])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])",
      "mutated_line": "search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][1])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][1])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])",
      "mutated_line": "search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][0])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][0])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])",
      "mutated_line": "search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][1])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][1])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])",
      "mutated_line": "search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][-2])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][-2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])",
      "mutated_line": "search(pos + phase, l, m + tasks[pos][2], w + tasks[pos][2])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][2], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])",
      "mutated_line": "search(pos + phase, l, m + tasks[pos][0], w + tasks[pos][2])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][0], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])",
      "mutated_line": "search(pos + phase, l, m + tasks[pos][0], w + tasks[pos][2])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][0], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])",
      "mutated_line": "search(pos + phase, l, m + tasks[pos][-1], w + tasks[pos][2])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][-1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])",
      "mutated_line": "search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][3])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][3])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])",
      "mutated_line": "search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][1])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][1])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])",
      "mutated_line": "search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][0])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][0])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])",
      "mutated_line": "search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][1])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][1])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])",
      "mutated_line": "search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][-2])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][-2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if seq is not None and l + first_l > result[0]:",
      "mutated_line": "if seq is not None and l + first_l > result[1]:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[1]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if seq is not None and l + first_l > result[0]:",
      "mutated_line": "if seq is not None and l + first_l > result[-1]:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[-1]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if seq is not None and l + first_l > result[0]:",
      "mutated_line": "if seq is not None and l + first_l > result[1]:",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[1]:\n                    result = (l + first_l, seq + stack[::-1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "result = (l + first_l, seq + stack[::-1])",
      "mutated_line": "result = (l + first_l, seq + stack[::+1])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::+1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result = (l + first_l, seq + stack[::-1])",
      "mutated_line": "result = (l + first_l, seq + stack[::-2])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-2])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result = (l + first_l, seq + stack[::-1])",
      "mutated_line": "result = (l + first_l, seq + stack[::-0])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-0])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result = (l + first_l, seq + stack[::-1])",
      "mutated_line": "result = (l + first_l, seq + stack[::-0])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::-0])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "result = (l + first_l, seq + stack[::-1])",
      "mutated_line": "result = (l + first_l, seq + stack[::--1])",
      "code": "def find_optimal_companions(n, tasks):\n    middle = {}\n    stack = []\n    result = (-10000000000.0, ())\n    phase = 1\n\n    def search(pos, l, m, w):\n        nonlocal result\n        if pos == n >> 1 if phase == 1 else pos < n >> 1:\n            if phase == 1:\n                middle[m - l, w - l] = (stack[:], l)\n            else:\n                (seq, first_l) = middle.get((l - m, l - w), (None, None))\n                if seq is not None and l + first_l > result[0]:\n                    result = (l + first_l, seq + stack[::--1])\n        else:\n            stack.append('LM')\n            search(pos + phase, l + tasks[pos][0], m + tasks[pos][1], w)\n            stack[-1] = 'LW'\n            search(pos + phase, l + tasks[pos][0], m, w + tasks[pos][2])\n            stack[-1] = 'MW'\n            search(pos + phase, l, m + tasks[pos][1], w + tasks[pos][2])\n            stack.pop()\n    search(0, 0, 0, 0)\n    phase = -1\n    search(n - 1, 0, 0, 0)\n    if result[1]:\n        return result[1]\n    else:\n        return 'Impossible'"
    }
  ]
}