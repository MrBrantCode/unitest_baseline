{
  "task_id": "taco_13574",
  "entry_point": "dijkstra_shortest_path",
  "mutant_count": 81,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dis[S] = 0",
      "mutated_line": "dis[S] = 1",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 1\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dis[S] = 0",
      "mutated_line": "dis[S] = -1",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = -1\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dis[S] = 0",
      "mutated_line": "dis[S] = 1",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 1\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while len(pq) > 0:",
      "mutated_line": "while len(pq) >= 0:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) >= 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while len(pq) > 0:",
      "mutated_line": "while len(pq) <= 0:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) <= 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while len(pq) > 0:",
      "mutated_line": "while len(pq) != 0:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) != 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vis = [0 for _ in range(V)]",
      "mutated_line": "vis = [1 for _ in range(V)]",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [1 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vis = [0 for _ in range(V)]",
      "mutated_line": "vis = [-1 for _ in range(V)]",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [-1 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "vis = [0 for _ in range(V)]",
      "mutated_line": "vis = [1 for _ in range(V)]",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [1 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "while len(pq) > 0:",
      "mutated_line": "while len(pq) > 1:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 1:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "while len(pq) > 0:",
      "mutated_line": "while len(pq) > -1:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > -1:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "while len(pq) > 0:",
      "mutated_line": "while len(pq) > 1:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 1:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "while len(pq) > 0 and vis[pq[0][1]] == 1:",
      "mutated_line": "while len(pq) > 0 or vis[pq[0][1]] == 1:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 or vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if len(pq) > 0:",
      "mutated_line": "if len(pq) >= 0:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) >= 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if len(pq) > 0:",
      "mutated_line": "if len(pq) <= 0:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) <= 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if len(pq) > 0:",
      "mutated_line": "if len(pq) != 0:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) != 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "pq = [(0, S)]",
      "mutated_line": "pq = [(1, S)]",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(1, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "pq = [(0, S)]",
      "mutated_line": "pq = [(-1, S)]",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(-1, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "pq = [(0, S)]",
      "mutated_line": "pq = [(1, S)]",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(1, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while len(pq) > 0 and vis[pq[0][1]] == 1:",
      "mutated_line": "while len(pq) >= 0 and vis[pq[0][1]] == 1:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) >= 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while len(pq) > 0 and vis[pq[0][1]] == 1:",
      "mutated_line": "while len(pq) <= 0 and vis[pq[0][1]] == 1:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) <= 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while len(pq) > 0 and vis[pq[0][1]] == 1:",
      "mutated_line": "while len(pq) != 0 and vis[pq[0][1]] == 1:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) != 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while len(pq) > 0 and vis[pq[0][1]] == 1:",
      "mutated_line": "while len(pq) > 0 and vis[pq[0][1]] != 1:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] != 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(pq) > 0:",
      "mutated_line": "if len(pq) > 1:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 1:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(pq) > 0:",
      "mutated_line": "if len(pq) > -1:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > -1:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if len(pq) > 0:",
      "mutated_line": "if len(pq) > 1:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 1:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "vis[temp[1]] = 1",
      "mutated_line": "vis[temp[1]] = 2",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 2\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "vis[temp[1]] = 1",
      "mutated_line": "vis[temp[1]] = 0",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 0\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "vis[temp[1]] = 1",
      "mutated_line": "vis[temp[1]] = 0",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 0\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "vis[temp[1]] = 1",
      "mutated_line": "vis[temp[1]] = -1",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = -1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while len(pq) > 0 and vis[pq[0][1]] == 1:",
      "mutated_line": "while len(pq) > 1 and vis[pq[0][1]] == 1:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 1 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while len(pq) > 0 and vis[pq[0][1]] == 1:",
      "mutated_line": "while len(pq) > -1 and vis[pq[0][1]] == 1:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > -1 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while len(pq) > 0 and vis[pq[0][1]] == 1:",
      "mutated_line": "while len(pq) > 1 and vis[pq[0][1]] == 1:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 1 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while len(pq) > 0 and vis[pq[0][1]] == 1:",
      "mutated_line": "while len(pq) > 0 and vis[pq[0][1]] == 2:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 2:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while len(pq) > 0 and vis[pq[0][1]] == 1:",
      "mutated_line": "while len(pq) > 0 and vis[pq[0][1]] == 0:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 0:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while len(pq) > 0 and vis[pq[0][1]] == 1:",
      "mutated_line": "while len(pq) > 0 and vis[pq[0][1]] == 0:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 0:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while len(pq) > 0 and vis[pq[0][1]] == 1:",
      "mutated_line": "while len(pq) > 0 and vis[pq[0][1]] == -1:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == -1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "vis[temp[1]] = 1",
      "mutated_line": "vis[temp[2]] = 1",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[2]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "vis[temp[1]] = 1",
      "mutated_line": "vis[temp[0]] = 1",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[0]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "vis[temp[1]] = 1",
      "mutated_line": "vis[temp[0]] = 1",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[0]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "vis[temp[1]] = 1",
      "mutated_line": "vis[temp[-1]] = 1",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[-1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in graph[temp[1]]:",
      "mutated_line": "for i in graph[temp[2]]:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[2]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in graph[temp[1]]:",
      "mutated_line": "for i in graph[temp[0]]:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[0]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in graph[temp[1]]:",
      "mutated_line": "for i in graph[temp[0]]:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[0]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in graph[temp[1]]:",
      "mutated_line": "for i in graph[temp[-1]]:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[-1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i[1] = min(dis[i[0]], temp[0] + i[1])",
      "mutated_line": "i[2] = min(dis[i[0]], temp[0] + i[1])",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[2] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i[1] = min(dis[i[0]], temp[0] + i[1])",
      "mutated_line": "i[0] = min(dis[i[0]], temp[0] + i[1])",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[0] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i[1] = min(dis[i[0]], temp[0] + i[1])",
      "mutated_line": "i[0] = min(dis[i[0]], temp[0] + i[1])",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[0] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i[1] = min(dis[i[0]], temp[0] + i[1])",
      "mutated_line": "i[-1] = min(dis[i[0]], temp[0] + i[1])",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[-1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "i[1] = min(dis[i[0]], temp[0] + i[1])",
      "mutated_line": "i[1] = min(dis[i[0]], temp[0] - i[1])",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] - i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "i[1] = min(dis[i[0]], temp[0] + i[1])",
      "mutated_line": "i[1] = min(dis[i[0]], temp[0] * i[1])",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] * i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dis[i[0]] = i[1]",
      "mutated_line": "dis[i[0]] = i[2]",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[2]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dis[i[0]] = i[1]",
      "mutated_line": "dis[i[0]] = i[0]",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[0]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dis[i[0]] = i[1]",
      "mutated_line": "dis[i[0]] = i[0]",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[0]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dis[i[0]] = i[1]",
      "mutated_line": "dis[i[0]] = i[-1]",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[-1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while len(pq) > 0 and vis[pq[0][1]] == 1:",
      "mutated_line": "while len(pq) > 0 and vis[pq[0][2]] == 1:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][2]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while len(pq) > 0 and vis[pq[0][1]] == 1:",
      "mutated_line": "while len(pq) > 0 and vis[pq[0][0]] == 1:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][0]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while len(pq) > 0 and vis[pq[0][1]] == 1:",
      "mutated_line": "while len(pq) > 0 and vis[pq[0][0]] == 1:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][0]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while len(pq) > 0 and vis[pq[0][1]] == 1:",
      "mutated_line": "while len(pq) > 0 and vis[pq[0][-1]] == 1:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][-1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dis[i[0]] = i[1]",
      "mutated_line": "dis[i[1]] = i[1]",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[1]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dis[i[0]] = i[1]",
      "mutated_line": "dis[i[-1]] = i[1]",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[-1]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dis[i[0]] = i[1]",
      "mutated_line": "dis[i[1]] = i[1]",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[1]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while len(pq) > 0 and vis[pq[0][1]] == 1:",
      "mutated_line": "while len(pq) > 0 and vis[pq[1][1]] == 1:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[1][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while len(pq) > 0 and vis[pq[0][1]] == 1:",
      "mutated_line": "while len(pq) > 0 and vis[pq[-1][1]] == 1:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[-1][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "while len(pq) > 0 and vis[pq[0][1]] == 1:",
      "mutated_line": "while len(pq) > 0 and vis[pq[1][1]] == 1:",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[1][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i[1] = min(dis[i[0]], temp[0] + i[1])",
      "mutated_line": "i[1] = min(dis[i[1]], temp[0] + i[1])",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[1]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i[1] = min(dis[i[0]], temp[0] + i[1])",
      "mutated_line": "i[1] = min(dis[i[-1]], temp[0] + i[1])",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[-1]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i[1] = min(dis[i[0]], temp[0] + i[1])",
      "mutated_line": "i[1] = min(dis[i[1]], temp[0] + i[1])",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[1]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i[1] = min(dis[i[0]], temp[0] + i[1])",
      "mutated_line": "i[1] = min(dis[i[0]], temp[1] + i[1])",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[1] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i[1] = min(dis[i[0]], temp[0] + i[1])",
      "mutated_line": "i[1] = min(dis[i[0]], temp[-1] + i[1])",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[-1] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i[1] = min(dis[i[0]], temp[0] + i[1])",
      "mutated_line": "i[1] = min(dis[i[0]], temp[1] + i[1])",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[1] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i[1] = min(dis[i[0]], temp[0] + i[1])",
      "mutated_line": "i[1] = min(dis[i[0]], temp[0] + i[2])",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[2])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i[1] = min(dis[i[0]], temp[0] + i[1])",
      "mutated_line": "i[1] = min(dis[i[0]], temp[0] + i[0])",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[0])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i[1] = min(dis[i[0]], temp[0] + i[1])",
      "mutated_line": "i[1] = min(dis[i[0]], temp[0] + i[0])",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[0])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "i[1] = min(dis[i[0]], temp[0] + i[1])",
      "mutated_line": "i[1] = min(dis[i[0]], temp[0] + i[-1])",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[-1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heapq.heappush(pq, (dis[i[0]], i[0]))",
      "mutated_line": "heapq.heappush(pq, (dis[i[0]], i[1]))",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[1]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heapq.heappush(pq, (dis[i[0]], i[0]))",
      "mutated_line": "heapq.heappush(pq, (dis[i[0]], i[-1]))",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[-1]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heapq.heappush(pq, (dis[i[0]], i[0]))",
      "mutated_line": "heapq.heappush(pq, (dis[i[0]], i[1]))",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[0]], i[1]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heapq.heappush(pq, (dis[i[0]], i[0]))",
      "mutated_line": "heapq.heappush(pq, (dis[i[1]], i[0]))",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[1]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heapq.heappush(pq, (dis[i[0]], i[0]))",
      "mutated_line": "heapq.heappush(pq, (dis[i[-1]], i[0]))",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[-1]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "heapq.heappush(pq, (dis[i[0]], i[0]))",
      "mutated_line": "heapq.heappush(pq, (dis[i[1]], i[0]))",
      "code": "import heapq\nimport sys\n\ndef dijkstra_shortest_path(V, adj, S):\n\n    def util(graph, vis, pq, dis, s, V):\n        while len(pq) > 0:\n            while len(pq) > 0 and vis[pq[0][1]] == 1:\n                heapq.heappop(pq)\n            if len(pq) > 0:\n                temp = heapq.heappop(pq)\n                vis[temp[1]] = 1\n                for i in graph[temp[1]]:\n                    i[1] = min(dis[i[0]], temp[0] + i[1])\n                    dis[i[0]] = i[1]\n                    heapq.heappush(pq, (dis[i[1]], i[0]))\n        return dis\n    vis = [0 for _ in range(V)]\n    dis = [sys.maxsize for _ in range(V)]\n    pq = [(0, S)]\n    dis[S] = 0\n    heapq.heapify(pq)\n    return util(adj, vis, pq, dis, S, V)"
    }
  ]
}