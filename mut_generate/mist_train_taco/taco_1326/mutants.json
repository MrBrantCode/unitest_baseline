{
  "task_id": "taco_1326",
  "entry_point": "primes",
  "mutant_count": 410,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = [True] * ((n - 1) // 2)",
      "mutated_line": "x = [True] / ((n - 1) // 2)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] / ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = [True] * ((n - 1) // 2)",
      "mutated_line": "x = [True] + (n - 1) // 2",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] + (n - 1) // 2\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = [True] * ((n - 1) // 2)",
      "mutated_line": "x = [True] ** ((n - 1) // 2)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] ** ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "mutated_line": "return [2] - [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] - [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "mutated_line": "return [2] * [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] * [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "def count_prime_xor_multisets(numbers, modulo=10**9 + 7):",
      "mutated_line": "def count_prime_xor_multisets(numbers, modulo=10 ** 9 - 7):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 - 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "def count_prime_xor_multisets(numbers, modulo=10**9 + 7):",
      "mutated_line": "def count_prime_xor_multisets(numbers, modulo=10 ** 9 * 7):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 * 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "count = [0] * 4501",
      "mutated_line": "count = [0] / 4501",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] / 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "count = [0] * 4501",
      "mutated_line": "count = [0] + 4501",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] + 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "count = [0] * 4501",
      "mutated_line": "count = [0] ** 4501",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] ** 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "totals[static][0] = 1",
      "mutated_line": "totals[static][0] = 2",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 2\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "totals[static][0] = 1",
      "mutated_line": "totals[static][0] = 0",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 0\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "totals[static][0] = 1",
      "mutated_line": "totals[static][0] = 0",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 0\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "totals[static][0] = 1",
      "mutated_line": "totals[static][0] = -1",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = -1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "total = 0",
      "mutated_line": "total = 1",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 1\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "total = 0",
      "mutated_line": "total = -1",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = -1\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "total = 0",
      "mutated_line": "total = 1",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 1\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "total += totals[static][prime]",
      "mutated_line": "total -= totals[static][prime]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total -= totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return total % modulo",
      "mutated_line": "return total * modulo",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total * modulo"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return total % modulo",
      "mutated_line": "return total + modulo",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total + modulo"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = [True] * ((n - 1) // 2)",
      "mutated_line": "x = [True] * ((n - 1) / 2)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) / 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = [True] * ((n - 1) // 2)",
      "mutated_line": "x = [True] * ((n - 1) * 2)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) * 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(int((sqrt(n) - 3) // 2) + 1):",
      "mutated_line": "for i in range(int((sqrt(n) - 3) // 2) - 1):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) - 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(int((sqrt(n) - 3) // 2) + 1):",
      "mutated_line": "for i in range(int((sqrt(n) - 3) // 2) * 1):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) * 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "def count_prime_xor_multisets(numbers, modulo=10**9 + 7):",
      "mutated_line": "def count_prime_xor_multisets(numbers, modulo=10 * 9 + 7):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 * 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "def count_prime_xor_multisets(numbers, modulo=10**9 + 7):",
      "mutated_line": "def count_prime_xor_multisets(numbers, modulo=10 + 9 + 7):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 + 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "def count_prime_xor_multisets(numbers, modulo=10**9 + 7):",
      "mutated_line": "def count_prime_xor_multisets(numbers, modulo=10 ** 9 + 8):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 8):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "def count_prime_xor_multisets(numbers, modulo=10**9 + 7):",
      "mutated_line": "def count_prime_xor_multisets(numbers, modulo=10 ** 9 + 6):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 6):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "def count_prime_xor_multisets(numbers, modulo=10**9 + 7):",
      "mutated_line": "def count_prime_xor_multisets(numbers, modulo=10 ** 9 + 0):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 0):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "def count_prime_xor_multisets(numbers, modulo=10**9 + 7):",
      "mutated_line": "def count_prime_xor_multisets(numbers, modulo=10 ** 9 + 1):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 1):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "def count_prime_xor_multisets(numbers, modulo=10**9 + 7):",
      "mutated_line": "def count_prime_xor_multisets(numbers, modulo=10 ** 9 + -7):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + -7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "count = [0] * 4501",
      "mutated_line": "count = [0] * 4502",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4502\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "count = [0] * 4501",
      "mutated_line": "count = [0] * 4500",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4500\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "count = [0] * 4501",
      "mutated_line": "count = [0] * 0",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 0\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "count = [0] * 4501",
      "mutated_line": "count = [0] * 1",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 1\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "count = [0] * 4501",
      "mutated_line": "count = [0] * -4501",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * -4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "totals = [[0] * 8192 for _ in range(2)]",
      "mutated_line": "totals = [[0] / 8192 for _ in range(2)]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] / 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "totals = [[0] * 8192 for _ in range(2)]",
      "mutated_line": "totals = [[0] + 8192 for _ in range(2)]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] + 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "totals = [[0] * 8192 for _ in range(2)]",
      "mutated_line": "totals = [[0] ** 8192 for _ in range(2)]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] ** 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "(static, update) = (0, 1)",
      "mutated_line": "(static, update) = (1, 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (1, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "(static, update) = (0, 1)",
      "mutated_line": "(static, update) = (-1, 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (-1, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "(static, update) = (0, 1)",
      "mutated_line": "(static, update) = (1, 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (1, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "(static, update) = (0, 1)",
      "mutated_line": "(static, update) = (0, 2)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 2)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "(static, update) = (0, 1)",
      "mutated_line": "(static, update) = (0, 0)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 0)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "(static, update) = (0, 1)",
      "mutated_line": "(static, update) = (0, 0)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 0)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "(static, update) = (0, 1)",
      "mutated_line": "(static, update) = (0, -1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, -1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "totals[static][0] = 1",
      "mutated_line": "totals[static][1] = 1",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][1] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "totals[static][0] = 1",
      "mutated_line": "totals[static][-1] = 1",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][-1] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "totals[static][0] = 1",
      "mutated_line": "totals[static][1] = 1",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][1] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "p = primes(8191)",
      "mutated_line": "p = primes(8192)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8192)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "p = primes(8191)",
      "mutated_line": "p = primes(8190)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8190)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "p = primes(8191)",
      "mutated_line": "p = primes(0)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(0)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "p = primes(8191)",
      "mutated_line": "p = primes(1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(1)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "p = primes(8191)",
      "mutated_line": "p = primes(-8191)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(-8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = [True] * ((n - 1) // 2)",
      "mutated_line": "x = [False] * ((n - 1) // 2)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [False] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = [True] * ((n - 1) // 2)",
      "mutated_line": "x = [True] * ((n + 1) // 2)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n + 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "x = [True] * ((n - 1) // 2)",
      "mutated_line": "x = [True] * (n * 1 // 2)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * (n * 1 // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = [True] * ((n - 1) // 2)",
      "mutated_line": "x = [True] * ((n - 1) // 3)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 3)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = [True] * ((n - 1) // 2)",
      "mutated_line": "x = [True] * ((n - 1) // 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 1)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = [True] * ((n - 1) // 2)",
      "mutated_line": "x = [True] * ((n - 1) // 0)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 0)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = [True] * ((n - 1) // 2)",
      "mutated_line": "x = [True] * ((n - 1) // 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 1)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = [True] * ((n - 1) // 2)",
      "mutated_line": "x = [True] * ((n - 1) // -2)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // -2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(int((sqrt(n) - 3) // 2) + 1):",
      "mutated_line": "for i in range(int((sqrt(n) - 3) // 2) + 2):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 2):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(int((sqrt(n) - 3) // 2) + 1):",
      "mutated_line": "for i in range(int((sqrt(n) - 3) // 2) + 0):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 0):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(int((sqrt(n) - 3) // 2) + 1):",
      "mutated_line": "for i in range(int((sqrt(n) - 3) // 2) + 0):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 0):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(int((sqrt(n) - 3) // 2) + 1):",
      "mutated_line": "for i in range(int((sqrt(n) - 3) // 2) + -1):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + -1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] / int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] / int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] + int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] + int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] ** int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] ** int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "mutated_line": "return [3] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [3] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "mutated_line": "return [1] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [1] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "mutated_line": "return [0] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [0] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "mutated_line": "return [1] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [1] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "mutated_line": "return [-2] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [-2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "mutated_line": "return [2] + [2 * i - 3 for (i, v) in enumerate(x) if v]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i - 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "mutated_line": "return [2] + [2 * i * 3 for (i, v) in enumerate(x) if v]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i * 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "def count_prime_xor_multisets(numbers, modulo=10**9 + 7):",
      "mutated_line": "def count_prime_xor_multisets(numbers, modulo=11 ** 9 + 7):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=11 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "def count_prime_xor_multisets(numbers, modulo=10**9 + 7):",
      "mutated_line": "def count_prime_xor_multisets(numbers, modulo=9 ** 9 + 7):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=9 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "def count_prime_xor_multisets(numbers, modulo=10**9 + 7):",
      "mutated_line": "def count_prime_xor_multisets(numbers, modulo=0 ** 9 + 7):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=0 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "def count_prime_xor_multisets(numbers, modulo=10**9 + 7):",
      "mutated_line": "def count_prime_xor_multisets(numbers, modulo=1 ** 9 + 7):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=1 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "def count_prime_xor_multisets(numbers, modulo=10**9 + 7):",
      "mutated_line": "def count_prime_xor_multisets(numbers, modulo=-10 ** 9 + 7):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=-10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "def count_prime_xor_multisets(numbers, modulo=10**9 + 7):",
      "mutated_line": "def count_prime_xor_multisets(numbers, modulo=10 ** 10 + 7):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 10 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "def count_prime_xor_multisets(numbers, modulo=10**9 + 7):",
      "mutated_line": "def count_prime_xor_multisets(numbers, modulo=10 ** 8 + 7):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 8 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "def count_prime_xor_multisets(numbers, modulo=10**9 + 7):",
      "mutated_line": "def count_prime_xor_multisets(numbers, modulo=10 ** 0 + 7):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 0 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "def count_prime_xor_multisets(numbers, modulo=10**9 + 7):",
      "mutated_line": "def count_prime_xor_multisets(numbers, modulo=10 ** 1 + 7):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 1 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "def count_prime_xor_multisets(numbers, modulo=10**9 + 7):",
      "mutated_line": "def count_prime_xor_multisets(numbers, modulo=10 ** -9 + 7):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** -9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "count = [0] * 4501",
      "mutated_line": "count = [1] * 4501",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [1] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "count = [0] * 4501",
      "mutated_line": "count = [-1] * 4501",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [-1] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "count = [0] * 4501",
      "mutated_line": "count = [1] * 4501",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [1] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4097, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4097, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4095, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4095, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((0, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((0, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((1, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((1, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((-4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((-4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4352), (4352, 4500), (3584, 4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4352), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4350), (4352, 4500), (3584, 4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4350), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 0), (4352, 4500), (3584, 4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 0), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 1), (4352, 4500), (3584, 4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 1), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, -4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, -4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4353, 4500), (3584, 4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4353, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4351, 4500), (3584, 4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4351, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (0, 4500), (3584, 4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (0, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (1, 4500), (3584, 4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (1, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (-4352, 4500), (3584, 4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (-4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4352, 4501), (3584, 4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4501), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4352, 4499), (3584, 4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4499), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4352, 0), (3584, 4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 0), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4352, 1), (3584, 4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 1), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4352, -4500), (3584, 4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, -4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4352, 4500), (3585, 4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3585, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4352, 4500), (3583, 4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3583, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4352, 4500), (0, 4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (0, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4352, 4500), (1, 4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (1, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4352, 4500), (-3584, 4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (-3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4352, 4500), (3584, 4096), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4096), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4352, 4500), (3584, 4094), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4094), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4352, 4500), (3584, 0), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 0), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4352, 4500), (3584, 1), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 1), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4352, 4500), (3584, -4095), (3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, -4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3501, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3501, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3499, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3499, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (0, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (0, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (1, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (1, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (-3500, 3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (-3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3584))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3584))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3582))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3582))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 0))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 0))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 1))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 1))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))",
      "mutated_line": "path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, -3583))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, -3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((257, 0), (512, 0), (512, 4096), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((257, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((255, 0), (512, 0), (512, 4096), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((255, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((0, 0), (512, 0), (512, 4096), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((0, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((1, 0), (512, 0), (512, 4096), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((1, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((-256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((-256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 1), (512, 0), (512, 4096), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 1), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, -1), (512, 0), (512, 4096), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, -1), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 1), (512, 0), (512, 4096), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 1), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (513, 0), (512, 4096), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (513, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (511, 0), (512, 4096), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (511, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (0, 0), (512, 4096), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (0, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (1, 0), (512, 4096), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (1, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (-512, 0), (512, 4096), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (-512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (512, 1), (512, 4096), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 1), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (512, -1), (512, 4096), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, -1), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (512, 1), (512, 4096), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 1), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (512, 0), (513, 4096), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (513, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (512, 0), (511, 4096), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (511, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (512, 0), (0, 4096), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (0, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (512, 0), (1, 4096), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (1, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (512, 0), (-512, 4096), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (-512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (512, 0), (512, 4097), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4097), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (512, 0), (512, 4095), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4095), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (512, 0), (512, 0), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 0), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (512, 0), (512, 1), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 1), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (512, 0), (512, -4096), (1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, -4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (512, 0), (512, 4096), (1025, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1025, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (512, 0), (512, 4096), (1023, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1023, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (512, 0), (512, 4096), (0, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (0, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (512, 0), (512, 4096), (1, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (512, 0), (512, 4096), (-1024, 4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (-1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4097))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4097))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4095))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4095))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 0))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 0))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 1))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 1))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))",
      "mutated_line": "span = ((256, 0), (512, 0), (512, 4096), (1024, -4096))",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, -4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "totals = [[0] * 8192 for _ in range(2)]",
      "mutated_line": "totals = [[0] * 8193 for _ in range(2)]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8193 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "totals = [[0] * 8192 for _ in range(2)]",
      "mutated_line": "totals = [[0] * 8191 for _ in range(2)]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8191 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "totals = [[0] * 8192 for _ in range(2)]",
      "mutated_line": "totals = [[0] * 0 for _ in range(2)]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 0 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "totals = [[0] * 8192 for _ in range(2)]",
      "mutated_line": "totals = [[0] * 1 for _ in range(2)]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 1 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "totals = [[0] * 8192 for _ in range(2)]",
      "mutated_line": "totals = [[0] * -8192 for _ in range(2)]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * -8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = [True] * ((n - 1) // 2)",
      "mutated_line": "x = [True] * ((n - 2) // 2)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 2) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = [True] * ((n - 1) // 2)",
      "mutated_line": "x = [True] * ((n - 0) // 2)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 0) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = [True] * ((n - 1) // 2)",
      "mutated_line": "x = [True] * ((n - 0) // 2)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 0) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "x = [True] * ((n - 1) // 2)",
      "mutated_line": "x = [True] * ((n - -1) // 2)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - -1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(int((sqrt(n) - 3) // 2) + 1):",
      "mutated_line": "for i in range(int((sqrt(n) - 3) / 2) + 1):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) / 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(int((sqrt(n) - 3) // 2) + 1):",
      "mutated_line": "for i in range(int((sqrt(n) - 3) * 2) + 1):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) * 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "mutated_line": "return [2] + [2 / i + 3 for (i, v) in enumerate(x) if v]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 / i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "mutated_line": "return [2] + [2 + i + 3 for (i, v) in enumerate(x) if v]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 + i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "mutated_line": "return [2] + [2 ** i + 3 for (i, v) in enumerate(x) if v]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 ** i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "mutated_line": "return [2] + [2 * i + 4 for (i, v) in enumerate(x) if v]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 4 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "mutated_line": "return [2] + [2 * i + 2 for (i, v) in enumerate(x) if v]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 2 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "mutated_line": "return [2] + [2 * i + 0 for (i, v) in enumerate(x) if v]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 0 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "mutated_line": "return [2] + [2 * i + 1 for (i, v) in enumerate(x) if v]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 1 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "mutated_line": "return [2] + [2 * i + -3 for (i, v) in enumerate(x) if v]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + -3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "totals = [[0] * 8192 for _ in range(2)]",
      "mutated_line": "totals = [[1] * 8192 for _ in range(2)]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[1] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "totals = [[0] * 8192 for _ in range(2)]",
      "mutated_line": "totals = [[-1] * 8192 for _ in range(2)]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[-1] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "totals = [[0] * 8192 for _ in range(2)]",
      "mutated_line": "totals = [[1] * 8192 for _ in range(2)]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[1] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "totals = [[0] * 8192 for _ in range(2)]",
      "mutated_line": "totals = [[0] * 8192 for _ in range(3)]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(3)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "totals = [[0] * 8192 for _ in range(2)]",
      "mutated_line": "totals = [[0] * 8192 for _ in range(1)]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(1)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "totals = [[0] * 8192 for _ in range(2)]",
      "mutated_line": "totals = [[0] * 8192 for _ in range(0)]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(0)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "totals = [[0] * 8192 for _ in range(2)]",
      "mutated_line": "totals = [[0] * 8192 for _ in range(1)]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(1)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "totals = [[0] * 8192 for _ in range(2)]",
      "mutated_line": "totals = [[0] * 8192 for _ in range(-2)]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(-2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "same = 1 + n // 2",
      "mutated_line": "same = 1 - n // 2",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 - n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "same = 1 + n // 2",
      "mutated_line": "same = 1 * (n // 2)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 * (n // 2)\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "change = (n + 1) // 2",
      "mutated_line": "change = (n + 1) / 2",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) / 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "change = (n + 1) // 2",
      "mutated_line": "change = (n + 1) * 2",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) * 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if totals[update][0] > 100000 * modulo:",
      "mutated_line": "if totals[update][0] >= 100000 * modulo:",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] >= 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if totals[update][0] > 100000 * modulo:",
      "mutated_line": "if totals[update][0] <= 100000 * modulo:",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] <= 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if totals[update][0] > 100000 * modulo:",
      "mutated_line": "if totals[update][0] != 100000 * modulo:",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] != 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(int((sqrt(n) - 3) // 2) + 1):",
      "mutated_line": "for i in range(int((sqrt(n) + 3) // 2) + 1):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) + 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(int((sqrt(n) - 3) // 2) + 1):",
      "mutated_line": "for i in range(int(sqrt(n) * 3 // 2) + 1):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int(sqrt(n) * 3 // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(int((sqrt(n) - 3) // 2) + 1):",
      "mutated_line": "for i in range(int((sqrt(n) - 3) // 3) + 1):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 3) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(int((sqrt(n) - 3) // 2) + 1):",
      "mutated_line": "for i in range(int((sqrt(n) - 3) // 1) + 1):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 1) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(int((sqrt(n) - 3) // 2) + 1):",
      "mutated_line": "for i in range(int((sqrt(n) - 3) // 0) + 1):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 0) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(int((sqrt(n) - 3) // 2) + 1):",
      "mutated_line": "for i in range(int((sqrt(n) - 3) // 1) + 1):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 1) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(int((sqrt(n) - 3) // 2) + 1):",
      "mutated_line": "for i in range(int((sqrt(n) - 3) // -2) + 1):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // -2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i - 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i - 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[(2 * i * i + 6 * i) * 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[(2 * i * i + 6 * i) * 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i - 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i - 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i * 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i * 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [True] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [True] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) - 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) - 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) * 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) * 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "mutated_line": "return [2] + [3 * i + 3 for (i, v) in enumerate(x) if v]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [3 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "mutated_line": "return [2] + [1 * i + 3 for (i, v) in enumerate(x) if v]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [1 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "mutated_line": "return [2] + [0 * i + 3 for (i, v) in enumerate(x) if v]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [0 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "mutated_line": "return [2] + [1 * i + 3 for (i, v) in enumerate(x) if v]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [1 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]",
      "mutated_line": "return [2] + [-2 * i + 3 for (i, v) in enumerate(x) if v]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [-2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for (j, n) in enumerate(count[p[0]:p[1] + 1]):",
      "mutated_line": "for (j, n) in enumerate(count[p[0]:p[1] - 1]):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] - 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for (j, n) in enumerate(count[p[0]:p[1] + 1]):",
      "mutated_line": "for (j, n) in enumerate(count[p[0]:p[1] * 1]):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] * 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "same = 1 + n // 2",
      "mutated_line": "same = 2 + n // 2",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 2 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "same = 1 + n // 2",
      "mutated_line": "same = 0 + n // 2",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 0 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "same = 1 + n // 2",
      "mutated_line": "same = 0 + n // 2",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 0 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "same = 1 + n // 2",
      "mutated_line": "same = -1 + n // 2",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = -1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "same = 1 + n // 2",
      "mutated_line": "same = 1 + n / 2",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n / 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "same = 1 + n // 2",
      "mutated_line": "same = 1 + n * 2",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n * 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "change = (n + 1) // 2",
      "mutated_line": "change = (n - 1) // 2",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n - 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "change = (n + 1) // 2",
      "mutated_line": "change = n * 1 // 2",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = n * 1 // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "change = (n + 1) // 2",
      "mutated_line": "change = (n + 1) // 3",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 3\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "change = (n + 1) // 2",
      "mutated_line": "change = (n + 1) // 1",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 1\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "change = (n + 1) // 2",
      "mutated_line": "change = (n + 1) // 0",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 0\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "change = (n + 1) // 2",
      "mutated_line": "change = (n + 1) // 1",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 1\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "change = (n + 1) // 2",
      "mutated_line": "change = (n + 1) // -2",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // -2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "o = span[i][1]",
      "mutated_line": "o = span[i][2]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][2]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "o = span[i][1]",
      "mutated_line": "o = span[i][0]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][0]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "o = span[i][1]",
      "mutated_line": "o = span[i][0]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][0]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "o = span[i][1]",
      "mutated_line": "o = span[i][-1]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][-1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "y = x ^ j + p[0]",
      "mutated_line": "y = x | j + p[0]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x | j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "totals[update][x] = totals[static][y] * change + totals[static][x] * same",
      "mutated_line": "totals[update][x] = totals[static][y] * change - totals[static][x] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change - totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "totals[update][x] = totals[static][y] * change + totals[static][x] * same",
      "mutated_line": "totals[update][x] = totals[static][y] * change * (totals[static][x] * same)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change * (totals[static][x] * same)\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "totals[update][y] = totals[static][x] * change + totals[static][y] * same",
      "mutated_line": "totals[update][y] = totals[static][x] * change - totals[static][y] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change - totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "totals[update][y] = totals[static][x] * change + totals[static][y] * same",
      "mutated_line": "totals[update][y] = totals[static][x] * change * (totals[static][y] * same)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change * (totals[static][y] * same)\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if totals[update][0] > 100000 * modulo:",
      "mutated_line": "if totals[update][0] > 100000 / modulo:",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 / modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if totals[update][0] > 100000 * modulo:",
      "mutated_line": "if totals[update][0] > 100000 + modulo:",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 + modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if totals[update][0] > 100000 * modulo:",
      "mutated_line": "if totals[update][0] > 100000 ** modulo:",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 ** modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(int((sqrt(n) - 3) // 2) + 1):",
      "mutated_line": "for i in range(int((sqrt(n) - 4) // 2) + 1):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 4) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(int((sqrt(n) - 3) // 2) + 1):",
      "mutated_line": "for i in range(int((sqrt(n) - 2) // 2) + 1):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 2) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(int((sqrt(n) - 3) // 2) + 1):",
      "mutated_line": "for i in range(int((sqrt(n) - 0) // 2) + 1):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 0) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(int((sqrt(n) - 3) // 2) + 1):",
      "mutated_line": "for i in range(int((sqrt(n) - 1) // 2) + 1):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 1) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(int((sqrt(n) - 3) // 2) + 1):",
      "mutated_line": "for i in range(int((sqrt(n) - -3) // 2) + 1):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - -3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i - 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i - 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i * (6 * i) + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i * (6 * i) + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 4::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 4::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 2::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 2::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 0::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 0::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 1::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 1::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + -3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + -3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 / i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 / i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 + i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 + i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 ** i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 ** i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 4] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 4] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 2] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 2] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 0] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 0] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 1] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 1] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + -3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + -3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) / (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) / (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) * (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) * (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 2)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 2)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 0)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 0)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 0)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 0)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + -1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + -1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (j, n) in enumerate(count[p[0]:p[1] + 1]):",
      "mutated_line": "for (j, n) in enumerate(count[p[1]:p[1] + 1]):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[1]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (j, n) in enumerate(count[p[0]:p[1] + 1]):",
      "mutated_line": "for (j, n) in enumerate(count[p[-1]:p[1] + 1]):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[-1]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (j, n) in enumerate(count[p[0]:p[1] + 1]):",
      "mutated_line": "for (j, n) in enumerate(count[p[1]:p[1] + 1]):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[1]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (j, n) in enumerate(count[p[0]:p[1] + 1]):",
      "mutated_line": "for (j, n) in enumerate(count[p[0]:p[1] + 2]):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 2]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (j, n) in enumerate(count[p[0]:p[1] + 1]):",
      "mutated_line": "for (j, n) in enumerate(count[p[0]:p[1] + 0]):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 0]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (j, n) in enumerate(count[p[0]:p[1] + 1]):",
      "mutated_line": "for (j, n) in enumerate(count[p[0]:p[1] + 0]):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 0]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (j, n) in enumerate(count[p[0]:p[1] + 1]):",
      "mutated_line": "for (j, n) in enumerate(count[p[0]:p[1] + -1]):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + -1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "same = 1 + n // 2",
      "mutated_line": "same = 1 + n // 3",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 3\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "same = 1 + n // 2",
      "mutated_line": "same = 1 + n // 1",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 1\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "same = 1 + n // 2",
      "mutated_line": "same = 1 + n // 0",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 0\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "same = 1 + n // 2",
      "mutated_line": "same = 1 + n // 1",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 1\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "same = 1 + n // 2",
      "mutated_line": "same = 1 + n // -2",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // -2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "change = (n + 1) // 2",
      "mutated_line": "change = (n + 2) // 2",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 2) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "change = (n + 1) // 2",
      "mutated_line": "change = (n + 0) // 2",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 0) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "change = (n + 1) // 2",
      "mutated_line": "change = (n + 0) // 2",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 0) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "change = (n + 1) // 2",
      "mutated_line": "change = (n + -1) // 2",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + -1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for x in range(span[i][0]):",
      "mutated_line": "for x in range(span[i][1]):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][1]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for x in range(span[i][0]):",
      "mutated_line": "for x in range(span[i][-1]):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][-1]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for x in range(span[i][0]):",
      "mutated_line": "for x in range(span[i][1]):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][1]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "y = x ^ j + p[0]",
      "mutated_line": "y = x ^ j - p[0]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j - p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "y = x ^ j + p[0]",
      "mutated_line": "y = x ^ j * p[0]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j * p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "totals[update][x] = totals[static][y] * change + totals[static][x] * same",
      "mutated_line": "totals[update][x] = totals[static][y] / change + totals[static][x] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] / change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "totals[update][x] = totals[static][y] * change + totals[static][x] * same",
      "mutated_line": "totals[update][x] = totals[static][y] + change + totals[static][x] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] + change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "totals[update][x] = totals[static][y] * change + totals[static][x] * same",
      "mutated_line": "totals[update][x] = totals[static][y] ** change + totals[static][x] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] ** change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "totals[update][x] = totals[static][y] * change + totals[static][x] * same",
      "mutated_line": "totals[update][x] = totals[static][y] * change + totals[static][x] / same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] / same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "totals[update][x] = totals[static][y] * change + totals[static][x] * same",
      "mutated_line": "totals[update][x] = totals[static][y] * change + (totals[static][x] + same)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + (totals[static][x] + same)\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "totals[update][x] = totals[static][y] * change + totals[static][x] * same",
      "mutated_line": "totals[update][x] = totals[static][y] * change + totals[static][x] ** same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] ** same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "totals[update][y] = totals[static][x] * change + totals[static][y] * same",
      "mutated_line": "totals[update][y] = totals[static][x] / change + totals[static][y] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] / change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "totals[update][y] = totals[static][x] * change + totals[static][y] * same",
      "mutated_line": "totals[update][y] = totals[static][x] + change + totals[static][y] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] + change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "totals[update][y] = totals[static][x] * change + totals[static][y] * same",
      "mutated_line": "totals[update][y] = totals[static][x] ** change + totals[static][y] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] ** change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "totals[update][y] = totals[static][x] * change + totals[static][y] * same",
      "mutated_line": "totals[update][y] = totals[static][x] * change + totals[static][y] / same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] / same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "totals[update][y] = totals[static][x] * change + totals[static][y] * same",
      "mutated_line": "totals[update][y] = totals[static][x] * change + (totals[static][y] + same)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + (totals[static][y] + same)\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "totals[update][y] = totals[static][x] * change + totals[static][y] * same",
      "mutated_line": "totals[update][y] = totals[static][x] * change + totals[static][y] ** same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] ** same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same",
      "mutated_line": "totals[update][x + o] = totals[static][y + o] * change - totals[static][x + o] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change - totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same",
      "mutated_line": "totals[update][x + o] = totals[static][y + o] * change * (totals[static][x + o] * same)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change * (totals[static][x + o] * same)\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same",
      "mutated_line": "totals[update][y + o] = totals[static][x + o] * change - totals[static][y + o] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change - totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same",
      "mutated_line": "totals[update][y + o] = totals[static][x + o] * change * (totals[static][y + o] * same)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change * (totals[static][y + o] * same)\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if totals[update][0] > 100000 * modulo:",
      "mutated_line": "if totals[update][1] > 100000 * modulo:",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][1] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if totals[update][0] > 100000 * modulo:",
      "mutated_line": "if totals[update][-1] > 100000 * modulo:",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][-1] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if totals[update][0] > 100000 * modulo:",
      "mutated_line": "if totals[update][1] > 100000 * modulo:",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][1] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if totals[update][0] > 100000 * modulo:",
      "mutated_line": "if totals[update][0] > 100001 * modulo:",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100001 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if totals[update][0] > 100000 * modulo:",
      "mutated_line": "if totals[update][0] > 99999 * modulo:",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 99999 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if totals[update][0] > 100000 * modulo:",
      "mutated_line": "if totals[update][0] > 0 * modulo:",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 0 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if totals[update][0] > 100000 * modulo:",
      "mutated_line": "if totals[update][0] > 1 * modulo:",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 1 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if totals[update][0] > 100000 * modulo:",
      "mutated_line": "if totals[update][0] > -100000 * modulo:",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > -100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i / i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i / i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i + i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i + i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[(2 * i) ** i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[(2 * i) ** i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 / i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 / i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + (6 + i) + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + (6 + i) + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 ** i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 ** i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::3 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::3 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::1 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::1 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::0 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::0 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::1 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::1 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::-2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::-2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n + (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n + (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int(n * (2 * i + 3) ** 2 // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int(n * (2 * i + 3) ** 2 // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i - 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i - 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i * 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i * 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (j, n) in enumerate(count[p[0]:p[1] + 1]):",
      "mutated_line": "for (j, n) in enumerate(count[p[0]:p[2] + 1]):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[2] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (j, n) in enumerate(count[p[0]:p[1] + 1]):",
      "mutated_line": "for (j, n) in enumerate(count[p[0]:p[0] + 1]):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[0] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (j, n) in enumerate(count[p[0]:p[1] + 1]):",
      "mutated_line": "for (j, n) in enumerate(count[p[0]:p[0] + 1]):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[0] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (j, n) in enumerate(count[p[0]:p[1] + 1]):",
      "mutated_line": "for (j, n) in enumerate(count[p[0]:p[-1] + 1]):",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[-1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same",
      "mutated_line": "totals[update][x - o] = totals[static][y + o] * change + totals[static][x + o] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x - o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same",
      "mutated_line": "totals[update][x * o] = totals[static][y + o] * change + totals[static][x + o] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x * o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same",
      "mutated_line": "totals[update][x + o] = totals[static][y + o] / change + totals[static][x + o] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] / change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same",
      "mutated_line": "totals[update][x + o] = totals[static][y + o] + change + totals[static][x + o] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] + change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same",
      "mutated_line": "totals[update][x + o] = totals[static][y + o] ** change + totals[static][x + o] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] ** change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same",
      "mutated_line": "totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] / same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] / same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same",
      "mutated_line": "totals[update][x + o] = totals[static][y + o] * change + (totals[static][x + o] + same)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + (totals[static][x + o] + same)\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same",
      "mutated_line": "totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] ** same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] ** same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same",
      "mutated_line": "totals[update][y - o] = totals[static][x + o] * change + totals[static][y + o] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y - o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same",
      "mutated_line": "totals[update][y * o] = totals[static][x + o] * change + totals[static][y + o] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y * o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same",
      "mutated_line": "totals[update][y + o] = totals[static][x + o] / change + totals[static][y + o] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] / change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same",
      "mutated_line": "totals[update][y + o] = totals[static][x + o] + change + totals[static][y + o] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] + change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same",
      "mutated_line": "totals[update][y + o] = totals[static][x + o] ** change + totals[static][y + o] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] ** change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same",
      "mutated_line": "totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] / same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] / same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same",
      "mutated_line": "totals[update][y + o] = totals[static][x + o] * change + (totals[static][y + o] + same)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + (totals[static][y + o] + same)\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same",
      "mutated_line": "totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] ** same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] ** same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 / i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 / i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[(2 + i) * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[(2 + i) * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 ** i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 ** i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 7 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 7 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 5 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 5 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 0 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 0 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 1 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 1 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + -6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + -6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) * 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) * 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3 + 2)) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3 + 2)) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 / i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 / i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 + i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 + i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 ** i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 ** i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 7) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 7) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 5) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 5) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 0) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 0) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 1) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 1) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + -6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + -6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "y = x ^ j + p[0]",
      "mutated_line": "y = x ^ j + p[1]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[1]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "y = x ^ j + p[0]",
      "mutated_line": "y = x ^ j + p[-1]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[-1]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "y = x ^ j + p[0]",
      "mutated_line": "y = x ^ j + p[1]",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[1]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[3 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[3 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[1 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[1 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[0 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[0 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[1 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[1 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[-2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[-2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i - 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i - 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i * 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i * 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 3) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 3) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 1) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 1) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 0) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 0) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 1) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 1) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** -2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** -2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (5 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (5 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (3 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (3 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (0 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (0 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (1 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (1 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (-4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (-4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same",
      "mutated_line": "totals[update][x + o] = totals[static][y - o] * change + totals[static][x + o] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y - o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same",
      "mutated_line": "totals[update][x + o] = totals[static][y * o] * change + totals[static][x + o] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y * o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same",
      "mutated_line": "totals[update][x + o] = totals[static][y + o] * change + totals[static][x - o] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x - o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same",
      "mutated_line": "totals[update][x + o] = totals[static][y + o] * change + totals[static][x * o] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x * o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same",
      "mutated_line": "totals[update][y + o] = totals[static][x - o] * change + totals[static][y + o] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x - o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same",
      "mutated_line": "totals[update][y + o] = totals[static][x * o] * change + totals[static][y + o] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x * o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same",
      "mutated_line": "totals[update][y + o] = totals[static][x + o] * change + totals[static][y - o] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y - o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same",
      "mutated_line": "totals[update][y + o] = totals[static][x + o] * change + totals[static][y * o] * same",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y * o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 / i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 / i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 + i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 + i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 ** i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 ** i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 4) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 4) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 2) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 2) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 0) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 0) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 1) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 1) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + -3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + -3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (3 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (3 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (1 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (1 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (0 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (0 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (1 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (1 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "mutated_line": "x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (-2 * i + 3) ** 2) // (4 * i + 6) + 1)",
      "code": "from collections import Counter\nfrom math import sqrt\n\ndef primes(n):\n    x = [True] * ((n - 1) // 2)\n    for i in range(int((sqrt(n) - 3) // 2) + 1):\n        if x[i]:\n            x[2 * i * i + 6 * i + 3::2 * i + 3] = [False] * int((n - (-2 * i + 3) ** 2) // (4 * i + 6) + 1)\n    return [2] + [2 * i + 3 for (i, v) in enumerate(x) if v]\n\ndef count_prime_xor_multisets(numbers, modulo=10 ** 9 + 7):\n    counts = Counter(numbers).items()\n    count = [0] * 4501\n    for (i, n) in counts:\n        count[i] = n\n    path = ((4096, 4351), (4352, 4500), (3584, 4095), (3500, 3583))\n    span = ((256, 0), (512, 0), (512, 4096), (1024, 4096))\n    totals = [[0] * 8192 for _ in range(2)]\n    (static, update) = (0, 1)\n    totals[static][0] = 1\n    for (i, p) in enumerate(path):\n        for (j, n) in enumerate(count[p[0]:p[1] + 1]):\n            if n:\n                same = 1 + n // 2\n                change = (n + 1) // 2\n                o = span[i][1]\n                for x in range(span[i][0]):\n                    y = x ^ j + p[0]\n                    totals[update][x] = totals[static][y] * change + totals[static][x] * same\n                    totals[update][y] = totals[static][x] * change + totals[static][y] * same\n                    if o:\n                        totals[update][x + o] = totals[static][y + o] * change + totals[static][x + o] * same\n                        totals[update][y + o] = totals[static][x + o] * change + totals[static][y + o] * same\n                if totals[update][0] > 100000 * modulo:\n                    for x in range(len(totals[update])):\n                        totals[update][x] %= modulo\n                (static, update) = (update, static)\n    p = primes(8191)\n    total = 0\n    for prime in p:\n        total += totals[static][prime]\n    return total % modulo"
    }
  ]
}