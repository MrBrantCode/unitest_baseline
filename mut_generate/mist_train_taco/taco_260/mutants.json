{
  "task_id": "taco_260",
  "entry_point": "count_bear_configurations",
  "mutant_count": 242,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 - 7",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 - 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 * 7",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 * 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 * 9 + 7",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 * 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 + 9 + 7",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 + 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 8\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 6",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 6\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 0\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 1\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + -7",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + -7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "LCR",
      "lineno": 5,
      "original_line": "if i > 0 and not visited[i - 1][j]:",
      "mutated_line": "if i > 0 or not visited[i - 1][j]:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 or not visited[i - 1][j]:\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "if i < N - 1 and not visited[i + 1][j]:",
      "mutated_line": "if i < N - 1 or not visited[i + 1][j]:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 or not visited[i + 1][j]:\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "if j > 0 and not visited[i][j - 1]:",
      "mutated_line": "if j > 0 or not visited[i][j - 1]:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 or not visited[i][j - 1]:\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if j < N - 1 and not visited[i][j + 1]:",
      "mutated_line": "if j < N - 1 or not visited[i][j + 1]:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 or not visited[i][j + 1]:\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans = 1",
      "mutated_line": "ans = 2",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 2\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans = 1",
      "mutated_line": "ans = 0",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 0\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans = 1",
      "mutated_line": "ans = 0",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 0\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ans = 1",
      "mutated_line": "ans = -1",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = -1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return ans % MOD",
      "mutated_line": "return ans * MOD",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans * MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "return ans % MOD",
      "mutated_line": "return ans + MOD",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans + MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 11 ** 9 + 7",
      "code": "def count_bear_configurations(N, land):\n    MOD = 11 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 9 ** 9 + 7",
      "code": "def count_bear_configurations(N, land):\n    MOD = 9 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 0 ** 9 + 7",
      "code": "def count_bear_configurations(N, land):\n    MOD = 0 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 1 ** 9 + 7",
      "code": "def count_bear_configurations(N, land):\n    MOD = 1 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = -10 ** 9 + 7",
      "code": "def count_bear_configurations(N, land):\n    MOD = -10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 10 + 7",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 10 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 8 + 7",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 8 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 0 + 7",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 0 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 1 + 7",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 1 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** -9 + 7",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** -9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i > 0 and not visited[i - 1][j]:",
      "mutated_line": "if i >= 0 and (not visited[i - 1][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i >= 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i > 0 and not visited[i - 1][j]:",
      "mutated_line": "if i <= 0 and (not visited[i - 1][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i <= 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if i > 0 and not visited[i - 1][j]:",
      "mutated_line": "if i != 0 and (not visited[i - 1][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i != 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[i - 1][j] = True",
      "mutated_line": "visited[i - 1][j] = False",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = False\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if i < N - 1 and not visited[i + 1][j]:",
      "mutated_line": "if i <= N - 1 and (not visited[i + 1][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i <= N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if i < N - 1 and not visited[i + 1][j]:",
      "mutated_line": "if i >= N - 1 and (not visited[i + 1][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i >= N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if i < N - 1 and not visited[i + 1][j]:",
      "mutated_line": "if i != N - 1 and (not visited[i + 1][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i != N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited[i + 1][j] = True",
      "mutated_line": "visited[i + 1][j] = False",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = False\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if j > 0 and not visited[i][j - 1]:",
      "mutated_line": "if j >= 0 and (not visited[i][j - 1]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j >= 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if j > 0 and not visited[i][j - 1]:",
      "mutated_line": "if j <= 0 and (not visited[i][j - 1]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j <= 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if j > 0 and not visited[i][j - 1]:",
      "mutated_line": "if j != 0 and (not visited[i][j - 1]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j != 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited[i][j - 1] = True",
      "mutated_line": "visited[i][j - 1] = False",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = False\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if j < N - 1 and not visited[i][j + 1]:",
      "mutated_line": "if j <= N - 1 and (not visited[i][j + 1]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j <= N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if j < N - 1 and not visited[i][j + 1]:",
      "mutated_line": "if j >= N - 1 and (not visited[i][j + 1]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j >= N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if j < N - 1 and not visited[i][j + 1]:",
      "mutated_line": "if j != N - 1 and (not visited[i][j + 1]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j != N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited[i][j + 1] = True",
      "mutated_line": "visited[i][j + 1] = False",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = False\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "if len(i) == 1 and i == ['?']:",
      "mutated_line": "if len(i) == 1 or i == ['?']:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 or i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if i > 0 and not visited[i - 1][j]:",
      "mutated_line": "if i > 1 and (not visited[i - 1][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 1 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if i > 0 and not visited[i - 1][j]:",
      "mutated_line": "if i > -1 and (not visited[i - 1][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > -1 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if i > 0 and not visited[i - 1][j]:",
      "mutated_line": "if i > 1 and (not visited[i - 1][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 1 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "find_connections(i - 1, j, visited, connections)",
      "mutated_line": "find_connections(i + 1, j, visited, connections)",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "find_connections(i - 1, j, visited, connections)",
      "mutated_line": "find_connections(i * 1, j, visited, connections)",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i * 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if i < N - 1 and not visited[i + 1][j]:",
      "mutated_line": "if i < N + 1 and (not visited[i + 1][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N + 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if i < N - 1 and not visited[i + 1][j]:",
      "mutated_line": "if i < N * 1 and (not visited[i + 1][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N * 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "find_connections(i + 1, j, visited, connections)",
      "mutated_line": "find_connections(i - 1, j, visited, connections)",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "find_connections(i + 1, j, visited, connections)",
      "mutated_line": "find_connections(i * 1, j, visited, connections)",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i * 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if j > 0 and not visited[i][j - 1]:",
      "mutated_line": "if j > 1 and (not visited[i][j - 1]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 1 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if j > 0 and not visited[i][j - 1]:",
      "mutated_line": "if j > -1 and (not visited[i][j - 1]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > -1 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if j > 0 and not visited[i][j - 1]:",
      "mutated_line": "if j > 1 and (not visited[i][j - 1]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 1 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "visited[i][j - 1] = True",
      "mutated_line": "visited[i][j + 1] = True",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j + 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "visited[i][j - 1] = True",
      "mutated_line": "visited[i][j * 1] = True",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j * 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "find_connections(i, j - 1, visited, connections)",
      "mutated_line": "find_connections(i, j + 1, visited, connections)",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j + 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "find_connections(i, j - 1, visited, connections)",
      "mutated_line": "find_connections(i, j * 1, visited, connections)",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j * 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if j < N - 1 and not visited[i][j + 1]:",
      "mutated_line": "if j < N + 1 and (not visited[i][j + 1]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N + 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if j < N - 1 and not visited[i][j + 1]:",
      "mutated_line": "if j < N * 1 and (not visited[i][j + 1]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N * 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "visited[i][j + 1] = True",
      "mutated_line": "visited[i][j - 1] = True",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j - 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "visited[i][j + 1] = True",
      "mutated_line": "visited[i][j * 1] = True",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j * 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "find_connections(i, j + 1, visited, connections)",
      "mutated_line": "find_connections(i, j - 1, visited, connections)",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j - 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "find_connections(i, j + 1, visited, connections)",
      "mutated_line": "find_connections(i, j * 1, visited, connections)",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j * 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if len(i) == 1 and i == ['?']:",
      "mutated_line": "if len(i) != 1 and i == ['?']:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) != 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if len(i) == 1 and i == ['?']:",
      "mutated_line": "if len(i) == 1 and i != ['?']:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i != ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = ans % MOD * 3",
      "mutated_line": "ans = ans % MOD / 3",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD / 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = ans % MOD * 3",
      "mutated_line": "ans = ans % MOD + 3",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD + 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = ans % MOD * 3",
      "mutated_line": "ans = (ans % MOD) ** 3",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = (ans % MOD) ** 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "elif len(i) > 1:",
      "mutated_line": "elif len(i) >= 1:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) >= 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "elif len(i) > 1:",
      "mutated_line": "elif len(i) <= 1:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) <= 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "elif len(i) > 1:",
      "mutated_line": "elif len(i) != 1:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) != 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]",
      "mutated_line": "visited = [[True if land[i][j] != '.' else False for j in range(N)] for i in range(N)]",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] != '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]",
      "mutated_line": "visited = [[False if land[i][j] == '.' else False for j in range(N)] for i in range(N)]",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[False if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]",
      "mutated_line": "visited = [[True if land[i][j] == '.' else True for j in range(N)] for i in range(N)]",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else True for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "visited[i][j] = True",
      "mutated_line": "visited[i][j] = False",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = False\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "visited[i - 1][j] = True",
      "mutated_line": "visited[i + 1][j] = True",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i + 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "visited[i - 1][j] = True",
      "mutated_line": "visited[i * 1][j] = True",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i * 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "find_connections(i - 1, j, visited, connections)",
      "mutated_line": "find_connections(i - 2, j, visited, connections)",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 2, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "find_connections(i - 1, j, visited, connections)",
      "mutated_line": "find_connections(i - 0, j, visited, connections)",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 0, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "find_connections(i - 1, j, visited, connections)",
      "mutated_line": "find_connections(i - 0, j, visited, connections)",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 0, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "find_connections(i - 1, j, visited, connections)",
      "mutated_line": "find_connections(i - -1, j, visited, connections)",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - -1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if i < N - 1 and not visited[i + 1][j]:",
      "mutated_line": "if i < N - 2 and (not visited[i + 1][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 2 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if i < N - 1 and not visited[i + 1][j]:",
      "mutated_line": "if i < N - 0 and (not visited[i + 1][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 0 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if i < N - 1 and not visited[i + 1][j]:",
      "mutated_line": "if i < N - 0 and (not visited[i + 1][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 0 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if i < N - 1 and not visited[i + 1][j]:",
      "mutated_line": "if i < N - -1 and (not visited[i + 1][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - -1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "visited[i + 1][j] = True",
      "mutated_line": "visited[i - 1][j] = True",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i - 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "visited[i + 1][j] = True",
      "mutated_line": "visited[i * 1][j] = True",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i * 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "find_connections(i + 1, j, visited, connections)",
      "mutated_line": "find_connections(i + 2, j, visited, connections)",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 2, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "find_connections(i + 1, j, visited, connections)",
      "mutated_line": "find_connections(i + 0, j, visited, connections)",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 0, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "find_connections(i + 1, j, visited, connections)",
      "mutated_line": "find_connections(i + 0, j, visited, connections)",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 0, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "find_connections(i + 1, j, visited, connections)",
      "mutated_line": "find_connections(i + -1, j, visited, connections)",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + -1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if j > 0 and not visited[i][j - 1]:",
      "mutated_line": "if j > 0 and (not visited[i][j + 1]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if j > 0 and not visited[i][j - 1]:",
      "mutated_line": "if j > 0 and (not visited[i][j * 1]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j * 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "connections[-1].append(land[i][j - 1])",
      "mutated_line": "connections[-1].append(land[i][j + 1])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "connections[-1].append(land[i][j - 1])",
      "mutated_line": "connections[-1].append(land[i][j * 1])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j * 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited[i][j - 1] = True",
      "mutated_line": "visited[i][j - 2] = True",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 2] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited[i][j - 1] = True",
      "mutated_line": "visited[i][j - 0] = True",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 0] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited[i][j - 1] = True",
      "mutated_line": "visited[i][j - 0] = True",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 0] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited[i][j - 1] = True",
      "mutated_line": "visited[i][j - -1] = True",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - -1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "find_connections(i, j - 1, visited, connections)",
      "mutated_line": "find_connections(i, j - 2, visited, connections)",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 2, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "find_connections(i, j - 1, visited, connections)",
      "mutated_line": "find_connections(i, j - 0, visited, connections)",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 0, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "find_connections(i, j - 1, visited, connections)",
      "mutated_line": "find_connections(i, j - 0, visited, connections)",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 0, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "find_connections(i, j - 1, visited, connections)",
      "mutated_line": "find_connections(i, j - -1, visited, connections)",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - -1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if j < N - 1 and not visited[i][j + 1]:",
      "mutated_line": "if j < N - 2 and (not visited[i][j + 1]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 2 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if j < N - 1 and not visited[i][j + 1]:",
      "mutated_line": "if j < N - 0 and (not visited[i][j + 1]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 0 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if j < N - 1 and not visited[i][j + 1]:",
      "mutated_line": "if j < N - 0 and (not visited[i][j + 1]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 0 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if j < N - 1 and not visited[i][j + 1]:",
      "mutated_line": "if j < N - -1 and (not visited[i][j + 1]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - -1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if j < N - 1 and not visited[i][j + 1]:",
      "mutated_line": "if j < N - 1 and (not visited[i][j - 1]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if j < N - 1 and not visited[i][j + 1]:",
      "mutated_line": "if j < N - 1 and (not visited[i][j * 1]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j * 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "connections[-1].append(land[i][j + 1])",
      "mutated_line": "connections[-1].append(land[i][j - 1])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "connections[-1].append(land[i][j + 1])",
      "mutated_line": "connections[-1].append(land[i][j * 1])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j * 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited[i][j + 1] = True",
      "mutated_line": "visited[i][j + 2] = True",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 2] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited[i][j + 1] = True",
      "mutated_line": "visited[i][j + 0] = True",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 0] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited[i][j + 1] = True",
      "mutated_line": "visited[i][j + 0] = True",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 0] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited[i][j + 1] = True",
      "mutated_line": "visited[i][j + -1] = True",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + -1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "find_connections(i, j + 1, visited, connections)",
      "mutated_line": "find_connections(i, j + 2, visited, connections)",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 2, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "find_connections(i, j + 1, visited, connections)",
      "mutated_line": "find_connections(i, j + 0, visited, connections)",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 0, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "find_connections(i, j + 1, visited, connections)",
      "mutated_line": "find_connections(i, j + 0, visited, connections)",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 0, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "find_connections(i, j + 1, visited, connections)",
      "mutated_line": "find_connections(i, j + -1, visited, connections)",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + -1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if len(i) == 1 and i == ['?']:",
      "mutated_line": "if len(i) == 2 and i == ['?']:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 2 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if len(i) == 1 and i == ['?']:",
      "mutated_line": "if len(i) == 0 and i == ['?']:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 0 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if len(i) == 1 and i == ['?']:",
      "mutated_line": "if len(i) == 0 and i == ['?']:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 0 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if len(i) == 1 and i == ['?']:",
      "mutated_line": "if len(i) == -1 and i == ['?']:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == -1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = ans % MOD * 3",
      "mutated_line": "ans = ans * MOD * 3",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans * MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans = ans % MOD * 3",
      "mutated_line": "ans = (ans + MOD) * 3",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = (ans + MOD) * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = ans % MOD * 3",
      "mutated_line": "ans = ans % MOD * 4",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 4\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = ans % MOD * 3",
      "mutated_line": "ans = ans % MOD * 2",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 2\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = ans % MOD * 3",
      "mutated_line": "ans = ans % MOD * 0",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 0\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = ans % MOD * 3",
      "mutated_line": "ans = ans % MOD * 1",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 1\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans = ans % MOD * 3",
      "mutated_line": "ans = ans % MOD * -3",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * -3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif len(i) > 1:",
      "mutated_line": "elif len(i) > 2:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 2:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif len(i) > 1:",
      "mutated_line": "elif len(i) > 0:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 0:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif len(i) > 1:",
      "mutated_line": "elif len(i) > 0:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 0:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif len(i) > 1:",
      "mutated_line": "elif len(i) > -1:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > -1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if 'G' in i:",
      "mutated_line": "if 'G' not in i:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' not in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]",
      "mutated_line": "visited = [[True if land[i][j] == '' else False for j in range(N)] for i in range(N)]",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if i > 0 and not visited[i - 1][j]:",
      "mutated_line": "if i > 0 and (not visited[i + 1][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i + 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "if i > 0 and not visited[i - 1][j]:",
      "mutated_line": "if i > 0 and (not visited[i * 1][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i * 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "connections[-1].append(land[i - 1][j])",
      "mutated_line": "connections[+1].append(land[i - 1][j])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[+1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "connections[-1].append(land[i - 1][j])",
      "mutated_line": "connections[-1].append(land[i + 1][j])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "connections[-1].append(land[i - 1][j])",
      "mutated_line": "connections[-1].append(land[i * 1][j])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i * 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[i - 1][j] = True",
      "mutated_line": "visited[i - 2][j] = True",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 2][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[i - 1][j] = True",
      "mutated_line": "visited[i - 0][j] = True",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 0][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[i - 1][j] = True",
      "mutated_line": "visited[i - 0][j] = True",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 0][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visited[i - 1][j] = True",
      "mutated_line": "visited[i - -1][j] = True",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - -1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if i < N - 1 and not visited[i + 1][j]:",
      "mutated_line": "if i < N - 1 and (not visited[i - 1][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i - 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if i < N - 1 and not visited[i + 1][j]:",
      "mutated_line": "if i < N - 1 and (not visited[i * 1][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i * 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "connections[-1].append(land[i + 1][j])",
      "mutated_line": "connections[+1].append(land[i + 1][j])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[+1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "connections[-1].append(land[i + 1][j])",
      "mutated_line": "connections[-1].append(land[i - 1][j])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "connections[-1].append(land[i + 1][j])",
      "mutated_line": "connections[-1].append(land[i * 1][j])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i * 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited[i + 1][j] = True",
      "mutated_line": "visited[i + 2][j] = True",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 2][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited[i + 1][j] = True",
      "mutated_line": "visited[i + 0][j] = True",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 0][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited[i + 1][j] = True",
      "mutated_line": "visited[i + 0][j] = True",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 0][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited[i + 1][j] = True",
      "mutated_line": "visited[i + -1][j] = True",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + -1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if j > 0 and not visited[i][j - 1]:",
      "mutated_line": "if j > 0 and (not visited[i][j - 2]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 2]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if j > 0 and not visited[i][j - 1]:",
      "mutated_line": "if j > 0 and (not visited[i][j - 0]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 0]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if j > 0 and not visited[i][j - 1]:",
      "mutated_line": "if j > 0 and (not visited[i][j - 0]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 0]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if j > 0 and not visited[i][j - 1]:",
      "mutated_line": "if j > 0 and (not visited[i][j - -1]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - -1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "connections[-1].append(land[i][j - 1])",
      "mutated_line": "connections[+1].append(land[i][j - 1])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[+1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "connections[-1].append(land[i][j - 1])",
      "mutated_line": "connections[-1].append(land[i][j - 2])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 2])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "connections[-1].append(land[i][j - 1])",
      "mutated_line": "connections[-1].append(land[i][j - 0])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 0])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "connections[-1].append(land[i][j - 1])",
      "mutated_line": "connections[-1].append(land[i][j - 0])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 0])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "connections[-1].append(land[i][j - 1])",
      "mutated_line": "connections[-1].append(land[i][j - -1])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - -1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if j < N - 1 and not visited[i][j + 1]:",
      "mutated_line": "if j < N - 1 and (not visited[i][j + 2]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 2]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if j < N - 1 and not visited[i][j + 1]:",
      "mutated_line": "if j < N - 1 and (not visited[i][j + 0]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 0]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if j < N - 1 and not visited[i][j + 1]:",
      "mutated_line": "if j < N - 1 and (not visited[i][j + 0]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 0]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if j < N - 1 and not visited[i][j + 1]:",
      "mutated_line": "if j < N - 1 and (not visited[i][j + -1]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + -1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "connections[-1].append(land[i][j + 1])",
      "mutated_line": "connections[+1].append(land[i][j + 1])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[+1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "connections[-1].append(land[i][j + 1])",
      "mutated_line": "connections[-1].append(land[i][j + 2])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 2])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "connections[-1].append(land[i][j + 1])",
      "mutated_line": "connections[-1].append(land[i][j + 0])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 0])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "connections[-1].append(land[i][j + 1])",
      "mutated_line": "connections[-1].append(land[i][j + 0])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 0])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "connections[-1].append(land[i][j + 1])",
      "mutated_line": "connections[-1].append(land[i][j + -1])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + -1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if len(i) == 1 and i == ['?']:",
      "mutated_line": "if len(i) == 1 and i == ['']:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if 'G' in i:",
      "mutated_line": "if '' in i:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if '' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 1\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = -1\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 1\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "LCR",
      "lineno": 31,
      "original_line": "elif 'B' in i and 'P' in i:",
      "mutated_line": "elif 'B' in i or 'P' in i:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if i > 0 and not visited[i - 1][j]:",
      "mutated_line": "if i > 0 and (not visited[i - 2][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 2][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if i > 0 and not visited[i - 1][j]:",
      "mutated_line": "if i > 0 and (not visited[i - 0][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 0][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if i > 0 and not visited[i - 1][j]:",
      "mutated_line": "if i > 0 and (not visited[i - 0][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 0][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if i > 0 and not visited[i - 1][j]:",
      "mutated_line": "if i > 0 and (not visited[i - -1][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - -1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "connections[-1].append(land[i - 1][j])",
      "mutated_line": "connections[-2].append(land[i - 1][j])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-2].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "connections[-1].append(land[i - 1][j])",
      "mutated_line": "connections[-0].append(land[i - 1][j])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-0].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "connections[-1].append(land[i - 1][j])",
      "mutated_line": "connections[-0].append(land[i - 1][j])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-0].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "connections[-1].append(land[i - 1][j])",
      "mutated_line": "connections[--1].append(land[i - 1][j])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[--1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "connections[-1].append(land[i - 1][j])",
      "mutated_line": "connections[-1].append(land[i - 2][j])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 2][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "connections[-1].append(land[i - 1][j])",
      "mutated_line": "connections[-1].append(land[i - 0][j])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 0][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "connections[-1].append(land[i - 1][j])",
      "mutated_line": "connections[-1].append(land[i - 0][j])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 0][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "connections[-1].append(land[i - 1][j])",
      "mutated_line": "connections[-1].append(land[i - -1][j])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - -1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if i < N - 1 and not visited[i + 1][j]:",
      "mutated_line": "if i < N - 1 and (not visited[i + 2][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 2][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if i < N - 1 and not visited[i + 1][j]:",
      "mutated_line": "if i < N - 1 and (not visited[i + 0][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 0][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if i < N - 1 and not visited[i + 1][j]:",
      "mutated_line": "if i < N - 1 and (not visited[i + 0][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 0][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if i < N - 1 and not visited[i + 1][j]:",
      "mutated_line": "if i < N - 1 and (not visited[i + -1][j]):",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + -1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "connections[-1].append(land[i + 1][j])",
      "mutated_line": "connections[-2].append(land[i + 1][j])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-2].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "connections[-1].append(land[i + 1][j])",
      "mutated_line": "connections[-0].append(land[i + 1][j])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-0].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "connections[-1].append(land[i + 1][j])",
      "mutated_line": "connections[-0].append(land[i + 1][j])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-0].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "connections[-1].append(land[i + 1][j])",
      "mutated_line": "connections[--1].append(land[i + 1][j])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[--1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "connections[-1].append(land[i + 1][j])",
      "mutated_line": "connections[-1].append(land[i + 2][j])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 2][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "connections[-1].append(land[i + 1][j])",
      "mutated_line": "connections[-1].append(land[i + 0][j])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 0][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "connections[-1].append(land[i + 1][j])",
      "mutated_line": "connections[-1].append(land[i + 0][j])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 0][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "connections[-1].append(land[i + 1][j])",
      "mutated_line": "connections[-1].append(land[i + -1][j])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + -1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "connections[-1].append(land[i][j - 1])",
      "mutated_line": "connections[-2].append(land[i][j - 1])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-2].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "connections[-1].append(land[i][j - 1])",
      "mutated_line": "connections[-0].append(land[i][j - 1])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-0].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "connections[-1].append(land[i][j - 1])",
      "mutated_line": "connections[-0].append(land[i][j - 1])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-0].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "connections[-1].append(land[i][j - 1])",
      "mutated_line": "connections[--1].append(land[i][j - 1])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[--1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "connections[-1].append(land[i][j + 1])",
      "mutated_line": "connections[-2].append(land[i][j + 1])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-2].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "connections[-1].append(land[i][j + 1])",
      "mutated_line": "connections[-0].append(land[i][j + 1])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-0].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "connections[-1].append(land[i][j + 1])",
      "mutated_line": "connections[-0].append(land[i][j + 1])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-0].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "connections[-1].append(land[i][j + 1])",
      "mutated_line": "connections[--1].append(land[i][j + 1])",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[--1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "elif 'B' in i and 'P' in i:",
      "mutated_line": "elif 'B' not in i and 'P' in i:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' not in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "elif 'B' in i and 'P' in i:",
      "mutated_line": "elif 'B' in i and 'P' not in i:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' not in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 1\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = -1\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 1\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "elif 'B' in i or 'P' in i:",
      "mutated_line": "elif 'B' in i and 'P' in i:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "ans *= 1",
      "mutated_line": "ans /= 1",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans /= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "elif 'B' in i and 'P' in i:",
      "mutated_line": "elif '' in i and 'P' in i:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif '' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "elif 'B' in i and 'P' in i:",
      "mutated_line": "elif 'B' in i and '' in i:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and '' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif 'B' in i or 'P' in i:",
      "mutated_line": "elif 'B' not in i or 'P' in i:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' not in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif 'B' in i or 'P' in i:",
      "mutated_line": "elif 'B' in i or 'P' not in i:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' not in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans *= 1",
      "mutated_line": "ans *= 2",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 2\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans *= 1",
      "mutated_line": "ans *= 0",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 0\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans *= 1",
      "mutated_line": "ans *= 0",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 0\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ans *= 1",
      "mutated_line": "ans *= -1",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= -1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = ans % MOD * 2",
      "mutated_line": "ans = ans % MOD / 2",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD / 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = ans % MOD * 2",
      "mutated_line": "ans = ans % MOD + 2",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD + 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = ans % MOD * 2",
      "mutated_line": "ans = (ans % MOD) ** 2",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = (ans % MOD) ** 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif 'B' in i or 'P' in i:",
      "mutated_line": "elif '' in i or 'P' in i:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif '' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif 'B' in i or 'P' in i:",
      "mutated_line": "elif 'B' in i or '' in i:",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or '' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = ans % MOD * 2",
      "mutated_line": "ans = ans * MOD * 2",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans * MOD * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = ans % MOD * 2",
      "mutated_line": "ans = (ans + MOD) * 2",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = (ans + MOD) * 2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = ans % MOD * 2",
      "mutated_line": "ans = ans % MOD * 3",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 3\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = ans % MOD * 2",
      "mutated_line": "ans = ans % MOD * 1",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 1\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = ans % MOD * 2",
      "mutated_line": "ans = ans % MOD * 0",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 0\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = ans % MOD * 2",
      "mutated_line": "ans = ans % MOD * 1",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * 1\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = ans % MOD * 2",
      "mutated_line": "ans = ans % MOD * -2",
      "code": "def count_bear_configurations(N, land):\n    MOD = 10 ** 9 + 7\n\n    def find_connections(i, j, visited, connections):\n        if i > 0 and (not visited[i - 1][j]):\n            connections[-1].append(land[i - 1][j])\n            visited[i - 1][j] = True\n            find_connections(i - 1, j, visited, connections)\n        if i < N - 1 and (not visited[i + 1][j]):\n            connections[-1].append(land[i + 1][j])\n            visited[i + 1][j] = True\n            find_connections(i + 1, j, visited, connections)\n        if j > 0 and (not visited[i][j - 1]):\n            connections[-1].append(land[i][j - 1])\n            visited[i][j - 1] = True\n            find_connections(i, j - 1, visited, connections)\n        if j < N - 1 and (not visited[i][j + 1]):\n            connections[-1].append(land[i][j + 1])\n            visited[i][j + 1] = True\n            find_connections(i, j + 1, visited, connections)\n\n    def count_ans(connections):\n        ans = 1\n        for i in connections:\n            if len(i) == 1 and i == ['?']:\n                ans = ans % MOD * 3\n            elif len(i) > 1:\n                if 'G' in i:\n                    ans = 0\n                    break\n                elif 'B' in i and 'P' in i:\n                    ans = 0\n                    break\n                elif 'B' in i or 'P' in i:\n                    ans *= 1\n                else:\n                    ans = ans % MOD * -2\n        return ans % MOD\n    visited = [[True if land[i][j] == '.' else False for j in range(N)] for i in range(N)]\n    connections = []\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                visited[i][j] = True\n                connections.append([land[i][j]])\n                find_connections(i, j, visited, connections)\n    return count_ans(connections)"
    }
  ]
}