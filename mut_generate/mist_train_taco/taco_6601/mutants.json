{
  "task_id": "taco_6601",
  "entry_point": "calculate_valid_dna_chains",
  "mutant_count": 100,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000008",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000008\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1000000006",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000006\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 0",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 0\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = 1",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 1000000007",
      "mutated_line": "MOD = -1000000007",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = -1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if n > 1:",
      "mutated_line": "if n >= 1:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n >= 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if n > 1:",
      "mutated_line": "if n <= 1:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n <= 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if n > 1:",
      "mutated_line": "if n != 1:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n != 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "matrix = [[1] * m for _ in range(m)]",
      "mutated_line": "for (a, b) in forbidden_pairs:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] / m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "matrix = [[1] * m for _ in range(m)]",
      "mutated_line": "for (a, b) in forbidden_pairs:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] + m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "matrix = [[1] * m for _ in range(m)]",
      "mutated_line": "for (a, b) in forbidden_pairs:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] ** m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "matrix[num_a][num_b] = 0",
      "mutated_line": "matrix[num_a][num_b] = 1",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 1\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "matrix[num_a][num_b] = 0",
      "mutated_line": "matrix[num_a][num_b] = -1",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = -1\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "matrix[num_a][num_b] = 0",
      "mutated_line": "matrix[num_a][num_b] = 1",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 1\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "assert m1 == m2",
      "mutated_line": "assert m1 != m2",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 != m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if n == 1:",
      "mutated_line": "if n != 1:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n != 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if n % 2 != 0:",
      "mutated_line": "if n % 2 == 0:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 == 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if n > 1:",
      "mutated_line": "if n > 2:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 2:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if n > 1:",
      "mutated_line": "if n > 0:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 0:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if n > 1:",
      "mutated_line": "if n > 0:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 0:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if n > 1:",
      "mutated_line": "if n > -1:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > -1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "return sum(map(sum, results)) % MOD",
      "mutated_line": "return sum(map(sum, results)) * MOD",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) * MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "return sum(map(sum, results)) % MOD",
      "mutated_line": "return sum(map(sum, results)) + MOD",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) + MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "char_to_num = {chr(i + ord('a')): i for i in range(26)}",
      "mutated_line": "char_to_num = {chr(i - ord('a')): i for i in range(26)}",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i - ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "char_to_num = {chr(i + ord('a')): i for i in range(26)}",
      "mutated_line": "char_to_num = {chr(i * ord('a')): i for i in range(26)}",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i * ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})",
      "mutated_line": "char_to_num.update({chr(i + ord('A')): i - 26 for i in range(26)})",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i - 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})",
      "mutated_line": "char_to_num.update({chr(i + ord('A')): i * 26 for i in range(26)})",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i * 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = [[0] * k2 for _ in range(n1)]",
      "mutated_line": "result = [[0] / k2 for _ in range(n1)]",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] / k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = [[0] * k2 for _ in range(n1)]",
      "mutated_line": "result = [[0] + k2 for _ in range(n1)]",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] + k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = [[0] * k2 for _ in range(n1)]",
      "mutated_line": "result = [[0] ** k2 for _ in range(n1)]",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] ** k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 2:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 2:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 0:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 0:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if n == 1:",
      "mutated_line": "if n == -1:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == -1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "half_power = mod_matrix_power(a, n // 2)",
      "mutated_line": "half_power = mod_matrix_power(a, n / 2)",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n / 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "half_power = mod_matrix_power(a, n // 2)",
      "mutated_line": "half_power = mod_matrix_power(a, n * 2)",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n * 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if n % 2 != 0:",
      "mutated_line": "if n * 2 != 0:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n * 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if n % 2 != 0:",
      "mutated_line": "if n + 2 != 0:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n + 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if n % 2 != 0:",
      "mutated_line": "if n % 2 != 1:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 1:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if n % 2 != 0:",
      "mutated_line": "if n % 2 != -1:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != -1:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if n % 2 != 0:",
      "mutated_line": "if n % 2 != 1:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 1:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "matrix = mod_matrix_power(matrix, n - 1)",
      "mutated_line": "matrix = mod_matrix_power(matrix, n + 1)",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n + 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "matrix = mod_matrix_power(matrix, n - 1)",
      "mutated_line": "matrix = mod_matrix_power(matrix, n * 1)",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n * 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "char_to_num = {chr(i + ord('a')): i for i in range(26)}",
      "mutated_line": "char_to_num = {chr(i + ord('a')): i for i in range(27)}",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(27)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "char_to_num = {chr(i + ord('a')): i for i in range(26)}",
      "mutated_line": "char_to_num = {chr(i + ord('a')): i for i in range(25)}",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(25)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "char_to_num = {chr(i + ord('a')): i for i in range(26)}",
      "mutated_line": "char_to_num = {chr(i + ord('a')): i for i in range(0)}",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(0)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "char_to_num = {chr(i + ord('a')): i for i in range(26)}",
      "mutated_line": "char_to_num = {chr(i + ord('a')): i for i in range(1)}",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(1)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "char_to_num = {chr(i + ord('a')): i for i in range(26)}",
      "mutated_line": "char_to_num = {chr(i + ord('a')): i for i in range(-26)}",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(-26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})",
      "mutated_line": "char_to_num.update({chr(i - ord('A')): i + 26 for i in range(26)})",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i - ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})",
      "mutated_line": "char_to_num.update({chr(i * ord('A')): i + 26 for i in range(26)})",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i * ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})",
      "mutated_line": "char_to_num.update({chr(i + ord('A')): i + 27 for i in range(26)})",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 27 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})",
      "mutated_line": "char_to_num.update({chr(i + ord('A')): i + 25 for i in range(26)})",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 25 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})",
      "mutated_line": "char_to_num.update({chr(i + ord('A')): i + 0 for i in range(26)})",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 0 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})",
      "mutated_line": "char_to_num.update({chr(i + ord('A')): i + 1 for i in range(26)})",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 1 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})",
      "mutated_line": "char_to_num.update({chr(i + ord('A')): i + -26 for i in range(26)})",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + -26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "matrix = [[1] * m for _ in range(m)]",
      "mutated_line": "for (a, b) in forbidden_pairs:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[2] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "matrix = [[1] * m for _ in range(m)]",
      "mutated_line": "for (a, b) in forbidden_pairs:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[0] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "matrix = [[1] * m for _ in range(m)]",
      "mutated_line": "for (a, b) in forbidden_pairs:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[0] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "matrix = [[1] * m for _ in range(m)]",
      "mutated_line": "for (a, b) in forbidden_pairs:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[-1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "result[i][j] += a[i][l] * b[l][j]",
      "mutated_line": "result[i][j] -= a[i][l] * b[l][j]",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] -= a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "half_power = mod_matrix_power(a, n // 2)",
      "mutated_line": "half_power = mod_matrix_power(a, n // 3)",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 3)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "half_power = mod_matrix_power(a, n // 2)",
      "mutated_line": "half_power = mod_matrix_power(a, n // 1)",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 1)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "half_power = mod_matrix_power(a, n // 2)",
      "mutated_line": "half_power = mod_matrix_power(a, n // 0)",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 0)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "half_power = mod_matrix_power(a, n // 2)",
      "mutated_line": "half_power = mod_matrix_power(a, n // 1)",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 1)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "half_power = mod_matrix_power(a, n // 2)",
      "mutated_line": "half_power = mod_matrix_power(a, n // -2)",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // -2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if n % 2 != 0:",
      "mutated_line": "if n % 3 != 0:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 3 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if n % 2 != 0:",
      "mutated_line": "if n % 1 != 0:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 1 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if n % 2 != 0:",
      "mutated_line": "if n % 0 != 0:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 0 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if n % 2 != 0:",
      "mutated_line": "if n % 1 != 0:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 1 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if n % 2 != 0:",
      "mutated_line": "if n % -2 != 0:",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % -2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "matrix = mod_matrix_power(matrix, n - 1)",
      "mutated_line": "matrix = mod_matrix_power(matrix, n - 2)",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 2)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "matrix = mod_matrix_power(matrix, n - 1)",
      "mutated_line": "matrix = mod_matrix_power(matrix, n - 0)",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 0)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "matrix = mod_matrix_power(matrix, n - 1)",
      "mutated_line": "matrix = mod_matrix_power(matrix, n - 0)",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 0)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "matrix = mod_matrix_power(matrix, n - 1)",
      "mutated_line": "matrix = mod_matrix_power(matrix, n - -1)",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - -1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "results = mod_matrix_product([[1] * m], matrix)",
      "mutated_line": "results = mod_matrix_product([[1] / m], matrix)",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] / m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "results = mod_matrix_product([[1] * m], matrix)",
      "mutated_line": "results = mod_matrix_product([[1] + m], matrix)",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] + m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "results = mod_matrix_product([[1] * m], matrix)",
      "mutated_line": "results = mod_matrix_product([[1] ** m], matrix)",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] ** m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "char_to_num = {chr(i + ord('a')): i for i in range(26)}",
      "mutated_line": "char_to_num = {chr(i + ord('')): i for i in range(26)}",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})",
      "mutated_line": "char_to_num.update({chr(i + ord('A')): i + 26 for i in range(27)})",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(27)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})",
      "mutated_line": "char_to_num.update({chr(i + ord('A')): i + 26 for i in range(25)})",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(25)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})",
      "mutated_line": "char_to_num.update({chr(i + ord('A')): i + 26 for i in range(0)})",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(0)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})",
      "mutated_line": "char_to_num.update({chr(i + ord('A')): i + 26 for i in range(1)})",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(1)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})",
      "mutated_line": "char_to_num.update({chr(i + ord('A')): i + 26 for i in range(-26)})",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(-26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "n1, m1 = len(a), len(a[0])",
      "mutated_line": "(n1, m1) = (len(a), len(a[1]))",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[1]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "n1, m1 = len(a), len(a[0])",
      "mutated_line": "(n1, m1) = (len(a), len(a[-1]))",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[-1]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "n1, m1 = len(a), len(a[0])",
      "mutated_line": "(n1, m1) = (len(a), len(a[1]))",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[1]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "m2, k2 = len(b), len(b[0])",
      "mutated_line": "(m2, k2) = (len(b), len(b[1]))",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[1]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "m2, k2 = len(b), len(b[0])",
      "mutated_line": "(m2, k2) = (len(b), len(b[-1]))",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[-1]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "m2, k2 = len(b), len(b[0])",
      "mutated_line": "(m2, k2) = (len(b), len(b[1]))",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[1]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = [[0] * k2 for _ in range(n1)]",
      "mutated_line": "result = [[1] * k2 for _ in range(n1)]",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[1] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = [[0] * k2 for _ in range(n1)]",
      "mutated_line": "result = [[-1] * k2 for _ in range(n1)]",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[-1] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = [[0] * k2 for _ in range(n1)]",
      "mutated_line": "result = [[1] * k2 for _ in range(n1)]",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[1] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "result[i][j] += a[i][l] * b[l][j]",
      "mutated_line": "result[i][j] += a[i][l] / b[l][j]",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] / b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "result[i][j] += a[i][l] * b[l][j]",
      "mutated_line": "result[i][j] += a[i][l] + b[l][j]",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] + b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "result[i][j] += a[i][l] * b[l][j]",
      "mutated_line": "result[i][j] += a[i][l] ** b[l][j]",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] ** b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})",
      "mutated_line": "char_to_num.update({chr(i + ord('')): i + 26 for i in range(26)})",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "results = mod_matrix_product([[1] * m], matrix)",
      "mutated_line": "results = mod_matrix_product([[2] * m], matrix)",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[2] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "results = mod_matrix_product([[1] * m], matrix)",
      "mutated_line": "results = mod_matrix_product([[0] * m], matrix)",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[0] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "results = mod_matrix_product([[1] * m], matrix)",
      "mutated_line": "results = mod_matrix_product([[0] * m], matrix)",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[0] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "results = mod_matrix_product([[1] * m], matrix)",
      "mutated_line": "results = mod_matrix_product([[-1] * m], matrix)",
      "code": "def calculate_valid_dna_chains(n, m, k, forbidden_pairs):\n    MOD = 1000000007\n    char_to_num = {chr(i + ord('a')): i for i in range(26)}\n    char_to_num.update({chr(i + ord('A')): i + 26 for i in range(26)})\n    matrix = [[1] * m for _ in range(m)]\n    for (a, b) in forbidden_pairs:\n        num_a = char_to_num[a]\n        num_b = char_to_num[b]\n        matrix[num_a][num_b] = 0\n\n    def mod_matrix_product(a, b):\n        (n1, m1) = (len(a), len(a[0]))\n        (m2, k2) = (len(b), len(b[0]))\n        assert m1 == m2\n        result = [[0] * k2 for _ in range(n1)]\n        for i in range(n1):\n            for j in range(k2):\n                for l in range(m1):\n                    result[i][j] += a[i][l] * b[l][j]\n                result[i][j] %= MOD\n        return result\n\n    def mod_matrix_power(a, n):\n        if n == 1:\n            return a\n        half_power = mod_matrix_power(a, n // 2)\n        result = mod_matrix_product(half_power, half_power)\n        if n % 2 != 0:\n            result = mod_matrix_product(result, a)\n        return result\n    if n > 1:\n        matrix = mod_matrix_power(matrix, n - 1)\n        results = mod_matrix_product([[-1] * m], matrix)\n        return sum(map(sum, results)) % MOD\n    else:\n        return m"
    }
  ]
}