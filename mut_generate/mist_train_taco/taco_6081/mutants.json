{
  "task_id": "taco_6081",
  "entry_point": "find_minimum_cost_string",
  "mutant_count": 76,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "extra = n - len(ks)",
      "mutated_line": "extra = n + len(ks)",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n + len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "extra = n - len(ks)",
      "mutated_line": "extra = n * len(ks)",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n * len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if k == 1:",
      "mutated_line": "if k != 1:",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k != 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if k == 2:",
      "mutated_line": "if k != 2:",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k != 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "msd = 2",
      "mutated_line": "msd = 3",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 3\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "msd = 2",
      "mutated_line": "msd = 1",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 1\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "msd = 2",
      "mutated_line": "msd = 0",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 0\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "msd = 2",
      "mutated_line": "msd = 1",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 1\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "msd = 2",
      "mutated_line": "msd = -2",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = -2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while msd < k:",
      "mutated_line": "while msd <= k:",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd <= k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while msd < k:",
      "mutated_line": "while msd >= k:",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd >= k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while msd < k:",
      "mutated_line": "while msd != k:",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd != k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "msd += 1",
      "mutated_line": "msd -= 1",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd -= 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ks.pop(0)",
      "mutated_line": "ks.pop(1)",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(1)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ks.pop(0)",
      "mutated_line": "ks.pop(-1)",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(-1)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ks.pop(0)",
      "mutated_line": "ks.pop(1)",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(1)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ks = ['a', 'a']",
      "mutated_line": "ks = ['', 'a']",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ks = ['a', 'a']",
      "mutated_line": "ks = ['a', '']",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', '']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 2:",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 2:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 0:",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 0:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 0:",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 0:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if k == 1:",
      "mutated_line": "if k == -1:",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == -1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ks = ['a', 'a', 'b', 'b', 'a']",
      "mutated_line": "ks = ['', 'a', 'b', 'b', 'a']",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ks = ['a', 'a', 'b', 'b', 'a']",
      "mutated_line": "ks = ['a', '', 'b', 'b', 'a']",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', '', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ks = ['a', 'a', 'b', 'b', 'a']",
      "mutated_line": "ks = ['a', 'a', '', 'b', 'a']",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', '', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ks = ['a', 'a', 'b', 'b', 'a']",
      "mutated_line": "ks = ['a', 'a', 'b', '', 'a']",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', '', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "ks = ['a', 'a', 'b', 'b', 'a']",
      "mutated_line": "ks = ['a', 'a', 'b', 'b', '']",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', '']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if k == 2:",
      "mutated_line": "if k == 3:",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 3:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if k == 2:",
      "mutated_line": "if k == 1:",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 1:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if k == 2:",
      "mutated_line": "if k == 0:",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 0:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if k == 2:",
      "mutated_line": "if k == 1:",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 1:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if k == 2:",
      "mutated_line": "if k == -2:",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == -2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "msd += 1",
      "mutated_line": "msd += 2",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 2\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "msd += 1",
      "mutated_line": "msd += 0",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 0\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "msd += 1",
      "mutated_line": "msd += 0",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 0\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "msd += 1",
      "mutated_line": "msd += -1",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += -1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return ''.join(ans)",
      "mutated_line": "return 'MUTATED'.join(ans)",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return 'MUTATED'.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i in range(msd - 1):",
      "mutated_line": "for i in range(msd + 1):",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd + 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for i in range(msd - 1):",
      "mutated_line": "for i in range(msd * 1):",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd * 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans.append(ks[i % len(ks)])",
      "mutated_line": "ans.append(ks[i * len(ks)])",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i * len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans.append(ks[i % len(ks)])",
      "mutated_line": "ans.append(ks[i + len(ks)])",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i + len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(msd - 1):",
      "mutated_line": "for i in range(msd - 2):",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 2):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(msd - 1):",
      "mutated_line": "for i in range(msd - 0):",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 0):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(msd - 1):",
      "mutated_line": "for i in range(msd - 0):",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 0):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for i in range(msd - 1):",
      "mutated_line": "for i in range(msd - -1):",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - -1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])",
      "mutated_line": "ks.extend([chr(ord('a') - msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') - msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])",
      "mutated_line": "ks.extend([chr(ord('a') * msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') * msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])",
      "mutated_line": "ks.extend([chr(ord('a') + msd), chr(ord('a') + msd + 1), chr(ord('a') + msd)])",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd + 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])",
      "mutated_line": "ks.extend([chr(ord('a') + msd), chr((ord('a') + msd) * 1), chr(ord('a') + msd)])",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr((ord('a') + msd) * 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])",
      "mutated_line": "ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') - msd)])",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') - msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])",
      "mutated_line": "ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') * msd)])",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') * msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ks.extend(chr(ord('a') + msd))",
      "mutated_line": "ks.extend(chr(ord('a') - msd))",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') - msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ks.extend(chr(ord('a') + msd))",
      "mutated_line": "ks.extend(chr(ord('a') * msd))",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') * msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ks.extend(chr(ord('a') + (msd - (2 + i))))",
      "mutated_line": "ks.extend(chr(ord('a') - (msd - (2 + i))))",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') - (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ks.extend(chr(ord('a') + (msd - (2 + i))))",
      "mutated_line": "ks.extend(chr(ord('a') * (msd - (2 + i))))",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') * (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])",
      "mutated_line": "ks.extend([chr(ord('a') + msd), chr(ord('a') - msd - 1), chr(ord('a') + msd)])",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') - msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])",
      "mutated_line": "ks.extend([chr(ord('a') + msd), chr(ord('a') * msd - 1), chr(ord('a') + msd)])",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') * msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])",
      "mutated_line": "ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 2), chr(ord('a') + msd)])",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 2), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])",
      "mutated_line": "ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 0), chr(ord('a') + msd)])",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 0), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])",
      "mutated_line": "ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 0), chr(ord('a') + msd)])",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 0), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])",
      "mutated_line": "ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - -1), chr(ord('a') + msd)])",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - -1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ks.extend(chr(ord('a') + (msd - (2 + i))))",
      "mutated_line": "ks.extend(chr(ord('a') + (msd + (2 + i))))",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd + (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ks.extend(chr(ord('a') + (msd - (2 + i))))",
      "mutated_line": "ks.extend(chr(ord('a') + msd * (2 + i)))",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + msd * (2 + i)))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])",
      "mutated_line": "ks.extend([chr(ord('') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])",
      "mutated_line": "ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('') + msd)])",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ks.extend(chr(ord('a') + msd))",
      "mutated_line": "ks.extend(chr(ord('') + msd))",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ks.extend(chr(ord('a') + (msd - (2 + i))))",
      "mutated_line": "ks.extend(chr(ord('') + (msd - (2 + i))))",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ks.extend(chr(ord('a') + (msd - (2 + i))))",
      "mutated_line": "ks.extend(chr(ord('a') + (msd - (2 - i))))",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 - i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ks.extend(chr(ord('a') + (msd - (2 + i))))",
      "mutated_line": "ks.extend(chr(ord('a') + (msd - 2 * i)))",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - 2 * i)))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])",
      "mutated_line": "ks.extend([chr(ord('a') + msd), chr(ord('') + msd - 1), chr(ord('a') + msd)])",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ks.extend(chr(ord('a') + (msd - (2 + i))))",
      "mutated_line": "ks.extend(chr(ord('a') + (msd - (3 + i))))",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (3 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ks.extend(chr(ord('a') + (msd - (2 + i))))",
      "mutated_line": "ks.extend(chr(ord('a') + (msd - (1 + i))))",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (1 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ks.extend(chr(ord('a') + (msd - (2 + i))))",
      "mutated_line": "ks.extend(chr(ord('a') + (msd - (0 + i))))",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (0 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ks.extend(chr(ord('a') + (msd - (2 + i))))",
      "mutated_line": "ks.extend(chr(ord('a') + (msd - (1 + i))))",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (1 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ks.extend(chr(ord('a') + (msd - (2 + i))))",
      "mutated_line": "ks.extend(chr(ord('a') + (msd - (-2 + i))))",
      "code": "def find_minimum_cost_string(n: int, k: int) -> str:\n    \"\"\"\n    Finds a string of length n with minimum possible cost, using the first k characters of the Latin alphabet.\n\n    Parameters:\n    n (int): The length of the string to be generated.\n    k (int): The number of characters from the Latin alphabet to be used.\n\n    Returns:\n    str: A string of length n with the minimum possible cost.\n    \"\"\"\n\n    def create_ks(k):\n        ks = ['a', 'a']\n        if k == 1:\n            return ks\n        ks = ['a', 'a', 'b', 'b', 'a']\n        if k == 2:\n            return ks\n        msd = 2\n        while msd < k:\n            ks.extend([chr(ord('a') + msd), chr(ord('a') + msd - 1), chr(ord('a') + msd)])\n            for i in range(msd - 1):\n                ks.extend(chr(ord('a') + msd))\n                ks.extend(chr(ord('a') + (msd - (-2 + i))))\n            msd += 1\n        return ks\n    ks = create_ks(k)\n    ans = []\n    extra = n - len(ks)\n    for i in range(min(n, len(ks))):\n        ans.append(ks[i])\n    ks.pop(0)\n    for i in range(extra):\n        ans.append(ks[i % len(ks)])\n    return ''.join(ans)"
    }
  ]
}