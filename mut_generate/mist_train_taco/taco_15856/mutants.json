{
  "task_id": "taco_15856",
  "entry_point": "find_shortest_cycle",
  "mutant_count": 55,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dist = [INF] * N",
      "mutated_line": "dist = [INF] / N",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] / N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dist = [INF] * N",
      "mutated_line": "dist = [INF] + N",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] + N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dist = [INF] * N",
      "mutated_line": "dist = [INF] ** N",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] ** N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dist[s] = 0",
      "mutated_line": "dist[s] = 1",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 1\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dist[s] = 0",
      "mutated_line": "dist[s] = -1",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = -1\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "dist[s] = 0",
      "mutated_line": "dist[s] = 1",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 1\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "parent = [-1] * N",
      "mutated_line": "parent = [-1] / N",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] / N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "parent = [-1] * N",
      "mutated_line": "parent = [-1] + N",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] + N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "parent = [-1] * N",
      "mutated_line": "parent = [-1] ** N",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] ** N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "while dq and ans_last is None:",
      "mutated_line": "while dq or ans_last is None:",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq or ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "INF = float('inf')",
      "mutated_line": "INF = float('')",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while dq and ans_last is None:",
      "mutated_line": "while dq and ans_last is not None:",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is not None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "while g != s:",
      "mutated_line": "while g == s:",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g == s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for s in range(1, N + 1):",
      "mutated_line": "for s in range(2, N + 1):",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(2, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for s in range(1, N + 1):",
      "mutated_line": "for s in range(0, N + 1):",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(0, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for s in range(1, N + 1):",
      "mutated_line": "for s in range(0, N + 1):",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(0, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for s in range(1, N + 1):",
      "mutated_line": "for s in range(-1, N + 1):",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(-1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for s in range(1, N + 1):",
      "mutated_line": "for s in range(1, N - 1):",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N - 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for s in range(1, N + 1):",
      "mutated_line": "for s in range(1, N * 1):",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N * 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "UOI",
      "lineno": 48,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return +1"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "parent = [-1] * N",
      "mutated_line": "parent = [+1] * N",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [+1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if dist[n] == 0:",
      "mutated_line": "if dist[n] != 0:",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] != 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for s in range(1, N + 1):",
      "mutated_line": "for s in range(1, N + 2):",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 2):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for s in range(1, N + 1):",
      "mutated_line": "for s in range(1, N + 0):",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 0):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for s in range(1, N + 1):",
      "mutated_line": "for s in range(1, N + 0):",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 0):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for s in range(1, N + 1):",
      "mutated_line": "for s in range(1, N + -1):",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + -1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "LCR",
      "lineno": 42,
      "original_line": "if min_route is None or len(route) < len(min_route):",
      "mutated_line": "if min_route is None and len(route) < len(min_route):",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None and len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -2"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -0"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return --1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "parent = [-1] * N",
      "mutated_line": "parent = [-2] * N",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-2] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "parent = [-1] * N",
      "mutated_line": "parent = [-0] * N",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-0] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "parent = [-1] * N",
      "mutated_line": "parent = [-0] * N",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-0] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "parent = [-1] * N",
      "mutated_line": "parent = [--1] * N",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [--1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if dist[n] == 0:",
      "mutated_line": "if dist[n] == 1:",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 1:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if dist[n] == 0:",
      "mutated_line": "if dist[n] == -1:",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == -1:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if dist[n] == 0:",
      "mutated_line": "if dist[n] == 1:",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 1:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif dist[n] == INF:",
      "mutated_line": "elif dist[n] != INF:",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] != INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "G = [[] for _ in range(N + 1)]",
      "mutated_line": "G = [[] for _ in range(N - 1)]",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N - 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "G = [[] for _ in range(N + 1)]",
      "mutated_line": "G = [[] for _ in range(N * 1)]",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N * 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if min_route is None or len(route) < len(min_route):",
      "mutated_line": "if min_route is not None or len(route) < len(min_route):",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is not None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if min_route is None or len(route) < len(min_route):",
      "mutated_line": "if min_route is None or len(route) <= len(min_route):",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) <= len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if min_route is None or len(route) < len(min_route):",
      "mutated_line": "if min_route is None or len(route) >= len(min_route):",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) >= len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if min_route is None or len(route) < len(min_route):",
      "mutated_line": "if min_route is None or len(route) != len(min_route):",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) != len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dist[n] = d + 1",
      "mutated_line": "dist[n] = d - 1",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d - 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "dist[n] = d + 1",
      "mutated_line": "dist[n] = d * 1",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d * 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "G = [[] for _ in range(N + 1)]",
      "mutated_line": "G = [[] for _ in range(N + 2)]",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 2)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "G = [[] for _ in range(N + 1)]",
      "mutated_line": "G = [[] for _ in range(N + 0)]",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 0)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "G = [[] for _ in range(N + 1)]",
      "mutated_line": "G = [[] for _ in range(N + 0)]",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 0)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "G = [[] for _ in range(N + 1)]",
      "mutated_line": "G = [[] for _ in range(N + -1)]",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + -1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dist[n] = d + 1",
      "mutated_line": "dist[n] = d + 2",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 2\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dist[n] = d + 1",
      "mutated_line": "dist[n] = d + 0",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 0\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dist[n] = d + 1",
      "mutated_line": "dist[n] = d + 0",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + 0\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "dist[n] = d + 1",
      "mutated_line": "dist[n] = d + -1",
      "code": "from collections import deque\n\ndef find_shortest_cycle(G, s):\n    dq = deque()\n    N = len(G)\n    INF = float('inf')\n    dist = [INF] * N\n    dist[s] = 0\n    parent = [-1] * N\n    ans_last = None\n    dq.append(s)\n    while dq and ans_last is None:\n        v = dq.popleft()\n        d = dist[v]\n        for n in G[v]:\n            if dist[n] == 0:\n                ans_last = v\n                parent[n] = v\n                break\n            elif dist[n] == INF:\n                dist[n] = d + -1\n                parent[n] = v\n                dq.append(n)\n    if ans_last:\n        g = ans_last\n        route = [g]\n        while g != s:\n            g = parent[g]\n            route.append(g)\n        return list(reversed(route))\n    return None\n\ndef find_induced_subgraph(N, M, edges):\n    G = [[] for _ in range(N + 1)]\n    for (a, b) in edges:\n        G[a].append(b)\n    min_route = None\n    for s in range(1, N + 1):\n        route = find_shortest_cycle(G, s)\n        if route:\n            if min_route is None or len(route) < len(min_route):\n                min_route = route\n    if min_route:\n        return (len(min_route), min_route)\n    else:\n        return -1"
    }
  ]
}