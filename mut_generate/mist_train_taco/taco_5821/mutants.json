{
  "task_id": "taco_5821",
  "entry_point": "calculate_min_costs",
  "mutant_count": 100,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cur = 0",
      "mutated_line": "cur = 1",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 1\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cur = 0",
      "mutated_line": "cur = -1",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = -1\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "cur = 0",
      "mutated_line": "cur = 1",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 1\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "tokens.append('')",
      "mutated_line": "tokens.append('MUTATED')",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('MUTATED')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if tokens[cur] == '|':",
      "mutated_line": "if tokens[cur] != '|':",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] != '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "cur += 1",
      "mutated_line": "cur -= 1",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur -= 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if tokens[cur] == '&':",
      "mutated_line": "if tokens[cur] != '&':",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] != '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "cur += 1",
      "mutated_line": "cur -= 1",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur -= 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if tokens[cur] == '?':",
      "mutated_line": "if tokens[cur] != '?':",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] != '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "cur += 1",
      "mutated_line": "cur -= 1",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur -= 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "tokens = [tok for tok in formula if tok != ' ']",
      "mutated_line": "tokens = [tok for tok in formula if tok == ' ']",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok == ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if tokens[cur] == '|':",
      "mutated_line": "if tokens[cur] == '':",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cur += 1",
      "mutated_line": "cur += 2",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 2\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cur += 1",
      "mutated_line": "cur += 0",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 0\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cur += 1",
      "mutated_line": "cur += 0",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 0\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "cur += 1",
      "mutated_line": "cur += -1",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += -1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "zero = lhs[0] + rhs[0]",
      "mutated_line": "zero = lhs[0] - rhs[0]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] - rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "zero = lhs[0] + rhs[0]",
      "mutated_line": "zero = lhs[0] * rhs[0]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] * rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if tokens[cur] == '&':",
      "mutated_line": "if tokens[cur] == '':",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cur += 1",
      "mutated_line": "cur += 2",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 2\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cur += 1",
      "mutated_line": "cur += 0",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 0\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cur += 1",
      "mutated_line": "cur += 0",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 0\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cur += 1",
      "mutated_line": "cur += -1",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += -1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "one = lhs[1] + rhs[1]",
      "mutated_line": "one = lhs[1] - rhs[1]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] - rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "one = lhs[1] + rhs[1]",
      "mutated_line": "one = lhs[1] * rhs[1]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] * rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if tokens[cur] == '?':",
      "mutated_line": "if tokens[cur] == '':",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cur += 1",
      "mutated_line": "cur += 2",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 2\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cur += 1",
      "mutated_line": "cur += 0",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 0\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cur += 1",
      "mutated_line": "cur += 0",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 0\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cur += 1",
      "mutated_line": "cur += -1",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += -1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "elif tokens[cur] == '(':",
      "mutated_line": "elif tokens[cur] != '(':",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] != '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "cur += 1",
      "mutated_line": "cur -= 1",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur -= 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "cur += 1",
      "mutated_line": "cur -= 1",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur -= 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (result[0], result[1])",
      "mutated_line": "return (result[1], result[1])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[1], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (result[0], result[1])",
      "mutated_line": "return (result[-1], result[1])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[-1], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (result[0], result[1])",
      "mutated_line": "return (result[1], result[1])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[1], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (result[0], result[1])",
      "mutated_line": "return (result[0], result[2])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[2])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (result[0], result[1])",
      "mutated_line": "return (result[0], result[0])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[0])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (result[0], result[1])",
      "mutated_line": "return (result[0], result[0])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[0])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (result[0], result[1])",
      "mutated_line": "return (result[0], result[-1])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "tokens = [tok for tok in formula if tok != ' ']",
      "mutated_line": "tokens = [tok for tok in formula if tok != '']",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != '']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "one = min(lhs[1], lhs[0] + rhs[1])",
      "mutated_line": "one = min(lhs[1], lhs[0] - rhs[1])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] - rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "one = min(lhs[1], lhs[0] + rhs[1])",
      "mutated_line": "one = min(lhs[1], lhs[0] * rhs[1])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] * rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "zero = min(lhs[0], lhs[1] + rhs[0])",
      "mutated_line": "zero = min(lhs[0], lhs[1] - rhs[0])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] - rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "zero = min(lhs[0], lhs[1] + rhs[0])",
      "mutated_line": "zero = min(lhs[0], lhs[1] * rhs[0])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] * rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return [1, 1]",
      "mutated_line": "return [2, 1]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [2, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return [1, 1]",
      "mutated_line": "return [0, 1]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [0, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return [1, 1]",
      "mutated_line": "return [0, 1]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [0, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return [1, 1]",
      "mutated_line": "return [-1, 1]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [-1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return [1, 1]",
      "mutated_line": "return [1, 2]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 2]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return [1, 1]",
      "mutated_line": "return [1, 0]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 0]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return [1, 1]",
      "mutated_line": "return [1, 0]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 0]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return [1, 1]",
      "mutated_line": "return [1, -1]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, -1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "elif tokens[cur] == '(':",
      "mutated_line": "elif tokens[cur] == '':",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "cur += 1",
      "mutated_line": "cur += 2",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 2\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "cur += 1",
      "mutated_line": "cur += 0",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 0\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "cur += 1",
      "mutated_line": "cur += 0",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 0\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "cur += 1",
      "mutated_line": "cur += -1",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += -1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if tokens[cur] != ')':",
      "mutated_line": "if tokens[cur] == ')':",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] == ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "cur += 1",
      "mutated_line": "cur += 2",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 2\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "cur += 1",
      "mutated_line": "cur += 0",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 0\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "cur += 1",
      "mutated_line": "cur += 0",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 0\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "cur += 1",
      "mutated_line": "cur += -1",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += -1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "zero = lhs[0] + rhs[0]",
      "mutated_line": "zero = lhs[1] + rhs[0]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[1] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "zero = lhs[0] + rhs[0]",
      "mutated_line": "zero = lhs[-1] + rhs[0]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[-1] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "zero = lhs[0] + rhs[0]",
      "mutated_line": "zero = lhs[1] + rhs[0]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[1] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "zero = lhs[0] + rhs[0]",
      "mutated_line": "zero = lhs[0] + rhs[1]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[1]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "zero = lhs[0] + rhs[0]",
      "mutated_line": "zero = lhs[0] + rhs[-1]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[-1]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "zero = lhs[0] + rhs[0]",
      "mutated_line": "zero = lhs[0] + rhs[1]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[1]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "one = min(lhs[1], lhs[0] + rhs[1])",
      "mutated_line": "one = min(lhs[2], lhs[0] + rhs[1])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[2], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "one = min(lhs[1], lhs[0] + rhs[1])",
      "mutated_line": "one = min(lhs[0], lhs[0] + rhs[1])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[0], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "one = min(lhs[1], lhs[0] + rhs[1])",
      "mutated_line": "one = min(lhs[0], lhs[0] + rhs[1])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[0], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "one = min(lhs[1], lhs[0] + rhs[1])",
      "mutated_line": "one = min(lhs[-1], lhs[0] + rhs[1])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[-1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "zero = min(lhs[0], lhs[1] + rhs[0])",
      "mutated_line": "zero = min(lhs[1], lhs[1] + rhs[0])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[1], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "zero = min(lhs[0], lhs[1] + rhs[0])",
      "mutated_line": "zero = min(lhs[-1], lhs[1] + rhs[0])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[-1], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "zero = min(lhs[0], lhs[1] + rhs[0])",
      "mutated_line": "zero = min(lhs[1], lhs[1] + rhs[0])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[1], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "one = lhs[1] + rhs[1]",
      "mutated_line": "one = lhs[2] + rhs[1]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[2] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "one = lhs[1] + rhs[1]",
      "mutated_line": "one = lhs[0] + rhs[1]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[0] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "one = lhs[1] + rhs[1]",
      "mutated_line": "one = lhs[0] + rhs[1]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[0] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "one = lhs[1] + rhs[1]",
      "mutated_line": "one = lhs[-1] + rhs[1]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[-1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "one = lhs[1] + rhs[1]",
      "mutated_line": "one = lhs[1] + rhs[2]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[2]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "one = lhs[1] + rhs[1]",
      "mutated_line": "one = lhs[1] + rhs[0]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[0]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "one = lhs[1] + rhs[1]",
      "mutated_line": "one = lhs[1] + rhs[0]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[0]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "one = lhs[1] + rhs[1]",
      "mutated_line": "one = lhs[1] + rhs[-1]",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[-1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if tokens[cur] != ')':",
      "mutated_line": "if tokens[cur] != '':",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != '':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "one = min(lhs[1], lhs[0] + rhs[1])",
      "mutated_line": "one = min(lhs[1], lhs[1] + rhs[1])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[1] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "one = min(lhs[1], lhs[0] + rhs[1])",
      "mutated_line": "one = min(lhs[1], lhs[-1] + rhs[1])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[-1] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "one = min(lhs[1], lhs[0] + rhs[1])",
      "mutated_line": "one = min(lhs[1], lhs[1] + rhs[1])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[1] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "one = min(lhs[1], lhs[0] + rhs[1])",
      "mutated_line": "one = min(lhs[1], lhs[0] + rhs[2])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[2])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "one = min(lhs[1], lhs[0] + rhs[1])",
      "mutated_line": "one = min(lhs[1], lhs[0] + rhs[0])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[0])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "one = min(lhs[1], lhs[0] + rhs[1])",
      "mutated_line": "one = min(lhs[1], lhs[0] + rhs[0])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[0])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "one = min(lhs[1], lhs[0] + rhs[1])",
      "mutated_line": "one = min(lhs[1], lhs[0] + rhs[-1])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[-1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "zero = min(lhs[0], lhs[1] + rhs[0])",
      "mutated_line": "zero = min(lhs[0], lhs[2] + rhs[0])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[2] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "zero = min(lhs[0], lhs[1] + rhs[0])",
      "mutated_line": "zero = min(lhs[0], lhs[0] + rhs[0])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[0] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "zero = min(lhs[0], lhs[1] + rhs[0])",
      "mutated_line": "zero = min(lhs[0], lhs[0] + rhs[0])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[0] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "zero = min(lhs[0], lhs[1] + rhs[0])",
      "mutated_line": "zero = min(lhs[0], lhs[-1] + rhs[0])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[-1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "zero = min(lhs[0], lhs[1] + rhs[0])",
      "mutated_line": "zero = min(lhs[0], lhs[1] + rhs[1])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[1])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "zero = min(lhs[0], lhs[1] + rhs[0])",
      "mutated_line": "zero = min(lhs[0], lhs[1] + rhs[-1])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[-1])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "zero = min(lhs[0], lhs[1] + rhs[0])",
      "mutated_line": "zero = min(lhs[0], lhs[1] + rhs[1])",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[1])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('not closed')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "raise Exception('not closed')",
      "mutated_line": "raise Exception('')",
      "code": "def calculate_min_costs(formula: str) -> tuple:\n    tokens = [tok for tok in formula if tok != ' ']\n    tokens.append('')\n    cur = 0\n\n    def parse_formula():\n        return parse_or()\n\n    def parse_or():\n        nonlocal cur\n        lhs = parse_and()\n        if tokens[cur] == '|':\n            cur += 1\n            rhs = parse_or()\n            zero = lhs[0] + rhs[0]\n            one = min(lhs[1], lhs[0] + rhs[1])\n            return (zero, one)\n        return lhs\n\n    def parse_and():\n        nonlocal cur\n        lhs = parse_term()\n        if tokens[cur] == '&':\n            cur += 1\n            rhs = parse_and()\n            zero = min(lhs[0], lhs[1] + rhs[0])\n            one = lhs[1] + rhs[1]\n            return (zero, one)\n        return lhs\n\n    def parse_term():\n        nonlocal cur\n        if tokens[cur] == '?':\n            cur += 1\n            return [1, 1]\n        elif tokens[cur] == '(':\n            cur += 1\n            res = parse_or()\n            if tokens[cur] != ')':\n                raise Exception('')\n            cur += 1\n            return res\n    result = parse_formula()\n    return (result[0], result[1])"
    }
  ]
}