{
  "task_id": "taco_1281",
  "entry_point": "calculate_sum_of_f_over_subsets",
  "mutant_count": 151,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def calculate_sum_of_f_over_subsets(points, mod=998244353):",
      "mutated_line": "def calculate_sum_of_f_over_subsets(points, mod=998244354):",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244354):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def calculate_sum_of_f_over_subsets(points, mod=998244353):",
      "mutated_line": "def calculate_sum_of_f_over_subsets(points, mod=998244352):",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244352):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def calculate_sum_of_f_over_subsets(points, mod=998244353):",
      "mutated_line": "def calculate_sum_of_f_over_subsets(points, mod=0):",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=0):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def calculate_sum_of_f_over_subsets(points, mod=998244353):",
      "mutated_line": "def calculate_sum_of_f_over_subsets(points, mod=1):",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=1):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def calculate_sum_of_f_over_subsets(points, mod=998244353):",
      "mutated_line": "def calculate_sum_of_f_over_subsets(points, mod=-998244353):",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=-998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "BIT = [0] * (LEN + 1)",
      "mutated_line": "BIT = [0] / (LEN + 1)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] / (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "BIT = [0] * (LEN + 1)",
      "mutated_line": "BIT = [0] + (LEN + 1)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] + (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "BIT = [0] * (LEN + 1)",
      "mutated_line": "BIT = [0] ** (LEN + 1)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] ** (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 * N - (pow(2, N, mod) - 1) * (N - 4) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N - (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 * N * ((pow(2, N, mod) - 1) * (N - 4) % mod)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N * ((pow(2, N, mod) - 1) * (N - 4) % mod)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "BIT = [0] * (LEN + 1)",
      "mutated_line": "BIT = [0] / (LEN + 1)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] / (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "BIT = [0] * (LEN + 1)",
      "mutated_line": "BIT = [0] + (LEN + 1)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] + (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "BIT = [0] * (LEN + 1)",
      "mutated_line": "BIT = [0] ** (LEN + 1)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] ** (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "BIT = [0] * (LEN + 1)",
      "mutated_line": "BIT = [0] * (LEN - 1)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN - 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "BIT = [0] * (LEN + 1)",
      "mutated_line": "BIT = [0] * (LEN * 1)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN * 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while v <= LEN:",
      "mutated_line": "while v < LEN:",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v < LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while v <= LEN:",
      "mutated_line": "while v > LEN:",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v > LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while v <= LEN:",
      "mutated_line": "while v == LEN:",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v == LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "BIT[v] += w",
      "mutated_line": "BIT[v] -= w",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] -= w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "v += v & -v",
      "mutated_line": "v -= v & -v",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v -= v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ANS = 0",
      "mutated_line": "ANS = 1",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 1\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ANS = 0",
      "mutated_line": "ANS = -1",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = -1\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "ANS = 0",
      "mutated_line": "ANS = 1",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 1\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while v != 0:",
      "mutated_line": "while v == 0:",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v == 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "ANS += BIT[v]",
      "mutated_line": "ANS -= BIT[v]",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS -= BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "v -= v & -v",
      "mutated_line": "v += v & -v",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v += v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 / N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 / N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 + N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 + N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 ** N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 ** N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) * mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) * mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 * N + ((pow(2, N, mod) - 1) * (N - 4) + mod)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + ((pow(2, N, mod) - 1) * (N - 4) + mod)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) * mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) * mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2 + mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2 + mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "BIT = [0] * (LEN + 1)",
      "mutated_line": "BIT = [0] * (LEN - 1)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN - 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "BIT = [0] * (LEN + 1)",
      "mutated_line": "BIT = [0] * (LEN * 1)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN * 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) * mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) * mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2 + mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2 + mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "points = [[compression_dict_x[x] + 1, y] for (x, y) in points]",
      "mutated_line": "points = [[compression_dict_x[x] - 1, y] for (x, y) in points]",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] - 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "points = [[compression_dict_x[x] + 1, y] for (x, y) in points]",
      "mutated_line": "points = [[compression_dict_x[x] * 1, y] for (x, y) in points]",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] * 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "BIT = [0] * (LEN + 1)",
      "mutated_line": "BIT = [1] * (LEN + 1)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [1] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "BIT = [0] * (LEN + 1)",
      "mutated_line": "BIT = [-1] * (LEN + 1)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [-1] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "BIT = [0] * (LEN + 1)",
      "mutated_line": "BIT = [1] * (LEN + 1)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [1] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "BIT = [0] * (LEN + 1)",
      "mutated_line": "BIT = [0] * (LEN + 2)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 2)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "BIT = [0] * (LEN + 1)",
      "mutated_line": "BIT = [0] * (LEN + 0)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 0)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "BIT = [0] * (LEN + 1)",
      "mutated_line": "BIT = [0] * (LEN + 0)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 0)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "BIT = [0] * (LEN + 1)",
      "mutated_line": "BIT = [0] * (LEN + -1)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + -1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "v += v & -v",
      "mutated_line": "v += v | -v",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v | -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while v != 0:",
      "mutated_line": "while v != 1:",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 1:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while v != 0:",
      "mutated_line": "while v != -1:",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != -1:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while v != 0:",
      "mutated_line": "while v != 1:",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 1:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "v -= v & -v",
      "mutated_line": "v -= v | -v",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v | -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 5 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 5 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 3 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 3 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 0 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 0 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 1 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 1 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = -4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = -4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 * N + (pow(2, N, mod) - 1) / (N - 4) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) / (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 * N + (pow(2, N, mod) - 1 + (N - 4)) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1 + (N - 4)) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 * N + (pow(2, N, mod) - 1) ** (N - 4) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) ** (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) + 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) + 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod)) * 2 % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod)) * 2 % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "update(x, 1)",
      "mutated_line": "update(x, 2)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 2)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "update(x, 1)",
      "mutated_line": "update(x, 0)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 0)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "update(x, 1)",
      "mutated_line": "update(x, 0)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 0)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "update(x, 1)",
      "mutated_line": "update(x, -1)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, -1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "BIT = [0] * (LEN + 1)",
      "mutated_line": "BIT = [1] * (LEN + 1)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [1] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "BIT = [0] * (LEN + 1)",
      "mutated_line": "BIT = [-1] * (LEN + 1)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [-1] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "BIT = [0] * (LEN + 1)",
      "mutated_line": "BIT = [1] * (LEN + 1)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [1] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "BIT = [0] * (LEN + 1)",
      "mutated_line": "BIT = [0] * (LEN + 2)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 2)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "BIT = [0] * (LEN + 1)",
      "mutated_line": "BIT = [0] * (LEN + 0)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 0)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "BIT = [0] * (LEN + 1)",
      "mutated_line": "BIT = [0] * (LEN + 0)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 0)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "BIT = [0] * (LEN + 1)",
      "mutated_line": "BIT = [0] * (LEN + -1)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + -1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) + 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) + 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod)) * 2 % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod)) * 2 % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "update(x, 1)",
      "mutated_line": "update(x, 2)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 2)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "update(x, 1)",
      "mutated_line": "update(x, 0)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 0)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "update(x, 1)",
      "mutated_line": "update(x, 0)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 0)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "update(x, 1)",
      "mutated_line": "update(x, -1)",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, -1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "points = [[compression_dict_x[x] + 1, y] for (x, y) in points]",
      "mutated_line": "points = [[compression_dict_x[x] + 2, y] for (x, y) in points]",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 2, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "points = [[compression_dict_x[x] + 1, y] for (x, y) in points]",
      "mutated_line": "points = [[compression_dict_x[x] + 0, y] for (x, y) in points]",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 0, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "points = [[compression_dict_x[x] + 1, y] for (x, y) in points]",
      "mutated_line": "points = [[compression_dict_x[x] + 0, y] for (x, y) in points]",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 0, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "points = [[compression_dict_x[x] + 1, y] for (x, y) in points]",
      "mutated_line": "points = [[compression_dict_x[x] + -1, y] for (x, y) in points]",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + -1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "v += v & -v",
      "mutated_line": "v += v & +v",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & +v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "v -= v & -v",
      "mutated_line": "v -= v & +v",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & +v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 * N + (pow(2, N, mod) + 1) * (N - 4) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) + 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 * N + pow(2, N, mod) * 1 * (N - 4) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + pow(2, N, mod) * 1 * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N + 4) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N + 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N * 4) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N * 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) - pow(2, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) - pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = ((ANS + pow(2, left, mod)) * pow(2, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = ((ANS + pow(2, left, mod)) * pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 3) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 3) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 1) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 1) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 0) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 0) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 1) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 1) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - -2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - -2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) - pow(2, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) - pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = ((ANS + pow(2, left, mod)) * pow(2, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = ((ANS + pow(2, left, mod)) * pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 3) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 3) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 1) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 1) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 0) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 0) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 1) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 1) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - -2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - -2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "P_Y = sorted(points, key=lambda x: x[1])",
      "mutated_line": "P_Y = sorted(points, key=lambda x: x[2])",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[2])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "P_Y = sorted(points, key=lambda x: x[1])",
      "mutated_line": "P_Y = sorted(points, key=lambda x: x[0])",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[0])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "P_Y = sorted(points, key=lambda x: x[1])",
      "mutated_line": "P_Y = sorted(points, key=lambda x: x[0])",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[0])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "P_Y = sorted(points, key=lambda x: x[1])",
      "mutated_line": "P_Y = sorted(points, key=lambda x: x[-1])",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[-1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 * N + (pow(2, N, mod) - 2) * (N - 4) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 2) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 * N + (pow(2, N, mod) - 0) * (N - 4) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 0) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 * N + (pow(2, N, mod) - 0) * (N - 4) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 0) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 * N + (pow(2, N, mod) - -1) * (N - 4) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - -1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 5) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 5) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 3) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 3) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 0) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 0) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 1) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 1) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - -4) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - -4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS - pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS - pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS * pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS * pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS - pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS - pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS * pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS * pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 * N + (pow(3, N, mod) - 1) * (N - 4) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(3, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 * N + (pow(1, N, mod) - 1) * (N - 4) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(1, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 * N + (pow(0, N, mod) - 1) * (N - 4) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(0, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 * N + (pow(1, N, mod) - 1) * (N - 4) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(1, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod",
      "mutated_line": "ANS = 4 * N + (pow(-2, N, mod) - 1) * (N - 4) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(-2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(3, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(3, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(1, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(1, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(0, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(0, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(1, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(1, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(-2, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(-2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i + left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i + left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i * left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i * left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(3, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(3, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(1, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(1, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(0, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(0, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(1, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(1, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(-2, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(-2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i + left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i + left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i * left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i * left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(3, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(3, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(1, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(1, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(0, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(0, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(1, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(1, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(-2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(-2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(3, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(3, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(1, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(1, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(0, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(0, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(1, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(1, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "mutated_line": "ANS = (ANS + pow(-2, left, mod) + pow(2, i - left, mod) - 2) % mod",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(-2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}",
      "mutated_line": "compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[1] for p in points])))}",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[1] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}",
      "mutated_line": "compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[-1] for p in points])))}",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[-1] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[0] for p in points])))}",
      "mutated_line": "compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[1] for p in points])))}",
      "code": "def calculate_sum_of_f_over_subsets(points, mod=998244353):\n    N = len(points)\n    compression_dict_x = {a: ind for (ind, a) in enumerate(sorted(set([p[1] for p in points])))}\n    points = [[compression_dict_x[x] + 1, y] for (x, y) in points]\n    P_Y = sorted(points, key=lambda x: x[1])\n    LEN = len(compression_dict_x)\n    BIT = [0] * (LEN + 1)\n\n    def update(v, w):\n        while v <= LEN:\n            BIT[v] += w\n            v += v & -v\n\n    def getvalue(v):\n        ANS = 0\n        while v != 0:\n            ANS += BIT[v]\n            v -= v & -v\n        return ANS\n    ANS = 4 * N + (pow(2, N, mod) - 1) * (N - 4) % mod\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    P_Y.reverse()\n    BIT = [0] * (LEN + 1)\n    for i in range(N):\n        (x, y) = P_Y[i]\n        left = getvalue(x)\n        ANS = (ANS + pow(2, left, mod) + pow(2, i - left, mod) - 2) % mod\n        update(x, 1)\n    return ANS"
    }
  ]
}