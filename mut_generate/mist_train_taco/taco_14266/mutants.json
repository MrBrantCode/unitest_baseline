{
  "task_id": "taco_14266",
  "entry_point": "calculate_expected_moves",
  "mutant_count": 88,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):",
      "mutated_line": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000008):",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000008):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):",
      "mutated_line": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000006):",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000006):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):",
      "mutated_line": "def calculate_expected_moves(x, y, s, u, v, MOD=0):",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=0):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):",
      "mutated_line": "def calculate_expected_moves(x, y, s, u, v, MOD=1):",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):",
      "mutated_line": "def calculate_expected_moves(x, y, s, u, v, MOD=-1000000007):",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=-1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if s % x == 0 and (s // x) & (s // x - 1) == 0:",
      "mutated_line": "if s % x == 0 or s // x & s // x - 1 == 0:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 or s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "while n < 0:",
      "mutated_line": "while n <= 0:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n <= 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "while n < 0:",
      "mutated_line": "while n >= 0:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n >= 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "while n < 0:",
      "mutated_line": "while n != 0:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n != 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "ASR",
      "lineno": 5,
      "original_line": "n += m",
      "mutated_line": "n -= m",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n -= m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res = 1",
      "mutated_line": "res = 2",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 2\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res = 1",
      "mutated_line": "res = 0",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 0\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res = 1",
      "mutated_line": "res = 0",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 0\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "res = 1",
      "mutated_line": "res = -1",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = -1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if s % x == 0 and (s // x) & (s // x - 1) == 0:",
      "mutated_line": "if s % x != 0 and s // x & s // x - 1 == 0:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x != 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if s % x == 0 and (s // x) & (s // x - 1) == 0:",
      "mutated_line": "if s % x == 0 and s // x & s // x - 1 != 0:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 != 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "while n < 0:",
      "mutated_line": "while n < 1:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 1:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "while n < 0:",
      "mutated_line": "while n < -1:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < -1:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "while n < 0:",
      "mutated_line": "while n < 1:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 1:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if p % 2:",
      "mutated_line": "if p * 2:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p * 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "if p % 2:",
      "mutated_line": "if p + 2:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p + 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p //= 2",
      "mutated_line": "p //= 3",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 3\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p //= 2",
      "mutated_line": "p //= 1",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 1\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p //= 2",
      "mutated_line": "p //= 0",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 0\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p //= 2",
      "mutated_line": "p //= 1",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 1\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p //= 2",
      "mutated_line": "p //= -2",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= -2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if s % x == 0 and (s // x) & (s // x - 1) == 0:",
      "mutated_line": "if s * x == 0 and s // x & s // x - 1 == 0:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s * x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if s % x == 0 and (s // x) & (s // x - 1) == 0:",
      "mutated_line": "if s + x == 0 and s // x & s // x - 1 == 0:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s + x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if s % x == 0 and (s // x) & (s // x - 1) == 0:",
      "mutated_line": "if s % x == 1 and s // x & s // x - 1 == 0:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 1 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if s % x == 0 and (s // x) & (s // x - 1) == 0:",
      "mutated_line": "if s % x == -1 and s // x & s // x - 1 == 0:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == -1 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if s % x == 0 and (s // x) & (s // x - 1) == 0:",
      "mutated_line": "if s % x == 1 and s // x & s // x - 1 == 0:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 1 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if s % x == 0 and (s // x) & (s // x - 1) == 0:",
      "mutated_line": "if s % x == 0 and s // x | s // x - 1 == 0:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x | s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if s % x == 0 and (s // x) & (s // x - 1) == 0:",
      "mutated_line": "if s % x == 0 and s // x & s // x - 1 == 1:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 1:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if s % x == 0 and (s // x) & (s // x - 1) == 0:",
      "mutated_line": "if s % x == 0 and s // x & s // x - 1 == -1:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == -1:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if s % x == 0 and (s // x) & (s // x - 1) == 0:",
      "mutated_line": "if s % x == 0 and s // x & s // x - 1 == 1:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 1:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "inv = power(u, MOD - 2)",
      "mutated_line": "inv = power(u, MOD + 2)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD + 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "inv = power(u, MOD - 2)",
      "mutated_line": "inv = power(u, MOD * 2)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD * 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return mod(mod(mod(s // x) * v) * inv)",
      "mutated_line": "return mod(mod(mod(s // x) * v) / inv)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) / inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return mod(mod(mod(s // x) * v) * inv)",
      "mutated_line": "return mod(mod(mod(s // x) * v) + inv)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) + inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return mod(mod(mod(s // x) * v) * inv)",
      "mutated_line": "return mod(mod(mod(s // x) * v) ** inv)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) ** inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "inv = power(v - u, MOD - 2)",
      "mutated_line": "inv = power(v + u, MOD - 2)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v + u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "inv = power(v - u, MOD - 2)",
      "mutated_line": "inv = power(v * u, MOD - 2)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v * u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "inv = power(v - u, MOD - 2)",
      "mutated_line": "inv = power(v - u, MOD + 2)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD + 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "inv = power(v - u, MOD - 2)",
      "mutated_line": "inv = power(v - u, MOD * 2)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD * 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return mod(mod(mod(s // y) * v) * inv)",
      "mutated_line": "return mod(mod(mod(s // y) * v) / inv)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) / inv)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return mod(mod(mod(s // y) * v) * inv)",
      "mutated_line": "return mod(mod(mod(s // y) * v) + inv)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) + inv)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return mod(mod(mod(s // y) * v) * inv)",
      "mutated_line": "return mod(mod(mod(s // y) * v) ** inv)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) ** inv)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if p % 2:",
      "mutated_line": "if p % 3:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 3:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if p % 2:",
      "mutated_line": "if p % 1:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 1:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if p % 2:",
      "mutated_line": "if p % 0:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 0:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if p % 2:",
      "mutated_line": "if p % 1:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 1:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if p % 2:",
      "mutated_line": "if p % -2:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % -2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "n = mod(n * n)",
      "mutated_line": "n = mod(n / n)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n / n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "n = mod(n * n)",
      "mutated_line": "n = mod(n + n)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n + n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "n = mod(n * n)",
      "mutated_line": "n = mod(n ** n)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n ** n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if s % x == 0 and (s // x) & (s // x - 1) == 0:",
      "mutated_line": "if s % x == 0 and s / x & s // x - 1 == 0:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s / x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if s % x == 0 and (s // x) & (s // x - 1) == 0:",
      "mutated_line": "if s % x == 0 and s * x & s // x - 1 == 0:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s * x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if s % x == 0 and (s // x) & (s // x - 1) == 0:",
      "mutated_line": "if s % x == 0 and s // x & s // x + 1 == 0:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x + 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if s % x == 0 and (s // x) & (s // x - 1) == 0:",
      "mutated_line": "if s % x == 0 and s // x & s // x * 1 == 0:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x * 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "inv = power(u, MOD - 2)",
      "mutated_line": "inv = power(u, MOD - 3)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 3)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "inv = power(u, MOD - 2)",
      "mutated_line": "inv = power(u, MOD - 1)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 1)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "inv = power(u, MOD - 2)",
      "mutated_line": "inv = power(u, MOD - 0)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 0)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "inv = power(u, MOD - 2)",
      "mutated_line": "inv = power(u, MOD - 1)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 1)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "inv = power(u, MOD - 2)",
      "mutated_line": "inv = power(u, MOD - -2)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - -2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "inv = power(v - u, MOD - 2)",
      "mutated_line": "inv = power(v - u, MOD - 3)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 3)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "inv = power(v - u, MOD - 2)",
      "mutated_line": "inv = power(v - u, MOD - 1)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 1)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "inv = power(v - u, MOD - 2)",
      "mutated_line": "inv = power(v - u, MOD - 0)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 0)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "inv = power(v - u, MOD - 2)",
      "mutated_line": "inv = power(v - u, MOD - 1)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 1)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "inv = power(v - u, MOD - 2)",
      "mutated_line": "inv = power(v - u, MOD - -2)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - -2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res = mod(res * n)",
      "mutated_line": "res = mod(res / n)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res / n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res = mod(res * n)",
      "mutated_line": "res = mod(res + n)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res + n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "res = mod(res * n)",
      "mutated_line": "res = mod(res ** n)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res ** n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if s % x == 0 and (s // x) & (s // x - 1) == 0:",
      "mutated_line": "if s % x == 0 and s // x & s / x - 1 == 0:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s / x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if s % x == 0 and (s // x) & (s // x - 1) == 0:",
      "mutated_line": "if s % x == 0 and s // x & s * x - 1 == 0:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s * x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if s % x == 0 and (s // x) & (s // x - 1) == 0:",
      "mutated_line": "if s % x == 0 and s // x & s // x - 2 == 0:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 2 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if s % x == 0 and (s // x) & (s // x - 1) == 0:",
      "mutated_line": "if s % x == 0 and s // x & s // x - 0 == 0:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 0 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if s % x == 0 and (s // x) & (s // x - 1) == 0:",
      "mutated_line": "if s % x == 0 and s // x & s // x - 0 == 0:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 0 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if s % x == 0 and (s // x) & (s // x - 1) == 0:",
      "mutated_line": "if s % x == 0 and s // x & s // x - -1 == 0:",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - -1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return mod(mod(mod(s // x) * v) * inv)",
      "mutated_line": "return mod(mod(mod(s // x) / v) * inv)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) / v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return mod(mod(mod(s // x) * v) * inv)",
      "mutated_line": "return mod(mod(mod(s // x) + v) * inv)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) + v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return mod(mod(mod(s // x) * v) * inv)",
      "mutated_line": "return mod(mod(mod(s // x) ** v) * inv)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) ** v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return mod(mod(mod(s // y) * v) * inv)",
      "mutated_line": "return mod(mod(mod(s // y) / v) * inv)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) / v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return mod(mod(mod(s // y) * v) * inv)",
      "mutated_line": "return mod(mod(mod(s // y) + v) * inv)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) + v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return mod(mod(mod(s // y) * v) * inv)",
      "mutated_line": "return mod(mod(mod(s // y) ** v) * inv)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) ** v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return mod(mod(mod(s // x) * v) * inv)",
      "mutated_line": "return mod(mod(mod(s / x) * v) * inv)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s / x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return mod(mod(mod(s // x) * v) * inv)",
      "mutated_line": "return mod(mod(mod(s * x) * v) * inv)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s * x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s // y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return mod(mod(mod(s // y) * v) * inv)",
      "mutated_line": "return mod(mod(mod(s / y) * v) * inv)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s / y) * v) * inv)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "return mod(mod(mod(s // y) * v) * inv)",
      "mutated_line": "return mod(mod(mod(s * y) * v) * inv)",
      "code": "def calculate_expected_moves(x, y, s, u, v, MOD=1000000007):\n\n    def mod(n, m=MOD):\n        n %= m\n        while n < 0:\n            n += m\n        return n\n\n    def power(n, p):\n        res = 1\n        while p:\n            if p % 2:\n                res = mod(res * n)\n            p //= 2\n            n = mod(n * n)\n        return res\n    if s % x == 0 and s // x & s // x - 1 == 0:\n        inv = power(u, MOD - 2)\n        return mod(mod(mod(s // x) * v) * inv)\n    else:\n        inv = power(v - u, MOD - 2)\n        return mod(mod(mod(s * y) * v) * inv)"
    }
  ]
}