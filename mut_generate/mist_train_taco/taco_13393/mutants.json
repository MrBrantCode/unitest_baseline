{
  "task_id": "taco_13393",
  "entry_point": "make_array_good",
  "mutant_count": 98,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def make_array_good(n, a):\n    \"\"\"\"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if total_sum % 2 != 0:",
      "mutated_line": "return (0, [])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 == 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "target_sum = total_sum // 2",
      "mutated_line": "target_sum = total_sum / 2",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum / 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "target_sum = total_sum // 2",
      "mutated_line": "target_sum = total_sum * 2",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum * 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp = [False] * (target_sum + 1)",
      "mutated_line": "dp = [False] / (target_sum + 1)",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] / (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp = [False] * (target_sum + 1)",
      "mutated_line": "dp = [False] + (target_sum + 1)",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] + (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp = [False] * (target_sum + 1)",
      "mutated_line": "dp = [False] ** (target_sum + 1)",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] ** (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp[0] = True",
      "mutated_line": "dp[0] = False",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = False\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if total_sum % 2 != 0:",
      "mutated_line": "return (0, [])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum * 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if total_sum % 2 != 0:",
      "mutated_line": "return (0, [])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum + 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if total_sum % 2 != 0:",
      "mutated_line": "return (0, [])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 1:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if total_sum % 2 != 0:",
      "mutated_line": "return (0, [])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != -1:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if total_sum % 2 != 0:",
      "mutated_line": "return (0, [])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 1:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "target_sum = total_sum // 2",
      "mutated_line": "target_sum = total_sum // 3",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 3\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "target_sum = total_sum // 2",
      "mutated_line": "target_sum = total_sum // 1",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 1\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "target_sum = total_sum // 2",
      "mutated_line": "target_sum = total_sum // 0",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 0\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "target_sum = total_sum // 2",
      "mutated_line": "target_sum = total_sum // 1",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 1\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "target_sum = total_sum // 2",
      "mutated_line": "target_sum = total_sum // -2",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // -2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp = [False] * (target_sum + 1)",
      "mutated_line": "dp = [False] * (target_sum - 1)",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum - 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp = [False] * (target_sum + 1)",
      "mutated_line": "dp = [False] * (target_sum * 1)",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum * 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp[0] = True",
      "mutated_line": "dp[1] = True",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[1] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp[0] = True",
      "mutated_line": "dp[-1] = True",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[-1] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp[0] = True",
      "mutated_line": "dp[1] = True",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[1] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if a[i] % 2 != 0:",
      "mutated_line": "return (0, [])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if a[i] % 2 == 0:",
      "mutated_line": "if a[i] % 2 != 0:",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return 0, []",
      "mutated_line": "return (1, [])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return 0, []",
      "mutated_line": "return (-1, [])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (-1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return 0, []",
      "mutated_line": "return (1, [])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (1, [])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if total_sum % 2 != 0:",
      "mutated_line": "return (0, [])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 3 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if total_sum % 2 != 0:",
      "mutated_line": "return (0, [])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 1 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if total_sum % 2 != 0:",
      "mutated_line": "return (0, [])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 0 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if total_sum % 2 != 0:",
      "mutated_line": "return (0, [])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 1 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if total_sum % 2 != 0:",
      "mutated_line": "return (0, [])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % -2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 0, []",
      "mutated_line": "return (1, [])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (1, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 0, []",
      "mutated_line": "return (-1, [])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (-1, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 0, []",
      "mutated_line": "return (1, [])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (1, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp = [False] * (target_sum + 1)",
      "mutated_line": "dp = [True] * (target_sum + 1)",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [True] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp = [False] * (target_sum + 1)",
      "mutated_line": "dp = [False] * (target_sum + 2)",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 2)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp = [False] * (target_sum + 1)",
      "mutated_line": "dp = [False] * (target_sum + 0)",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 0)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp = [False] * (target_sum + 1)",
      "mutated_line": "dp = [False] * (target_sum + 0)",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 0)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp = [False] * (target_sum + 1)",
      "mutated_line": "dp = [False] * (target_sum + -1)",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + -1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for j in range(target_sum, num - 1, -1):",
      "mutated_line": "for j in range(target_sum, num + 1, -1):",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num + 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for j in range(target_sum, num - 1, -1):",
      "mutated_line": "for j in range(target_sum, num * 1, -1):",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num * 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "for j in range(target_sum, num - 1, -1):",
      "mutated_line": "for j in range(target_sum, num - 1, +1):",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, +1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return 0, []",
      "mutated_line": "return (1, [])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (1, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return 0, []",
      "mutated_line": "return (-1, [])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (-1, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return 0, []",
      "mutated_line": "return (1, [])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (1, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if a[i] % 2 != 0:",
      "mutated_line": "if a[i] * 2 != 0:",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] * 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if a[i] % 2 != 0:",
      "mutated_line": "if a[i] + 2 != 0:",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] + 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if a[i] % 2 != 0:",
      "mutated_line": "if a[i] % 2 != 1:",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 1:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if a[i] % 2 != 0:",
      "mutated_line": "if a[i] % 2 != -1:",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != -1:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if a[i] % 2 != 0:",
      "mutated_line": "if a[i] % 2 != 1:",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 1:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if a[i] % 2 == 0:",
      "mutated_line": "if a[i] * 2 == 0:",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] * 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "if a[i] % 2 == 0:",
      "mutated_line": "if a[i] + 2 == 0:",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] + 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if a[i] % 2 == 0:",
      "mutated_line": "if a[i] % 2 == 1:",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 1:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if a[i] % 2 == 0:",
      "mutated_line": "if a[i] % 2 == -1:",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == -1:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if a[i] % 2 == 0:",
      "mutated_line": "if a[i] % 2 == 1:",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 1:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(target_sum, num - 1, -1):",
      "mutated_line": "for j in range(target_sum, num - 2, -1):",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 2, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(target_sum, num - 1, -1):",
      "mutated_line": "for j in range(target_sum, num - 0, -1):",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 0, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(target_sum, num - 1, -1):",
      "mutated_line": "for j in range(target_sum, num - 0, -1):",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 0, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(target_sum, num - 1, -1):",
      "mutated_line": "for j in range(target_sum, num - -1, -1):",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - -1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(target_sum, num - 1, -1):",
      "mutated_line": "for j in range(target_sum, num - 1, -2):",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -2):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(target_sum, num - 1, -1):",
      "mutated_line": "for j in range(target_sum, num - 1, -0):",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -0):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(target_sum, num - 1, -1):",
      "mutated_line": "for j in range(target_sum, num - 1, -0):",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -0):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(target_sum, num - 1, -1):",
      "mutated_line": "for j in range(target_sum, num - 1, --1):",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, --1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if dp[j - num]:",
      "mutated_line": "if dp[j + num]:",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j + num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if dp[j - num]:",
      "mutated_line": "if dp[j * num]:",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j * num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[j] = True",
      "mutated_line": "dp[j] = False",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = False\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if a[i] % 2 != 0:",
      "mutated_line": "if a[i] % 3 != 0:",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 3 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if a[i] % 2 != 0:",
      "mutated_line": "if a[i] % 1 != 0:",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 1 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if a[i] % 2 != 0:",
      "mutated_line": "if a[i] % 0 != 0:",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 0 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if a[i] % 2 != 0:",
      "mutated_line": "if a[i] % 1 != 0:",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 1 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if a[i] % 2 != 0:",
      "mutated_line": "if a[i] % -2 != 0:",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % -2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 1, [i + 1]",
      "mutated_line": "return (2, [i + 1])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (2, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 1, [i + 1]",
      "mutated_line": "return (0, [i + 1])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (0, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 1, [i + 1]",
      "mutated_line": "return (0, [i + 1])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (0, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 1, [i + 1]",
      "mutated_line": "return (-1, [i + 1])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (-1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if a[i] % 2 == 0:",
      "mutated_line": "if a[i] % 3 == 0:",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 3 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if a[i] % 2 == 0:",
      "mutated_line": "if a[i] % 1 == 0:",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 1 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if a[i] % 2 == 0:",
      "mutated_line": "if a[i] % 0 == 0:",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 0 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if a[i] % 2 == 0:",
      "mutated_line": "if a[i] % 1 == 0:",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 1 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if a[i] % 2 == 0:",
      "mutated_line": "if a[i] % -2 == 0:",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % -2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return 1, [i + 1]",
      "mutated_line": "return (2, [i + 1])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (2, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return 1, [i + 1]",
      "mutated_line": "return (0, [i + 1])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (0, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return 1, [i + 1]",
      "mutated_line": "return (0, [i + 1])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (0, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return 1, [i + 1]",
      "mutated_line": "return (-1, [i + 1])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (-1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return 1, [i + 1]",
      "mutated_line": "return (1, [i - 1])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i - 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return 1, [i + 1]",
      "mutated_line": "return (1, [i * 1])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i * 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return 1, [i + 1]",
      "mutated_line": "return (1, [i - 1])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i - 1])\n    return (0, [])"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "return 1, [i + 1]",
      "mutated_line": "return (1, [i * 1])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i * 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 1, [i + 1]",
      "mutated_line": "return (1, [i + 2])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 2])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 1, [i + 1]",
      "mutated_line": "return (1, [i + 0])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 0])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 1, [i + 1]",
      "mutated_line": "return (1, [i + 0])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 0])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 1, [i + 1]",
      "mutated_line": "return (1, [i + -1])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + -1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 1])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return 1, [i + 1]",
      "mutated_line": "return (1, [i + 2])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 2])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return 1, [i + 1]",
      "mutated_line": "return (1, [i + 0])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 0])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return 1, [i + 1]",
      "mutated_line": "return (1, [i + 0])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + 0])\n    return (0, [])"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "return 1, [i + 1]",
      "mutated_line": "return (1, [i + -1])",
      "code": "def make_array_good(n, a):\n    \"\"\"\n    Determines the minimum number of elements to remove from array `a` of length `n`\n    to make it a \"good\" array. An array is \"good\" if there's no way to partition it\n    into 2 subsequences such that the sum of the elements in the first is equal to\n    the sum of the elements in the second.\n\n    Parameters:\n    n (int): The length of the array.\n    a (list of int): The array of integers.\n\n    Returns:\n    tuple: A tuple containing:\n           - The minimum number of elements to remove (int).\n           - The indices of the elements to remove (list of int).\n    \"\"\"\n    total_sum = sum(a)\n    if total_sum % 2 != 0:\n        return (0, [])\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in a:\n        for j in range(target_sum, num - 1, -1):\n            if dp[j - num]:\n                dp[j] = True\n    if not dp[target_sum]:\n        return (0, [])\n    for i in range(n):\n        if a[i] % 2 != 0:\n            return (1, [i + 1])\n    for i in range(n):\n        if a[i] % 2 == 0:\n            return (1, [i + -1])\n    return (0, [])"
    }
  ]
}