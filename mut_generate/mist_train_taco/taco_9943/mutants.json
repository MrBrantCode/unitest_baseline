{
  "task_id": "taco_9943",
  "entry_point": "gcd",
  "mutant_count": 98,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if b == 0:",
      "mutated_line": "if b != 0:",
      "code": "def gcd(a, b):\n    if b != 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if (num ^ den < 0 and num > 0) and (num ^ den > 0 and num < 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if (num ^ den < 0 and num > 0) and (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "maxhits = [1] * (n + 1)",
      "mutated_line": "maxhits = [1] / (n + 1)",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] / (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "maxhits = [1] * (n + 1)",
      "mutated_line": "maxhits = [1] + (n + 1)",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] + (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "maxhits = [1] * (n + 1)",
      "mutated_line": "maxhits = [1] ** (n + 1)",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] ** (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "maxhits[0] = 0",
      "mutated_line": "maxhits[0] = 1",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 1\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "maxhits[0] = 0",
      "mutated_line": "maxhits[0] = -1",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = -1\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "maxhits[0] = 0",
      "mutated_line": "maxhits[0] = 1",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 1\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if b == 0:",
      "mutated_line": "if b == 1:",
      "code": "def gcd(a, b):\n    if b == 1:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if b == 0:",
      "mutated_line": "if b == -1:",
      "code": "def gcd(a, b):\n    if b == -1:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if b == 0:",
      "mutated_line": "if b == 1:",
      "code": "def gcd(a, b):\n    if b == 1:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return gcd(b, a % b)",
      "mutated_line": "return gcd(b, a * b)",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a * b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return gcd(b, a % b)",
      "mutated_line": "return gcd(b, a + b)",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a + b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if (num ^ den < 0 or num > 0) or (num ^ den > 0 and num < 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if (num ^ den < 0 or num > 0) or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 or num < 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 or num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "num = -num",
      "mutated_line": "num = +num",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = +num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "den = -den",
      "mutated_line": "den = +den",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = +den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "maxhits = [1] * (n + 1)",
      "mutated_line": "maxhits = [1] * (n - 1)",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n - 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "maxhits = [1] * (n + 1)",
      "mutated_line": "maxhits = [1] * (n * 1)",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n * 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "maxhits[0] = 0",
      "mutated_line": "maxhits[1] = 0",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[1] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "maxhits[0] = 0",
      "mutated_line": "maxhits[-1] = 0",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[-1] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "maxhits[0] = 0",
      "mutated_line": "maxhits[1] = 0",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[1] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den <= 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den <= 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den >= 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den >= 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den != 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den != 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den < 0 and num >= 0 or (num ^ den > 0 and num < 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num >= 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den < 0 and num <= 0 or (num ^ den > 0 and num < 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num <= 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den < 0 and num != 0 or (num ^ den > 0 and num < 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num != 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den < 0 and num > 0 or (num ^ den >= 0 and num < 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den >= 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den < 0 and num > 0 or (num ^ den <= 0 and num < 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den <= 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den < 0 and num > 0 or (num ^ den != 0 and num < 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den != 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num <= 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num <= 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num >= 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num >= 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num != 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num != 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "maxhits = [1] * (n + 1)",
      "mutated_line": "maxhits = [2] * (n + 1)",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [2] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "maxhits = [1] * (n + 1)",
      "mutated_line": "maxhits = [0] * (n + 1)",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [0] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "maxhits = [1] * (n + 1)",
      "mutated_line": "maxhits = [0] * (n + 1)",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [0] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "maxhits = [1] * (n + 1)",
      "mutated_line": "maxhits = [-1] * (n + 1)",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [-1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "maxhits = [1] * (n + 1)",
      "mutated_line": "maxhits = [1] * (n + 2)",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 2)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "maxhits = [1] * (n + 1)",
      "mutated_line": "maxhits = [1] * (n + 0)",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 0)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "maxhits = [1] * (n + 1)",
      "mutated_line": "maxhits = [1] * (n + 0)",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 0)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "maxhits = [1] * (n + 1)",
      "mutated_line": "maxhits = [1] * (n + -1)",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + -1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "xs = [flamingo[0] for flamingo in flamingos]",
      "mutated_line": "xs = [flamingo[1] for flamingo in flamingos]",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[1] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "xs = [flamingo[0] for flamingo in flamingos]",
      "mutated_line": "xs = [flamingo[-1] for flamingo in flamingos]",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[-1] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "xs = [flamingo[0] for flamingo in flamingos]",
      "mutated_line": "xs = [flamingo[1] for flamingo in flamingos]",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[1] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ys = [flamingo[1] for flamingo in flamingos]",
      "mutated_line": "ys = [flamingo[2] for flamingo in flamingos]",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[2] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ys = [flamingo[1] for flamingo in flamingos]",
      "mutated_line": "ys = [flamingo[0] for flamingo in flamingos]",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[0] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ys = [flamingo[1] for flamingo in flamingos]",
      "mutated_line": "ys = [flamingo[0] for flamingo in flamingos]",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[0] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ys = [flamingo[1] for flamingo in flamingos]",
      "mutated_line": "ys = [flamingo[-1] for flamingo in flamingos]",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[-1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dy = ys[i] - ys[j]",
      "mutated_line": "dy = ys[i] + ys[j]",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] + ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dy = ys[i] - ys[j]",
      "mutated_line": "dy = ys[i] * ys[j]",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] * ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dx = xs[i] - xs[j]",
      "mutated_line": "dx = xs[i] + xs[j]",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] + xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dx = xs[i] - xs[j]",
      "mutated_line": "dx = xs[i] * xs[j]",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] * xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if dy == 0:",
      "mutated_line": "if dy != 0:",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy != 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num | den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num | den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den < 1 and num > 0 or (num ^ den > 0 and num < 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 1 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den < -1 and num > 0 or (num ^ den > 0 and num < 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < -1 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den < 1 and num > 0 or (num ^ den > 0 and num < 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 1 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den < 0 and num > 1 or (num ^ den > 0 and num < 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 1 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den < 0 and num > -1 or (num ^ den > 0 and num < 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > -1 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den < 0 and num > 1 or (num ^ den > 0 and num < 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 1 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den < 0 and num > 0 or (num | den > 0 and num < 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num | den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den < 0 and num > 0 or (num ^ den > 1 and num < 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 1 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den < 0 and num > 0 or (num ^ den > -1 and num < 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > -1 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den < 0 and num > 0 or (num ^ den > 1 and num < 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 1 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 1):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 1):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < -1):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < -1):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):",
      "mutated_line": "if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 1):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 1):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if dy == 0:",
      "mutated_line": "if dy == 1:",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 1:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if dy == 0:",
      "mutated_line": "if dy == -1:",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == -1:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if dy == 0:",
      "mutated_line": "if dy == 1:",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 1:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "c_prime = ys[i] * dx - xs[i] * dy",
      "mutated_line": "c_prime = ys[i] * dx + xs[i] * dy",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx + xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "c_prime = ys[i] * dx - xs[i] * dy",
      "mutated_line": "c_prime = ys[i] * dx * (xs[i] * dy)",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx * (xs[i] * dy)\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "x_intercept = -c_prime / dy",
      "mutated_line": "x_intercept = -c_prime * dy",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime * dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "x_intercept = -c_prime / dy",
      "mutated_line": "x_intercept = -c_prime // dy",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime // dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if line in line_to_points:",
      "mutated_line": "if line not in line_to_points:",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line not in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):",
      "mutated_line": "if int(x_intercept) == x_intercept or x_intercept <= n or x_intercept > 0:",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept or x_intercept <= n or x_intercept > 0:\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "x_intercept = int(line[1])",
      "mutated_line": "x_intercept = int(line[2])",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[2])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "x_intercept = int(line[1])",
      "mutated_line": "x_intercept = int(line[0])",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[0])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "x_intercept = int(line[1])",
      "mutated_line": "x_intercept = int(line[0])",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[0])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "x_intercept = int(line[1])",
      "mutated_line": "x_intercept = int(line[-1])",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[-1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "c_prime = ys[i] * dx - xs[i] * dy",
      "mutated_line": "c_prime = ys[i] / dx - xs[i] * dy",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] / dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "c_prime = ys[i] * dx - xs[i] * dy",
      "mutated_line": "c_prime = ys[i] + dx - xs[i] * dy",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] + dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "c_prime = ys[i] * dx - xs[i] * dy",
      "mutated_line": "c_prime = ys[i] ** dx - xs[i] * dy",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] ** dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "c_prime = ys[i] * dx - xs[i] * dy",
      "mutated_line": "c_prime = ys[i] * dx - xs[i] / dy",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] / dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "c_prime = ys[i] * dx - xs[i] * dy",
      "mutated_line": "c_prime = ys[i] * dx - (xs[i] + dy)",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - (xs[i] + dy)\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "c_prime = ys[i] * dx - xs[i] * dy",
      "mutated_line": "c_prime = ys[i] * dx - xs[i] ** dy",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] ** dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "x_intercept = -c_prime / dy",
      "mutated_line": "x_intercept = +c_prime / dy",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = +c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):",
      "mutated_line": "if int(x_intercept) != x_intercept and x_intercept <= n and (x_intercept > 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) != x_intercept and x_intercept <= n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):",
      "mutated_line": "if int(x_intercept) == x_intercept and x_intercept < n and (x_intercept > 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept < n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):",
      "mutated_line": "if int(x_intercept) == x_intercept and x_intercept > n and (x_intercept > 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept > n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):",
      "mutated_line": "if int(x_intercept) == x_intercept and x_intercept == n and (x_intercept > 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept == n and (x_intercept > 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):",
      "mutated_line": "if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept >= 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept >= 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):",
      "mutated_line": "if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept <= 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept <= 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):",
      "mutated_line": "if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept != 0):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept != 0):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):",
      "mutated_line": "if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 1):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 1):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):",
      "mutated_line": "if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > -1):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > -1):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 0):",
      "mutated_line": "if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 1):",
      "code": "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef normalize_rational(num, den):\n    if num ^ den < 0 and num > 0 or (num ^ den > 0 and num < 0):\n        num = -num\n        den = -den\n    g = gcd(abs(num), abs(den))\n    num //= g\n    den //= g\n    return (num, den)\n\ndef calculate_max_flamingos_seen(n, m, flamingos):\n    maxhits = [1] * (n + 1)\n    maxhits[0] = 0\n    xs = [flamingo[0] for flamingo in flamingos]\n    ys = [flamingo[1] for flamingo in flamingos]\n    line_to_points = {}\n    for i in range(m):\n        for j in range(m):\n            dy = ys[i] - ys[j]\n            dx = xs[i] - xs[j]\n            if dy == 0:\n                continue\n            else:\n                slope = normalize_rational(dy, dx)\n                c_prime = ys[i] * dx - xs[i] * dy\n                x_intercept = -c_prime / dy\n                line = (slope, x_intercept)\n                if line in line_to_points:\n                    points = line_to_points[line]\n                    points.add(i)\n                    points.add(j)\n                    continue\n                if int(x_intercept) == x_intercept and x_intercept <= n and (x_intercept > 1):\n                    points = set([i, j])\n                    line_to_points[line] = points\n    for (line, points) in line_to_points.items():\n        x_intercept = int(line[1])\n        maxhits[x_intercept] = max(maxhits[x_intercept], len(points))\n    return sum(maxhits)"
    }
  ]
}