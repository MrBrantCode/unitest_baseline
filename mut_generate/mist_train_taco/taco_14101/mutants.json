{
  "task_id": "taco_14101",
  "entry_point": "count_ways_to_open_door",
  "mutant_count": 217,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 998244354",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244354\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 998244352",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244352\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 0",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 0\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 1",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 1\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = -998244353",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = -998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [1] / (n + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] / (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [1] + (n + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] + (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [1] ** (n + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] ** (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "rfact = [1] * (n + 1)",
      "mutated_line": "rfact = [1] / (n + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] / (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "rfact = [1] * (n + 1)",
      "mutated_line": "rfact = [1] + (n + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] + (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "rfact = [1] * (n + 1)",
      "mutated_line": "rfact = [1] ** (n + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] ** (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "on = [0] * (n * 2 + 1)",
      "mutated_line": "on = [0] / (n * 2 + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] / (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "on = [0] * (n * 2 + 1)",
      "mutated_line": "on = [0] + (n * 2 + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] + (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "on = [0] * (n * 2 + 1)",
      "mutated_line": "on = [0] ** (n * 2 + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] ** (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "off = [0] * (n * 2 + 2)",
      "mutated_line": "off = [0] / (n * 2 + 2)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] / (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "off = [0] * (n * 2 + 2)",
      "mutated_line": "off = [0] + (n * 2 + 2)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] + (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "off = [0] * (n * 2 + 2)",
      "mutated_line": "off = [0] ** (n * 2 + 2)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] ** (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "on[l] += 1",
      "mutated_line": "on[l] -= 1",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] -= 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "off[r + 1] += 1",
      "mutated_line": "off[r + 1] -= 1",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] -= 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 1\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = -1\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 1\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "cum = 0",
      "mutated_line": "cum = 1",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 1\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "cum = 0",
      "mutated_line": "cum = -1",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = -1\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "cum = 0",
      "mutated_line": "cum = 1",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 1\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "cum -= off[i]",
      "mutated_line": "cum += off[i]",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum += off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 46,
      "original_line": "cum += on[i]",
      "mutated_line": "cum -= on[i]",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum -= on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [1] * (n - 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n - 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [1] * (n * 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n * 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "rfact = [1] * (n + 1)",
      "mutated_line": "rfact = [1] * (n - 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n - 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "rfact = [1] * (n + 1)",
      "mutated_line": "rfact = [1] * (n * 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n * 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(0, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(0, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(-1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n - 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n * 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i - 1] * i * MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i * MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i - 1] * i + MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i + MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "rfact[n] = pow(fact[n], MOD - 2, MOD)",
      "mutated_line": "rfact[n] = pow(fact[n], MOD + 2, MOD)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD + 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "rfact[n] = pow(fact[n], MOD - 2, MOD)",
      "mutated_line": "rfact[n] = pow(fact[n], MOD * 2, MOD)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD * 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n, 0, -1):",
      "mutated_line": "for i in range(n, 1, -1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 1, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n, 0, -1):",
      "mutated_line": "for i in range(n, -1, -1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, -1, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n, 0, -1):",
      "mutated_line": "for i in range(n, 1, -1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 1, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "for i in range(n, 0, -1):",
      "mutated_line": "for i in range(n, 0, +1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, +1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "rfact[i - 1] = rfact[i] * i % MOD",
      "mutated_line": "rfact[i - 1] = rfact[i] * i * MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i * MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "rfact[i - 1] = rfact[i] * i % MOD",
      "mutated_line": "rfact[i - 1] = rfact[i] * i + MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i + MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return fact[n] * rfact[n - k] % MOD",
      "mutated_line": "return fact[n] * rfact[n - k] * MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] * MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return fact[n] * rfact[n - k] % MOD",
      "mutated_line": "return fact[n] * rfact[n - k] + MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] + MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return fact[n] * rfact[k] * rfact[n - k] % MOD",
      "mutated_line": "return fact[n] * rfact[k] * rfact[n - k] * MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] * MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return fact[n] * rfact[k] * rfact[n - k] % MOD",
      "mutated_line": "return fact[n] * rfact[k] * rfact[n - k] + MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] + MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}",
      "mutated_line": "compLR = {e: i - 1 for (i, e) in enumerate(sorted(set(L + R)))}",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i - 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}",
      "mutated_line": "compLR = {e: i * 1 for (i, e) in enumerate(sorted(set(L + R)))}",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i * 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "on = [0] * (n * 2 + 1)",
      "mutated_line": "on = [0] * (n * 2 - 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 - 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "on = [0] * (n * 2 + 1)",
      "mutated_line": "on = [0] * (n * 2 * 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 * 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "off = [0] * (n * 2 + 2)",
      "mutated_line": "off = [0] * (n * 2 - 2)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 - 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "off = [0] * (n * 2 + 2)",
      "mutated_line": "off = [0] * (n * 2 * 2)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 * 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "on[l] += 1",
      "mutated_line": "on[l] += 2",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 2\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "on[l] += 1",
      "mutated_line": "on[l] += 0",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 0\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "on[l] += 1",
      "mutated_line": "on[l] += 0",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 0\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "on[l] += 1",
      "mutated_line": "on[l] += -1",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += -1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "off[r + 1] += 1",
      "mutated_line": "off[r + 1] += 2",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 2\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "off[r + 1] += 1",
      "mutated_line": "off[r + 1] += 0",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 0\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "off[r + 1] += 1",
      "mutated_line": "off[r + 1] += 0",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 0\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "off[r + 1] += 1",
      "mutated_line": "off[r + 1] += -1",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += -1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n * 2 + 1):",
      "mutated_line": "for i in range(2, n * 2 + 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(2, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n * 2 + 1):",
      "mutated_line": "for i in range(0, n * 2 + 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(0, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n * 2 + 1):",
      "mutated_line": "for i in range(0, n * 2 + 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(0, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n * 2 + 1):",
      "mutated_line": "for i in range(-1, n * 2 + 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(-1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for i in range(1, n * 2 + 1):",
      "mutated_line": "for i in range(1, n * 2 - 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 - 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for i in range(1, n * 2 + 1):",
      "mutated_line": "for i in range(1, n * 2 * 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 * 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [2] * (n + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [2] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [0] * (n + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [0] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [0] * (n + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [0] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [-1] * (n + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [-1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [1] * (n + 2)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 2)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [1] * (n + 0)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 0)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [1] * (n + 0)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 0)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "fact = [1] * (n + 1)",
      "mutated_line": "fact = [1] * (n + -1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + -1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rfact = [1] * (n + 1)",
      "mutated_line": "rfact = [2] * (n + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [2] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rfact = [1] * (n + 1)",
      "mutated_line": "rfact = [0] * (n + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [0] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rfact = [1] * (n + 1)",
      "mutated_line": "rfact = [0] * (n + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [0] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rfact = [1] * (n + 1)",
      "mutated_line": "rfact = [-1] * (n + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rfact = [1] * (n + 1)",
      "mutated_line": "rfact = [1] * (n + 2)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 2)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rfact = [1] * (n + 1)",
      "mutated_line": "rfact = [1] * (n + 0)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 0)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rfact = [1] * (n + 1)",
      "mutated_line": "rfact = [1] * (n + 0)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 0)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "rfact = [1] * (n + 1)",
      "mutated_line": "rfact = [1] * (n + -1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + -1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 2):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 0):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 0):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + -1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i - 1] / i % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] / i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = (fact[i - 1] + i) % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = (fact[i - 1] + i) % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i - 1] ** i % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] ** i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "rfact[n] = pow(fact[n], MOD - 2, MOD)",
      "mutated_line": "rfact[n] = pow(fact[n], MOD - 3, MOD)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 3, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "rfact[n] = pow(fact[n], MOD - 2, MOD)",
      "mutated_line": "rfact[n] = pow(fact[n], MOD - 1, MOD)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 1, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "rfact[n] = pow(fact[n], MOD - 2, MOD)",
      "mutated_line": "rfact[n] = pow(fact[n], MOD - 0, MOD)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 0, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "rfact[n] = pow(fact[n], MOD - 2, MOD)",
      "mutated_line": "rfact[n] = pow(fact[n], MOD - 1, MOD)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 1, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "rfact[n] = pow(fact[n], MOD - 2, MOD)",
      "mutated_line": "rfact[n] = pow(fact[n], MOD - -2, MOD)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - -2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n, 0, -1):",
      "mutated_line": "for i in range(n, 0, -2):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -2):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n, 0, -1):",
      "mutated_line": "for i in range(n, 0, -0):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -0):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n, 0, -1):",
      "mutated_line": "for i in range(n, 0, -0):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -0):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(n, 0, -1):",
      "mutated_line": "for i in range(n, 0, --1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, --1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "rfact[i - 1] = rfact[i] * i % MOD",
      "mutated_line": "rfact[i + 1] = rfact[i] * i % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i + 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "rfact[i - 1] = rfact[i] * i % MOD",
      "mutated_line": "rfact[i * 1] = rfact[i] * i % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i * 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "rfact[i - 1] = rfact[i] * i % MOD",
      "mutated_line": "rfact[i - 1] = rfact[i] / i % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] / i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "rfact[i - 1] = rfact[i] * i % MOD",
      "mutated_line": "rfact[i - 1] = (rfact[i] + i) % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = (rfact[i] + i) % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "rfact[i - 1] = rfact[i] * i % MOD",
      "mutated_line": "rfact[i - 1] = rfact[i] ** i % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] ** i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return fact[n] * rfact[n - k] % MOD",
      "mutated_line": "return fact[n] / rfact[n - k] % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] / rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return fact[n] * rfact[n - k] % MOD",
      "mutated_line": "return (fact[n] + rfact[n - k]) % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return (fact[n] + rfact[n - k]) % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return fact[n] * rfact[n - k] % MOD",
      "mutated_line": "return fact[n] ** rfact[n - k] % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] ** rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return fact[n] * rfact[k] * rfact[n - k] % MOD",
      "mutated_line": "return fact[n] * rfact[k] / rfact[n - k] % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] / rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return fact[n] * rfact[k] * rfact[n - k] % MOD",
      "mutated_line": "return (fact[n] * rfact[k] + rfact[n - k]) % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return (fact[n] * rfact[k] + rfact[n - k]) % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return fact[n] * rfact[k] * rfact[n - k] % MOD",
      "mutated_line": "return (fact[n] * rfact[k]) ** rfact[n - k] % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return (fact[n] * rfact[k]) ** rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "L = [lamp[0] for lamp in lamps]",
      "mutated_line": "L = [lamp[1] for lamp in lamps]",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[1] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "L = [lamp[0] for lamp in lamps]",
      "mutated_line": "L = [lamp[-1] for lamp in lamps]",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[-1] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "L = [lamp[0] for lamp in lamps]",
      "mutated_line": "L = [lamp[1] for lamp in lamps]",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[1] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "R = [lamp[1] for lamp in lamps]",
      "mutated_line": "R = [lamp[2] for lamp in lamps]",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[2] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "R = [lamp[1] for lamp in lamps]",
      "mutated_line": "R = [lamp[0] for lamp in lamps]",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[0] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "R = [lamp[1] for lamp in lamps]",
      "mutated_line": "R = [lamp[0] for lamp in lamps]",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[0] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "R = [lamp[1] for lamp in lamps]",
      "mutated_line": "R = [lamp[-1] for lamp in lamps]",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[-1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}",
      "mutated_line": "compLR = {e: i + 2 for (i, e) in enumerate(sorted(set(L + R)))}",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 2 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}",
      "mutated_line": "compLR = {e: i + 0 for (i, e) in enumerate(sorted(set(L + R)))}",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 0 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}",
      "mutated_line": "compLR = {e: i + 0 for (i, e) in enumerate(sorted(set(L + R)))}",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 0 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}",
      "mutated_line": "compLR = {e: i + -1 for (i, e) in enumerate(sorted(set(L + R)))}",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + -1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "on = [0] * (n * 2 + 1)",
      "mutated_line": "on = [1] * (n * 2 + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [1] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "on = [0] * (n * 2 + 1)",
      "mutated_line": "on = [-1] * (n * 2 + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [-1] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "on = [0] * (n * 2 + 1)",
      "mutated_line": "on = [1] * (n * 2 + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [1] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "on = [0] * (n * 2 + 1)",
      "mutated_line": "on = [0] * (n / 2 + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n / 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "on = [0] * (n * 2 + 1)",
      "mutated_line": "on = [0] * (n + 2 + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n + 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "on = [0] * (n * 2 + 1)",
      "mutated_line": "on = [0] * (n ** 2 + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n ** 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "on = [0] * (n * 2 + 1)",
      "mutated_line": "on = [0] * (n * 2 + 2)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 2)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "on = [0] * (n * 2 + 1)",
      "mutated_line": "on = [0] * (n * 2 + 0)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 0)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "on = [0] * (n * 2 + 1)",
      "mutated_line": "on = [0] * (n * 2 + 0)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 0)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "on = [0] * (n * 2 + 1)",
      "mutated_line": "on = [0] * (n * 2 + -1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + -1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "off = [0] * (n * 2 + 2)",
      "mutated_line": "off = [1] * (n * 2 + 2)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [1] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "off = [0] * (n * 2 + 2)",
      "mutated_line": "off = [-1] * (n * 2 + 2)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [-1] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "off = [0] * (n * 2 + 2)",
      "mutated_line": "off = [1] * (n * 2 + 2)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [1] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "off = [0] * (n * 2 + 2)",
      "mutated_line": "off = [0] * (n / 2 + 2)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n / 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "off = [0] * (n * 2 + 2)",
      "mutated_line": "off = [0] * (n + 2 + 2)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n + 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "off = [0] * (n * 2 + 2)",
      "mutated_line": "off = [0] * (n ** 2 + 2)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n ** 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "off = [0] * (n * 2 + 2)",
      "mutated_line": "off = [0] * (n * 2 + 3)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 3)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "off = [0] * (n * 2 + 2)",
      "mutated_line": "off = [0] * (n * 2 + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 1)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "off = [0] * (n * 2 + 2)",
      "mutated_line": "off = [0] * (n * 2 + 0)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 0)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "off = [0] * (n * 2 + 2)",
      "mutated_line": "off = [0] * (n * 2 + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 1)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "off = [0] * (n * 2 + 2)",
      "mutated_line": "off = [0] * (n * 2 + -2)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + -2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "off[r + 1] += 1",
      "mutated_line": "off[r - 1] += 1",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r - 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "off[r + 1] += 1",
      "mutated_line": "off[r * 1] += 1",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r * 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for i in range(1, n * 2 + 1):",
      "mutated_line": "for i in range(1, n / 2 + 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n / 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for i in range(1, n * 2 + 1):",
      "mutated_line": "for i in range(1, n + 2 + 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n + 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for i in range(1, n * 2 + 1):",
      "mutated_line": "for i in range(1, n ** 2 + 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n ** 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n * 2 + 1):",
      "mutated_line": "for i in range(1, n * 2 + 2):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 2):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n * 2 + 1):",
      "mutated_line": "for i in range(1, n * 2 + 0):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 0):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n * 2 + 1):",
      "mutated_line": "for i in range(1, n * 2 + 0):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 0):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n * 2 + 1):",
      "mutated_line": "for i in range(1, n * 2 + -1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + -1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for j in range(1, on[i] + 1):",
      "mutated_line": "for j in range(2, on[i] + 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(2, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for j in range(1, on[i] + 1):",
      "mutated_line": "for j in range(0, on[i] + 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(0, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for j in range(1, on[i] + 1):",
      "mutated_line": "for j in range(0, on[i] + 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(0, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for j in range(1, on[i] + 1):",
      "mutated_line": "for j in range(-1, on[i] + 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(-1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for j in range(1, on[i] + 1):",
      "mutated_line": "for j in range(1, on[i] - 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] - 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for j in range(1, on[i] + 1):",
      "mutated_line": "for j in range(1, on[i] * 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] * 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "old = k - j",
      "mutated_line": "old = k + j",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k + j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "old = k - j",
      "mutated_line": "old = k * j",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k * j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if 0 <= old <= cum:",
      "mutated_line": "if 0 < old <= cum:",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 < old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if 0 <= old <= cum:",
      "mutated_line": "if 0 > old <= cum:",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 > old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if 0 <= old <= cum:",
      "mutated_line": "if 0 == old <= cum:",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 == old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "ans += comb(cum, old) * comb(on[i], j) % MOD",
      "mutated_line": "ans -= comb(cum, old) * comb(on[i], j) % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans -= comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "rfact[i - 1] = rfact[i] * i % MOD",
      "mutated_line": "rfact[i - 2] = rfact[i] * i % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 2] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "rfact[i - 1] = rfact[i] * i % MOD",
      "mutated_line": "rfact[i - 0] = rfact[i] * i % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 0] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "rfact[i - 1] = rfact[i] * i % MOD",
      "mutated_line": "rfact[i - 0] = rfact[i] * i % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 0] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "rfact[i - 1] = rfact[i] * i % MOD",
      "mutated_line": "rfact[i - -1] = rfact[i] * i % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - -1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return fact[n] * rfact[k] * rfact[n - k] % MOD",
      "mutated_line": "return fact[n] / rfact[k] * rfact[n - k] % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] / rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return fact[n] * rfact[k] * rfact[n - k] % MOD",
      "mutated_line": "return (fact[n] + rfact[k]) * rfact[n - k] % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return (fact[n] + rfact[k]) * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return fact[n] * rfact[k] * rfact[n - k] % MOD",
      "mutated_line": "return fact[n] ** rfact[k] * rfact[n - k] % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] ** rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "on = [0] * (n * 2 + 1)",
      "mutated_line": "on = [0] * (n * 3 + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 3 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "on = [0] * (n * 2 + 1)",
      "mutated_line": "on = [0] * (n * 1 + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 1 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "on = [0] * (n * 2 + 1)",
      "mutated_line": "on = [0] * (n * 0 + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 0 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "on = [0] * (n * 2 + 1)",
      "mutated_line": "on = [0] * (n * 1 + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 1 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "on = [0] * (n * 2 + 1)",
      "mutated_line": "on = [0] * (n * -2 + 1)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * -2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "off = [0] * (n * 2 + 2)",
      "mutated_line": "off = [0] * (n * 3 + 2)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 3 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "off = [0] * (n * 2 + 2)",
      "mutated_line": "off = [0] * (n * 1 + 2)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 1 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "off = [0] * (n * 2 + 2)",
      "mutated_line": "off = [0] * (n * 0 + 2)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 0 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "off = [0] * (n * 2 + 2)",
      "mutated_line": "off = [0] * (n * 1 + 2)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 1 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "off = [0] * (n * 2 + 2)",
      "mutated_line": "off = [0] * (n * -2 + 2)",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * -2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "off[r + 1] += 1",
      "mutated_line": "off[r + 2] += 1",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 2] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "off[r + 1] += 1",
      "mutated_line": "off[r + 0] += 1",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 0] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "off[r + 1] += 1",
      "mutated_line": "off[r + 0] += 1",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 0] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "off[r + 1] += 1",
      "mutated_line": "off[r + -1] += 1",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + -1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n * 2 + 1):",
      "mutated_line": "for i in range(1, n * 3 + 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 3 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n * 2 + 1):",
      "mutated_line": "for i in range(1, n * 1 + 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 1 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n * 2 + 1):",
      "mutated_line": "for i in range(1, n * 0 + 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 0 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n * 2 + 1):",
      "mutated_line": "for i in range(1, n * 1 + 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 1 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n * 2 + 1):",
      "mutated_line": "for i in range(1, n * -2 + 1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * -2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for j in range(1, on[i] + 1):",
      "mutated_line": "for j in range(1, on[i] + 2):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 2):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for j in range(1, on[i] + 1):",
      "mutated_line": "for j in range(1, on[i] + 0):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 0):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for j in range(1, on[i] + 1):",
      "mutated_line": "for j in range(1, on[i] + 0):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 0):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for j in range(1, on[i] + 1):",
      "mutated_line": "for j in range(1, on[i] + -1):",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + -1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= old <= cum:",
      "mutated_line": "if 1 <= old <= cum:",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 1 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= old <= cum:",
      "mutated_line": "if -1 <= old <= cum:",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if -1 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if 0 <= old <= cum:",
      "mutated_line": "if 1 <= old <= cum:",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 1 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "ans += comb(cum, old) * comb(on[i], j) % MOD",
      "mutated_line": "ans += comb(cum, old) * comb(on[i], j) * MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) * MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "ans += comb(cum, old) * comb(on[i], j) % MOD",
      "mutated_line": "ans += comb(cum, old) * comb(on[i], j) + MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) + MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i + 1] * i % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i + 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i * 1] * i % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i * 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return fact[n] * rfact[n - k] % MOD",
      "mutated_line": "return fact[n] * rfact[n + k] % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n + k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return fact[n] * rfact[n - k] % MOD",
      "mutated_line": "return fact[n] * rfact[n * k] % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n * k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return fact[n] * rfact[k] * rfact[n - k] % MOD",
      "mutated_line": "return fact[n] * rfact[k] * rfact[n + k] % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n + k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return fact[n] * rfact[k] * rfact[n - k] % MOD",
      "mutated_line": "return fact[n] * rfact[k] * rfact[n * k] % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n * k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "ans += comb(cum, old) * comb(on[i], j) % MOD",
      "mutated_line": "ans += comb(cum, old) / comb(on[i], j) % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) / comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "ans += comb(cum, old) * comb(on[i], j) % MOD",
      "mutated_line": "ans += (comb(cum, old) + comb(on[i], j)) % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += (comb(cum, old) + comb(on[i], j)) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "ans += comb(cum, old) * comb(on[i], j) % MOD",
      "mutated_line": "ans += comb(cum, old) ** comb(on[i], j) % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) ** comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i - 2] * i % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 2] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i - 0] * i % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 0] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i - 0] * i % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 0] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "fact[i] = fact[i - 1] * i % MOD",
      "mutated_line": "fact[i] = fact[i - -1] * i % MOD",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - -1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}",
      "mutated_line": "compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L - R)))}",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L - R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L + R)))}",
      "mutated_line": "compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L * R)))}",
      "code": "def count_ways_to_open_door(n, k, lamps):\n    MOD = 998244353\n    fact = [1] * (n + 1)\n    rfact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    rfact[n] = pow(fact[n], MOD - 2, MOD)\n    for i in range(n, 0, -1):\n        rfact[i - 1] = rfact[i] * i % MOD\n\n    def perm(n, k):\n        return fact[n] * rfact[n - k] % MOD\n\n    def comb(n, k):\n        return fact[n] * rfact[k] * rfact[n - k] % MOD\n    L = [lamp[0] for lamp in lamps]\n    R = [lamp[1] for lamp in lamps]\n    compLR = {e: i + 1 for (i, e) in enumerate(sorted(set(L * R)))}\n    for i in range(n):\n        L[i] = compLR[L[i]]\n        R[i] = compLR[R[i]]\n    on = [0] * (n * 2 + 1)\n    off = [0] * (n * 2 + 2)\n    for (l, r) in zip(L, R):\n        on[l] += 1\n        off[r + 1] += 1\n    ans = 0\n    cum = 0\n    for i in range(1, n * 2 + 1):\n        cum -= off[i]\n        for j in range(1, on[i] + 1):\n            old = k - j\n            if 0 <= old <= cum:\n                ans += comb(cum, old) * comb(on[i], j) % MOD\n            ans %= MOD\n        cum += on[i]\n    return ans"
    }
  ]
}