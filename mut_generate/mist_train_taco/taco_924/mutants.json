{
  "task_id": "taco_924",
  "entry_point": "calculate_expected_beauty",
  "mutant_count": 96,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i -= 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 1\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = -1\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 1\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "dfs(1, -1, 0)",
      "mutated_line": "dfs(2, -1, 0)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(2, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "dfs(1, -1, 0)",
      "mutated_line": "dfs(0, -1, 0)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(0, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "dfs(1, -1, 0)",
      "mutated_line": "dfs(0, -1, 0)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(0, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "dfs(1, -1, 0)",
      "mutated_line": "dfs(-1, -1, 0)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(-1, -1, 0)\n    return answer()"
    },
    {
      "operator": "UOI",
      "lineno": 47,
      "original_line": "dfs(1, -1, 0)",
      "mutated_line": "dfs(1, +1, 0)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, +1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "dfs(1, -1, 0)",
      "mutated_line": "dfs(1, -1, 1)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 1)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "dfs(1, -1, 0)",
      "mutated_line": "dfs(1, -1, -1)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, -1)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "dfs(1, -1, 0)",
      "mutated_line": "dfs(1, -1, 1)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 1)\n    return answer()"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.BITTree = [0] * (n + 1)",
      "mutated_line": "self.BITTree = [0] / (n + 1)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] / (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.BITTree = [0] * (n + 1)",
      "mutated_line": "self.BITTree = [0] + (n + 1)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] + (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.BITTree = [0] * (n + 1)",
      "mutated_line": "self.BITTree = [0] ** (n + 1)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] ** (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 1\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = -1\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 1\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "i = i + 1",
      "mutated_line": "i = i - 1",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i - 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "i = i + 1",
      "mutated_line": "i = i * 1",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i * 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i > 0:",
      "mutated_line": "while i >= 0:",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i >= 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i > 0:",
      "mutated_line": "while i <= 0:",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i <= 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "while i > 0:",
      "mutated_line": "while i != 0:",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i != 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "s += self.BITTree[i]",
      "mutated_line": "s -= self.BITTree[i]",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s -= self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "i -= i & -i",
      "mutated_line": "i += i & -i",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i += i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return self.getsum(r) - self.getsum(l - 1)",
      "mutated_line": "return self.getsum(r) + self.getsum(l - 1)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) + self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return self.getsum(r) - self.getsum(l - 1)",
      "mutated_line": "return self.getsum(r) * self.getsum(l - 1)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) * self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 2\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 0\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 0\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += -1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i <= self.size:",
      "mutated_line": "while i < self.size:",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i < self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i <= self.size:",
      "mutated_line": "while i > self.size:",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i > self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while i <= self.size:",
      "mutated_line": "while i == self.size:",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i == self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "self.BITTree[i] += v",
      "mutated_line": "self.BITTree[i] -= v",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] -= v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "i += i & -i",
      "mutated_line": "i -= i & -i",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i -= i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if i == prev:",
      "mutated_line": "if i != prev:",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i != prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "f = FenwickTree(n + 1)",
      "mutated_line": "f = FenwickTree(n - 1)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n - 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "f = FenwickTree(n + 1)",
      "mutated_line": "f = FenwickTree(n * 1)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n * 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "ans += f.query(1, j) - f.query(j, n)",
      "mutated_line": "ans -= f.query(1, j) - f.query(j, n)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans -= f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "dfs(1, -1, 0)",
      "mutated_line": "dfs(1, -2, 0)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -2, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "dfs(1, -1, 0)",
      "mutated_line": "dfs(1, -0, 0)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -0, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "dfs(1, -1, 0)",
      "mutated_line": "dfs(1, -0, 0)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -0, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "dfs(1, -1, 0)",
      "mutated_line": "dfs(1, --1, 0)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, --1, 0)\n    return answer()"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.BITTree = [0] * (n + 1)",
      "mutated_line": "self.BITTree = [0] * (n - 1)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n - 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "self.BITTree = [0] * (n + 1)",
      "mutated_line": "self.BITTree = [0] * (n * 1)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n * 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i = i + 1",
      "mutated_line": "i = i + 2",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 2\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i = i + 1",
      "mutated_line": "i = i + 0",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 0\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i = i + 1",
      "mutated_line": "i = i + 0",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 0\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "i = i + 1",
      "mutated_line": "i = i + -1",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + -1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while i > 0:",
      "mutated_line": "while i > 1:",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 1:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while i > 0:",
      "mutated_line": "while i > -1:",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > -1:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "while i > 0:",
      "mutated_line": "while i > 1:",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 1:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "i -= i & -i",
      "mutated_line": "i -= i | -i",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i | -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "i += i & -i",
      "mutated_line": "i += i | -i",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i | -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dfs(i, p, lvl + 1)",
      "mutated_line": "dfs(i, p, lvl - 1)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl - 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dfs(i, p, lvl + 1)",
      "mutated_line": "dfs(i, p, lvl * 1)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl * 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "f = FenwickTree(n + 1)",
      "mutated_line": "f = FenwickTree(n + 2)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 2)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "f = FenwickTree(n + 1)",
      "mutated_line": "f = FenwickTree(n + 0)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 0)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "f = FenwickTree(n + 1)",
      "mutated_line": "f = FenwickTree(n + 0)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 0)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "f = FenwickTree(n + 1)",
      "mutated_line": "f = FenwickTree(n + -1)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + -1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans += f.query(1, j) - f.query(j, n)",
      "mutated_line": "ans += f.query(1, j) + f.query(j, n)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) + f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans += f.query(1, j) - f.query(j, n)",
      "mutated_line": "ans += f.query(1, j) * f.query(j, n)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) * f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "child = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n - 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "child = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n * 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.BITTree = [0] * (n + 1)",
      "mutated_line": "self.BITTree = [1] * (n + 1)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [1] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.BITTree = [0] * (n + 1)",
      "mutated_line": "self.BITTree = [-1] * (n + 1)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [-1] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.BITTree = [0] * (n + 1)",
      "mutated_line": "self.BITTree = [1] * (n + 1)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [1] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.BITTree = [0] * (n + 1)",
      "mutated_line": "self.BITTree = [0] * (n + 2)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 2)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.BITTree = [0] * (n + 1)",
      "mutated_line": "self.BITTree = [0] * (n + 0)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 0)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.BITTree = [0] * (n + 1)",
      "mutated_line": "self.BITTree = [0] * (n + 0)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 0)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "self.BITTree = [0] * (n + 1)",
      "mutated_line": "self.BITTree = [0] * (n + -1)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + -1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "i -= i & -i",
      "mutated_line": "i -= i & +i",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & +i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return self.getsum(r) - self.getsum(l - 1)",
      "mutated_line": "return self.getsum(r) - self.getsum(l + 1)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l + 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return self.getsum(r) - self.getsum(l - 1)",
      "mutated_line": "return self.getsum(r) - self.getsum(l * 1)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l * 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "i += i & -i",
      "mutated_line": "i += i & +i",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & +i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dfs(i, p, lvl + 1)",
      "mutated_line": "dfs(i, p, lvl + 2)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 2)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dfs(i, p, lvl + 1)",
      "mutated_line": "dfs(i, p, lvl + 0)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 0)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dfs(i, p, lvl + 1)",
      "mutated_line": "dfs(i, p, lvl + 0)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 0)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dfs(i, p, lvl + 1)",
      "mutated_line": "dfs(i, p, lvl + -1)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + -1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "f.update(j, 1)",
      "mutated_line": "f.update(j, 2)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 2)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "f.update(j, 1)",
      "mutated_line": "f.update(j, 0)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 0)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "f.update(j, 1)",
      "mutated_line": "f.update(j, 0)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 0)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "f.update(j, 1)",
      "mutated_line": "f.update(j, -1)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, -1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "child = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 2)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "child = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 0)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "child = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 0)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "child = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + -1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return self.getsum(r) - self.getsum(l - 1)",
      "mutated_line": "return self.getsum(r) - self.getsum(l - 2)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 2)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return self.getsum(r) - self.getsum(l - 1)",
      "mutated_line": "return self.getsum(r) - self.getsum(l - 0)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 0)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return self.getsum(r) - self.getsum(l - 1)",
      "mutated_line": "return self.getsum(r) - self.getsum(l - 0)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 0)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return self.getsum(r) - self.getsum(l - 1)",
      "mutated_line": "return self.getsum(r) - self.getsum(l - -1)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - -1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans += f.query(1, j) - f.query(j, n)",
      "mutated_line": "ans += f.query(2, j) - f.query(j, n)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(2, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans += f.query(1, j) - f.query(j, n)",
      "mutated_line": "ans += f.query(0, j) - f.query(j, n)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(0, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans += f.query(1, j) - f.query(j, n)",
      "mutated_line": "ans += f.query(0, j) - f.query(j, n)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(0, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans += f.query(1, j) - f.query(j, n)",
      "mutated_line": "ans += f.query(-1, j) - f.query(j, n)",
      "code": "def calculate_expected_beauty(n, edges):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.BITTree = [0] * (n + 1)\n            self.size = n\n\n        def getsum(self, i):\n            s = 0\n            i = i + 1\n            while i > 0:\n                s += self.BITTree[i]\n                i -= i & -i\n            return s\n\n        def query(self, l, r):\n            return self.getsum(r) - self.getsum(l - 1)\n\n        def update(self, i, v):\n            i += 1\n            while i <= self.size:\n                self.BITTree[i] += v\n                i += i & -i\n\n    def dfs(p, prev, lvl):\n        level[lvl].append(p)\n        for i in child[p]:\n            if i == prev:\n                continue\n            dfs(i, p, lvl + 1)\n\n    def answer():\n        f = FenwickTree(n + 1)\n        ans = 0\n        for i in range(n):\n            for j in level[i]:\n                ans += f.query(-1, j) - f.query(j, n)\n            for j in level[i]:\n                f.update(j, 1)\n        return ans\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n    level = [[] for _ in range(n)]\n    dfs(1, -1, 0)\n    return answer()"
    }
  ]
}