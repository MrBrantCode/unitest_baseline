{
  "task_id": "taco_18146",
  "entry_point": "all_primes",
  "mutant_count": 163,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 46,
      "original_line": "ans -= bisect(nums, n)",
      "mutated_line": "ans += bisect(nums, n)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans += bisect(nums, n)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if pow(top + 2, p) <= n:",
      "mutated_line": "if pow(top + 2, p) < n:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) < n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if pow(top + 2, p) <= n:",
      "mutated_line": "if pow(top + 2, p) > n:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) > n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if pow(top + 2, p) <= n:",
      "mutated_line": "if pow(top + 2, p) == n:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) == n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "max_n = 1000000000000000000",
      "mutated_line": "max_n = 1000000000000000001",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000001\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "max_n = 1000000000000000000",
      "mutated_line": "max_n = 999999999999999999",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 999999999999999999\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "max_n = 1000000000000000000",
      "mutated_line": "max_n = 0",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 0\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "max_n = 1000000000000000000",
      "mutated_line": "max_n = 1",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "max_n = 1000000000000000000",
      "mutated_line": "max_n = -1000000000000000000",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = -1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) - count_pow_nums(n, 6)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) - count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = (n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3)) * count_pow_nums(n, 6)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = (n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3)) * count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(2, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(0, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(0, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(-1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n - 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n * 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prime = True",
      "mutated_line": "prime = False",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = False\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return top + 1",
      "mutated_line": "return top - 1",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top - 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "return top + 1",
      "mutated_line": "return top * 1",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top * 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif pow(top + 1, p) <= n:",
      "mutated_line": "elif pow(top + 1, p) < n:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) < n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif pow(top + 1, p) <= n:",
      "mutated_line": "elif pow(top + 1, p) > n:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) > n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif pow(top + 1, p) <= n:",
      "mutated_line": "elif pow(top + 1, p) == n:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) == n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "primes = all_primes(64)",
      "mutated_line": "primes = all_primes(65)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(65)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "primes = all_primes(64)",
      "mutated_line": "primes = all_primes(63)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(63)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "primes = all_primes(64)",
      "mutated_line": "primes = all_primes(0)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(0)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "primes = all_primes(64)",
      "mutated_line": "primes = all_primes(1)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(1)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "primes = all_primes(64)",
      "mutated_line": "primes = all_primes(-64)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(-64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for pi in range(3, len(primes)):",
      "mutated_line": "for pi in range(4, len(primes)):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(4, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for pi in range(3, len(primes)):",
      "mutated_line": "for pi in range(2, len(primes)):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(2, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for pi in range(3, len(primes)):",
      "mutated_line": "for pi in range(0, len(primes)):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(0, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for pi in range(3, len(primes)):",
      "mutated_line": "for pi in range(1, len(primes)):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(1, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for pi in range(3, len(primes)):",
      "mutated_line": "for pi in range(-3, len(primes)):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(-3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = n - 1 - count_pow_nums(n, 2) + count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) + count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = (n - 1 - count_pow_nums(n, 2)) * count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = (n - 1 - count_pow_nums(n, 2)) * count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 2):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 0):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 0):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + -1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(2, min(int(sqrt(i)) + 2, i)):",
      "mutated_line": "for j in range(3, min(int(sqrt(i)) + 2, i)):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(3, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(2, min(int(sqrt(i)) + 2, i)):",
      "mutated_line": "for j in range(1, min(int(sqrt(i)) + 2, i)):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(1, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(2, min(int(sqrt(i)) + 2, i)):",
      "mutated_line": "for j in range(0, min(int(sqrt(i)) + 2, i)):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(0, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(2, min(int(sqrt(i)) + 2, i)):",
      "mutated_line": "for j in range(1, min(int(sqrt(i)) + 2, i)):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(1, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(2, min(int(sqrt(i)) + 2, i)):",
      "mutated_line": "for j in range(-2, min(int(sqrt(i)) + 2, i)):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(-2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if i % j == 0:",
      "mutated_line": "if i % j != 0:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j != 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "top = int(pow(n, 1.0 / p))",
      "mutated_line": "top = int(pow(n, 1.0 * p))",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 * p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "top = int(pow(n, 1.0 / p))",
      "mutated_line": "top = int(pow(n, 1.0 // p))",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 // p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if pow(top + 2, p) <= n:",
      "mutated_line": "if pow(top - 2, p) <= n:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top - 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if pow(top + 2, p) <= n:",
      "mutated_line": "if pow(top * 2, p) <= n:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top * 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return top + 1",
      "mutated_line": "return top + 2",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 2\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return top + 1",
      "mutated_line": "return top + 0",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 0\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return top + 1",
      "mutated_line": "return top + 0",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 0\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return top + 1",
      "mutated_line": "return top + -1",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + -1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif pow(top, p) <= n:",
      "mutated_line": "elif pow(top, p) < n:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) < n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif pow(top, p) <= n:",
      "mutated_line": "elif pow(top, p) > n:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) > n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif pow(top, p) <= n:",
      "mutated_line": "elif pow(top, p) == n:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) == n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for num in range(2, cnt + 5):",
      "mutated_line": "for num in range(3, cnt + 5):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(3, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for num in range(2, cnt + 5):",
      "mutated_line": "for num in range(1, cnt + 5):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(1, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for num in range(2, cnt + 5):",
      "mutated_line": "for num in range(0, cnt + 5):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(0, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for num in range(2, cnt + 5):",
      "mutated_line": "for num in range(1, cnt + 5):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(1, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for num in range(2, cnt + 5):",
      "mutated_line": "for num in range(-2, cnt + 5):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(-2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "for num in range(2, cnt + 5):",
      "mutated_line": "for num in range(2, cnt - 5):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt - 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "for num in range(2, cnt + 5):",
      "mutated_line": "for num in range(2, cnt * 5):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt * 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 38,
      "original_line": "if sq2 ** 2 != num and sq3 ** 3 != num:",
      "mutated_line": "if sq2 ** 2 != num or sq3 ** 3 != num:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num or sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = n - 1 + count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 + count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = (n - 1) * count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = (n - 1) * count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 7)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 7)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 5)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 5)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 0)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 0)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 1)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 1)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, -6)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, -6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for j in range(2, min(int(sqrt(i)) + 2, i)):",
      "mutated_line": "for j in range(2, min(int(sqrt(i)) - 2, i)):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) - 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "for j in range(2, min(int(sqrt(i)) + 2, i)):",
      "mutated_line": "for j in range(2, min(int(sqrt(i)) * 2, i)):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) * 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if i % j == 0:",
      "mutated_line": "if i * j == 0:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i * j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if i % j == 0:",
      "mutated_line": "if i + j == 0:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i + j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if i % j == 0:",
      "mutated_line": "if i % j == 1:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 1:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if i % j == 0:",
      "mutated_line": "if i % j == -1:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == -1:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if i % j == 0:",
      "mutated_line": "if i % j == 1:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 1:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "prime = False",
      "mutated_line": "prime = True",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = True\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "top = int(pow(n, 1.0 / p))",
      "mutated_line": "top = int(pow(n, 2.0 / p))",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 2.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "top = int(pow(n, 1.0 / p))",
      "mutated_line": "top = int(pow(n, 0.0 / p))",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 0.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "top = int(pow(n, 1.0 / p))",
      "mutated_line": "top = int(pow(n, 0 / p))",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "top = int(pow(n, 1.0 / p))",
      "mutated_line": "top = int(pow(n, -1.0 / p))",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, -1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if pow(top + 2, p) <= n:",
      "mutated_line": "if pow(top + 3, p) <= n:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 3, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if pow(top + 2, p) <= n:",
      "mutated_line": "if pow(top + 1, p) <= n:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 1, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if pow(top + 2, p) <= n:",
      "mutated_line": "if pow(top + 0, p) <= n:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 0, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if pow(top + 2, p) <= n:",
      "mutated_line": "if pow(top + 1, p) <= n:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 1, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if pow(top + 2, p) <= n:",
      "mutated_line": "if pow(top + -2, p) <= n:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + -2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "elif pow(top + 1, p) <= n:",
      "mutated_line": "elif pow(top - 1, p) <= n:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top - 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "elif pow(top + 1, p) <= n:",
      "mutated_line": "elif pow(top * 1, p) <= n:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top * 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return top - 1",
      "mutated_line": "return top + 1",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top + 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return top - 1",
      "mutated_line": "return top * 1",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top * 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return top - 2",
      "mutated_line": "return top + 2",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top + 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return top - 2",
      "mutated_line": "return top * 2",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top * 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for num in range(2, cnt + 5):",
      "mutated_line": "for num in range(2, cnt + 6):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 6):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for num in range(2, cnt + 5):",
      "mutated_line": "for num in range(2, cnt + 4):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 4):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for num in range(2, cnt + 5):",
      "mutated_line": "for num in range(2, cnt + 0):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 0):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for num in range(2, cnt + 5):",
      "mutated_line": "for num in range(2, cnt + 1):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 1):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for num in range(2, cnt + 5):",
      "mutated_line": "for num in range(2, cnt + -5):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + -5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if sq2 ** 2 != num and sq3 ** 3 != num:",
      "mutated_line": "if sq2 ** 2 == num and sq3 ** 3 != num:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 == num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if sq2 ** 2 != num and sq3 ** 3 != num:",
      "mutated_line": "if sq2 ** 2 != num and sq3 ** 3 == num:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 == num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if power_num <= max_n:",
      "mutated_line": "if power_num < max_n:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num < max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if power_num <= max_n:",
      "mutated_line": "if power_num > max_n:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num > max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if power_num <= max_n:",
      "mutated_line": "if power_num == max_n:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num == max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = n + 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n + 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = n * 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n * 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 4) + count_pow_nums(n, 6)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 4) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 2) + count_pow_nums(n, 6)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 2) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 0) + count_pow_nums(n, 6)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 0) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 1) + count_pow_nums(n, 6)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 1) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, -3) + count_pow_nums(n, 6)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, -3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(2, min(int(sqrt(i)) + 2, i)):",
      "mutated_line": "for j in range(2, min(int(sqrt(i)) + 3, i)):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 3, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(2, min(int(sqrt(i)) + 2, i)):",
      "mutated_line": "for j in range(2, min(int(sqrt(i)) + 1, i)):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 1, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(2, min(int(sqrt(i)) + 2, i)):",
      "mutated_line": "for j in range(2, min(int(sqrt(i)) + 0, i)):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 0, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(2, min(int(sqrt(i)) + 2, i)):",
      "mutated_line": "for j in range(2, min(int(sqrt(i)) + 1, i)):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 1, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "for j in range(2, min(int(sqrt(i)) + 2, i)):",
      "mutated_line": "for j in range(2, min(int(sqrt(i)) + -2, i)):",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + -2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif pow(top + 1, p) <= n:",
      "mutated_line": "elif pow(top + 2, p) <= n:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 2, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif pow(top + 1, p) <= n:",
      "mutated_line": "elif pow(top + 0, p) <= n:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 0, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif pow(top + 1, p) <= n:",
      "mutated_line": "elif pow(top + 0, p) <= n:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 0, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "elif pow(top + 1, p) <= n:",
      "mutated_line": "elif pow(top + -1, p) <= n:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + -1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return top - 1",
      "mutated_line": "return top - 2",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 2\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return top - 1",
      "mutated_line": "return top - 0",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 0\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return top - 1",
      "mutated_line": "return top - 0",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 0\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return top - 1",
      "mutated_line": "return top - -1",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - -1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return top - 2",
      "mutated_line": "return top - 3",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 3\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return top - 2",
      "mutated_line": "return top - 1",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 1\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return top - 2",
      "mutated_line": "return top - 0",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 0\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return top - 2",
      "mutated_line": "return top - 1",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 1\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return top - 2",
      "mutated_line": "return top - -2",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - -2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "sq3 = round(pow(num, 1 / 3))",
      "mutated_line": "sq3 = round(pow(num, 1 * 3))",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 * 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "sq3 = round(pow(num, 1 / 3))",
      "mutated_line": "sq3 = round(pow(num, 1 // 3))",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 // 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if sq2 ** 2 != num and sq3 ** 3 != num:",
      "mutated_line": "if sq2 * 2 != num and sq3 ** 3 != num:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 * 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if sq2 ** 2 != num and sq3 ** 3 != num:",
      "mutated_line": "if sq2 + 2 != num and sq3 ** 3 != num:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 + 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if sq2 ** 2 != num and sq3 ** 3 != num:",
      "mutated_line": "if sq2 ** 2 != num and sq3 * 3 != num:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 * 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if sq2 ** 2 != num and sq3 ** 3 != num:",
      "mutated_line": "if sq2 ** 2 != num and sq3 + 3 != num:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 + 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = n - 2 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 2 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = n - 0 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 0 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = n - 0 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 0 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = n - -1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - -1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = n - 1 - count_pow_nums(n, 3) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 3) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = n - 1 - count_pow_nums(n, 1) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 1) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = n - 1 - count_pow_nums(n, 0) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 0) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = n - 1 - count_pow_nums(n, 1) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 1) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "mutated_line": "ans = n - 1 - count_pow_nums(n, -2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, -2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sq3 = round(pow(num, 1 / 3))",
      "mutated_line": "sq3 = round(pow(num, 2 / 3))",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 2 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sq3 = round(pow(num, 1 / 3))",
      "mutated_line": "sq3 = round(pow(num, 0 / 3))",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 0 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sq3 = round(pow(num, 1 / 3))",
      "mutated_line": "sq3 = round(pow(num, 0 / 3))",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 0 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sq3 = round(pow(num, 1 / 3))",
      "mutated_line": "sq3 = round(pow(num, -1 / 3))",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, -1 / 3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sq3 = round(pow(num, 1 / 3))",
      "mutated_line": "sq3 = round(pow(num, 1 / 4))",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 4))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sq3 = round(pow(num, 1 / 3))",
      "mutated_line": "sq3 = round(pow(num, 1 / 2))",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 2))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sq3 = round(pow(num, 1 / 3))",
      "mutated_line": "sq3 = round(pow(num, 1 / 0))",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 0))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sq3 = round(pow(num, 1 / 3))",
      "mutated_line": "sq3 = round(pow(num, 1 / 1))",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 1))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "sq3 = round(pow(num, 1 / 3))",
      "mutated_line": "sq3 = round(pow(num, 1 / -3))",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / -3))\n            if sq2 ** 2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if sq2 ** 2 != num and sq3 ** 3 != num:",
      "mutated_line": "if sq2 ** 3 != num and sq3 ** 3 != num:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 3 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if sq2 ** 2 != num and sq3 ** 3 != num:",
      "mutated_line": "if sq2 ** 1 != num and sq3 ** 3 != num:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 1 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if sq2 ** 2 != num and sq3 ** 3 != num:",
      "mutated_line": "if sq2 ** 0 != num and sq3 ** 3 != num:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 0 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if sq2 ** 2 != num and sq3 ** 3 != num:",
      "mutated_line": "if sq2 ** 1 != num and sq3 ** 3 != num:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 1 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if sq2 ** 2 != num and sq3 ** 3 != num:",
      "mutated_line": "if sq2 ** -2 != num and sq3 ** 3 != num:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** -2 != num and sq3 ** 3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if sq2 ** 2 != num and sq3 ** 3 != num:",
      "mutated_line": "if sq2 ** 2 != num and sq3 ** 4 != num:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 4 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if sq2 ** 2 != num and sq3 ** 3 != num:",
      "mutated_line": "if sq2 ** 2 != num and sq3 ** 2 != num:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 2 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if sq2 ** 2 != num and sq3 ** 3 != num:",
      "mutated_line": "if sq2 ** 2 != num and sq3 ** 0 != num:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 0 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if sq2 ** 2 != num and sq3 ** 3 != num:",
      "mutated_line": "if sq2 ** 2 != num and sq3 ** 1 != num:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** 1 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if sq2 ** 2 != num and sq3 ** 3 != num:",
      "mutated_line": "if sq2 ** 2 != num and sq3 ** -3 != num:",
      "code": "from math import sqrt, log2\nfrom bisect import bisect\n\ndef all_primes(n):\n    res = []\n    for i in range(1, n + 1):\n        prime = True\n        for j in range(2, min(int(sqrt(i)) + 2, i)):\n            if i % j == 0:\n                prime = False\n                break\n        if prime:\n            res.append(i)\n    return res\n\ndef count_pow_nums(n, p):\n    top = int(pow(n, 1.0 / p))\n    if pow(top + 2, p) <= n:\n        return top + 1\n    elif pow(top + 1, p) <= n:\n        return top\n    elif pow(top, p) <= n:\n        return top - 1\n    else:\n        return top - 2\n\ndef count_elegant_numbers(n):\n    primes = all_primes(64)\n    num_set = set()\n    max_n = 1000000000000000000\n    for pi in range(3, len(primes)):\n        p = primes[pi]\n        cnt = count_pow_nums(max_n, p)\n        for num in range(2, cnt + 5):\n            sq2 = round(sqrt(num))\n            sq3 = round(pow(num, 1 / 3))\n            if sq2 ** 2 != num and sq3 ** -3 != num:\n                power_num = pow(num, p)\n                if power_num <= max_n:\n                    num_set.add(power_num)\n    nums = sorted(num_set)\n    ans = n - 1 - count_pow_nums(n, 2) - count_pow_nums(n, 3) + count_pow_nums(n, 6)\n    ans -= bisect(nums, n)\n    return ans"
    }
  ]
}