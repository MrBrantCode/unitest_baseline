{
  "task_id": "taco_10550",
  "entry_point": "calculate_assignment_ways",
  "mutant_count": 105,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if p in memo:",
      "mutated_line": "if p not in memo:",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p not in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ret = 1",
      "mutated_line": "ret = 2",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 2\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ret = 1",
      "mutated_line": "ret = 0",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 0\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ret = 1",
      "mutated_line": "ret = 0",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 0\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "ret = 1",
      "mutated_line": "ret = -1",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = -1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while n > 0:",
      "mutated_line": "while n >= 0:",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n >= 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while n > 0:",
      "mutated_line": "while n <= 0:",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n <= 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while n > 0:",
      "mutated_line": "while n != 0:",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n != 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return C(n + 1, k + 1, p)",
      "mutated_line": "return C(n - 1, k + 1, p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n - 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return C(n + 1, k + 1, p)",
      "mutated_line": "return C(n * 1, k + 1, p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n * 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return C(n + 1, k + 1, p)",
      "mutated_line": "return C(n + 1, k - 1, p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k - 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return C(n + 1, k + 1, p)",
      "mutated_line": "return C(n + 1, k * 1, p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k * 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "fact = [1]",
      "mutated_line": "fact = [2]",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [2]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "fact = [1]",
      "mutated_line": "fact = [0]",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [0]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "fact = [1]",
      "mutated_line": "fact = [0]",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [0]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "fact = [1]",
      "mutated_line": "fact = [-1]",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [-1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, p):",
      "mutated_line": "for i in range(2, p):",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(2, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, p):",
      "mutated_line": "for i in range(0, p):",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(0, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, p):",
      "mutated_line": "for i in range(0, p):",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(0, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, p):",
      "mutated_line": "for i in range(-1, p):",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(-1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while n > 0:",
      "mutated_line": "while n > 1:",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 1:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while n > 0:",
      "mutated_line": "while n > -1:",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > -1:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "while n > 0:",
      "mutated_line": "while n > 1:",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 1:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "n1 = n % p",
      "mutated_line": "n1 = n * p",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n * p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "n1 = n % p",
      "mutated_line": "n1 = n + p",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n + p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "k1 = k % p",
      "mutated_line": "k1 = k * p",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k * p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "k1 = k % p",
      "mutated_line": "k1 = k + p",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k + p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if k1 > n1:",
      "mutated_line": "if k1 >= n1:",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 >= n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if k1 > n1:",
      "mutated_line": "if k1 <= n1:",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 <= n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if k1 > n1:",
      "mutated_line": "if k1 != n1:",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 != n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p",
      "mutated_line": "ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] * p",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] * p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p",
      "mutated_line": "ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] + p",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] + p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return C(n + 1, k + 1, p)",
      "mutated_line": "return C(n + 2, k + 1, p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 2, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return C(n + 1, k + 1, p)",
      "mutated_line": "return C(n + 0, k + 1, p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 0, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return C(n + 1, k + 1, p)",
      "mutated_line": "return C(n + 0, k + 1, p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 0, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return C(n + 1, k + 1, p)",
      "mutated_line": "return C(n + -1, k + 1, p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + -1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return C(n + 1, k + 1, p)",
      "mutated_line": "return C(n + 1, k + 2, p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 2, p)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return C(n + 1, k + 1, p)",
      "mutated_line": "return C(n + 1, k + 0, p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 0, p)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return C(n + 1, k + 1, p)",
      "mutated_line": "return C(n + 1, k + 0, p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 0, p)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return C(n + 1, k + 1, p)",
      "mutated_line": "return C(n + 1, k + -1, p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + -1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact.append(fact[-1] * i % p)",
      "mutated_line": "fact.append(fact[-1] * i * p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i * p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact.append(fact[-1] * i % p)",
      "mutated_line": "fact.append(fact[-1] * i + p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i + p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inv = [0, 1]",
      "mutated_line": "inv = [1, 1]",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [1, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inv = [0, 1]",
      "mutated_line": "inv = [-1, 1]",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [-1, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inv = [0, 1]",
      "mutated_line": "inv = [1, 1]",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [1, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inv = [0, 1]",
      "mutated_line": "inv = [0, 2]",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 2]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inv = [0, 1]",
      "mutated_line": "inv = [0, 0]",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 0]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inv = [0, 1]",
      "mutated_line": "inv = [0, 0]",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 0]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inv = [0, 1]",
      "mutated_line": "inv = [0, -1]",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, -1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(2, p):",
      "mutated_line": "for i in range(3, p):",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(3, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(2, p):",
      "mutated_line": "for i in range(1, p):",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(1, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(2, p):",
      "mutated_line": "for i in range(0, p):",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(0, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(2, p):",
      "mutated_line": "for i in range(1, p):",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(1, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for i in range(2, p):",
      "mutated_line": "for i in range(-2, p):",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(-2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "inv_fact = [1]",
      "mutated_line": "inv_fact = [2]",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [2]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "inv_fact = [1]",
      "mutated_line": "inv_fact = [0]",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [0]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "inv_fact = [1]",
      "mutated_line": "inv_fact = [0]",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [0]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "inv_fact = [1]",
      "mutated_line": "inv_fact = [-1]",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [-1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, p):",
      "mutated_line": "for i in range(2, p):",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(2, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, p):",
      "mutated_line": "for i in range(0, p):",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(0, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, p):",
      "mutated_line": "for i in range(0, p):",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(0, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, p):",
      "mutated_line": "for i in range(-1, p):",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(-1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 1\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return -1\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 1\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p",
      "mutated_line": "ret = ret * fact[n1] * inv_fact[k1] / inv_fact[n1 - k1] % p",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] / inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p",
      "mutated_line": "ret = (ret * fact[n1] * inv_fact[k1] + inv_fact[n1 - k1]) % p",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = (ret * fact[n1] * inv_fact[k1] + inv_fact[n1 - k1]) % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p",
      "mutated_line": "ret = (ret * fact[n1] * inv_fact[k1]) ** inv_fact[n1 - k1] % p",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = (ret * fact[n1] * inv_fact[k1]) ** inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact.append(fact[-1] * i % p)",
      "mutated_line": "fact.append(fact[-1] / i % p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] / i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact.append(fact[-1] * i % p)",
      "mutated_line": "fact.append((fact[-1] + i) % p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append((fact[-1] + i) % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "fact.append(fact[-1] * i % p)",
      "mutated_line": "fact.append(fact[-1] ** i % p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] ** i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "inv.append(p - p // i * inv[p % i] % p)",
      "mutated_line": "inv.append(p + p // i * inv[p % i] % p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p + p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "inv.append(p - p // i * inv[p % i] % p)",
      "mutated_line": "inv.append(p * (p // i * inv[p % i] % p))",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p * (p // i * inv[p % i] % p))\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inv_fact.append(inv_fact[-1] * inv[i] % p)",
      "mutated_line": "inv_fact.append(inv_fact[-1] * inv[i] * p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] * p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inv_fact.append(inv_fact[-1] * inv[i] % p)",
      "mutated_line": "inv_fact.append(inv_fact[-1] * inv[i] + p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] + p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p",
      "mutated_line": "ret = ret * fact[n1] / inv_fact[k1] * inv_fact[n1 - k1] % p",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] / inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p",
      "mutated_line": "ret = (ret * fact[n1] + inv_fact[k1]) * inv_fact[n1 - k1] % p",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = (ret * fact[n1] + inv_fact[k1]) * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p",
      "mutated_line": "ret = (ret * fact[n1]) ** inv_fact[k1] * inv_fact[n1 - k1] % p",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = (ret * fact[n1]) ** inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "inv.append(p - p // i * inv[p % i] % p)",
      "mutated_line": "inv.append(p - p // i * inv[p % i] * p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] * p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "inv.append(p - p // i * inv[p % i] % p)",
      "mutated_line": "inv.append(p - (p // i * inv[p % i] + p))",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - (p // i * inv[p % i] + p))\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inv_fact.append(inv_fact[-1] * inv[i] % p)",
      "mutated_line": "inv_fact.append(inv_fact[-1] / inv[i] % p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] / inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inv_fact.append(inv_fact[-1] * inv[i] % p)",
      "mutated_line": "inv_fact.append((inv_fact[-1] + inv[i]) % p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append((inv_fact[-1] + inv[i]) % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "inv_fact.append(inv_fact[-1] * inv[i] % p)",
      "mutated_line": "inv_fact.append(inv_fact[-1] ** inv[i] % p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] ** inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p",
      "mutated_line": "ret = ret / fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret / fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p",
      "mutated_line": "ret = (ret + fact[n1]) * inv_fact[k1] * inv_fact[n1 - k1] % p",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = (ret + fact[n1]) * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p",
      "mutated_line": "ret = ret ** fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret ** fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p",
      "mutated_line": "ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 + k1] % p",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 + k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p",
      "mutated_line": "ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 * k1] % p",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 * k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "fact.append(fact[-1] * i % p)",
      "mutated_line": "fact.append(fact[+1] * i % p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[+1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "inv.append(p - p // i * inv[p % i] % p)",
      "mutated_line": "inv.append(p - p // i / inv[p % i] % p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i / inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "inv.append(p - p // i * inv[p % i] % p)",
      "mutated_line": "inv.append(p - (p // i + inv[p % i]) % p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - (p // i + inv[p % i]) % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "inv.append(p - p // i * inv[p % i] % p)",
      "mutated_line": "inv.append(p - (p // i) ** inv[p % i] % p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - (p // i) ** inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fact.append(fact[-1] * i % p)",
      "mutated_line": "fact.append(fact[-2] * i % p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-2] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fact.append(fact[-1] * i % p)",
      "mutated_line": "fact.append(fact[-0] * i % p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-0] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fact.append(fact[-1] * i % p)",
      "mutated_line": "fact.append(fact[-0] * i % p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-0] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fact.append(fact[-1] * i % p)",
      "mutated_line": "fact.append(fact[--1] * i % p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[--1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "inv.append(p - p // i * inv[p % i] % p)",
      "mutated_line": "inv.append(p - p / i * inv[p % i] % p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p / i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "inv.append(p - p // i * inv[p % i] % p)",
      "mutated_line": "inv.append(p - p * i * inv[p % i] % p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p * i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "inv_fact.append(inv_fact[-1] * inv[i] % p)",
      "mutated_line": "inv_fact.append(inv_fact[+1] * inv[i] % p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[+1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "inv.append(p - p // i * inv[p % i] % p)",
      "mutated_line": "inv.append(p - p // i * inv[p * i] % p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p * i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "inv.append(p - p // i * inv[p % i] % p)",
      "mutated_line": "inv.append(p - p // i * inv[p + i] % p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p + i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inv_fact.append(inv_fact[-1] * inv[i] % p)",
      "mutated_line": "inv_fact.append(inv_fact[-2] * inv[i] % p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-2] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inv_fact.append(inv_fact[-1] * inv[i] % p)",
      "mutated_line": "inv_fact.append(inv_fact[-0] * inv[i] % p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-0] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inv_fact.append(inv_fact[-1] * inv[i] % p)",
      "mutated_line": "inv_fact.append(inv_fact[-0] * inv[i] % p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[-0] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "inv_fact.append(inv_fact[-1] * inv[i] % p)",
      "mutated_line": "inv_fact.append(inv_fact[--1] * inv[i] % p)",
      "code": "def calculate_assignment_ways(n, k, p):\n    memo = {}\n\n    def C(n, k, p):\n        fact = [1]\n        for i in range(1, p):\n            fact.append(fact[-1] * i % p)\n        if p in memo:\n            inv_fact = memo[p]\n        else:\n            inv = [0, 1]\n            for i in range(2, p):\n                inv.append(p - p // i * inv[p % i] % p)\n            inv_fact = [1]\n            for i in range(1, p):\n                inv_fact.append(inv_fact[--1] * inv[i] % p)\n            memo[p] = inv_fact\n        ret = 1\n        while n > 0:\n            n1 = n % p\n            k1 = k % p\n            if k1 > n1:\n                return 0\n            ret = ret * fact[n1] * inv_fact[k1] * inv_fact[n1 - k1] % p\n            n //= p\n            k //= p\n        return ret\n    return C(n + 1, k + 1, p)"
    }
  ]
}