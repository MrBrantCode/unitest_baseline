{
  "task_id": "taco_16041",
  "entry_point": "calculate_expected_cost",
  "mutant_count": 154,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MAX = 100005",
      "mutated_line": "MAX = 100006",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100006\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MAX = 100005",
      "mutated_line": "MAX = 100004",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100004\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MAX = 100005",
      "mutated_line": "MAX = 0",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 0\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MAX = 100005",
      "mutated_line": "MAX = 1",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 1\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MAX = 100005",
      "mutated_line": "MAX = -100005",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = -100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "vis = [False] * MAX",
      "mutated_line": "vis = [False] / MAX",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] / MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "vis = [False] * MAX",
      "mutated_line": "vis = [False] + MAX",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] + MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "vis = [False] * MAX",
      "mutated_line": "vis = [False] ** MAX",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] ** MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dp = [0] * MAX",
      "mutated_line": "dp = [0] / MAX",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] / MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dp = [0] * MAX",
      "mutated_line": "dp = [0] + MAX",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] + MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "dp = [0] * MAX",
      "mutated_line": "dp = [0] ** MAX",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] ** MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "prod = [0] * MAX",
      "mutated_line": "prod = [0] / MAX",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] / MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "prod = [0] * MAX",
      "mutated_line": "prod = [0] + MAX",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] + MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "prod = [0] * MAX",
      "mutated_line": "prod = [0] ** MAX",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] ** MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "tot = 0",
      "mutated_line": "tot = 1",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 1\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "tot = 0",
      "mutated_line": "tot = -1",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = -1\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "tot = 0",
      "mutated_line": "tot = 1",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 1\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "curr = 1",
      "mutated_line": "curr = 2",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 2\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "curr = 1",
      "mutated_line": "curr = 0",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 0\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "curr = 1",
      "mutated_line": "curr = 0",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 0\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "curr = 1",
      "mutated_line": "curr = -1",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = -1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "div = n * (n - 1) / 2",
      "mutated_line": "div = n * (n - 1) * 2",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) * 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "div = n * (n - 1) / 2",
      "mutated_line": "div = n * (n - 1) // 2",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) // 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 49,
      "original_line": "tot += min(sa, sb) * (n - min(sa, sb)) * i[1]",
      "mutated_line": "tot -= min(sa, sb) * (n - min(sa, sb)) * i[1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot -= min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "curr += 1",
      "mutated_line": "curr -= 1",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr -= 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 55,
      "original_line": "tot -= prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot += prod[q1] * edges[q1 - 1][1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot += prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 57,
      "original_line": "tot += prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot -= prod[q1] * edges[q1 - 1][1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot -= prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "vis[st] = True",
      "mutated_line": "vis[st] = False",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = False\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dfs(1)",
      "mutated_line": "dfs(2)",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(2)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dfs(1)",
      "mutated_line": "dfs(0)",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(0)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dfs(1)",
      "mutated_line": "dfs(0)",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(0)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "dfs(1)",
      "mutated_line": "dfs(-1)",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(-1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp[st] = 1",
      "mutated_line": "dp[st] = 2",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 2\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp[st] = 1",
      "mutated_line": "dp[st] = 0",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 0\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp[st] = 1",
      "mutated_line": "dp[st] = 0",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 0\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dp[st] = 1",
      "mutated_line": "dp[st] = -1",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = -1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "dp[st] += dp[i[0]]",
      "mutated_line": "dp[st] -= dp[i[0]]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] -= dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "div = n * (n - 1) / 2",
      "mutated_line": "div = n / (n - 1) / 2",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n / (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "div = n * (n - 1) / 2",
      "mutated_line": "div = (n + (n - 1)) / 2",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = (n + (n - 1)) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "div = n * (n - 1) / 2",
      "mutated_line": "div = n ** (n - 1) / 2",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n ** (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "div = n * (n - 1) / 2",
      "mutated_line": "div = n * (n - 1) / 3",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 3\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "div = n * (n - 1) / 2",
      "mutated_line": "div = n * (n - 1) / 1",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 1\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "div = n * (n - 1) / 2",
      "mutated_line": "div = n * (n - 1) / 0",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 0\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "div = n * (n - 1) / 2",
      "mutated_line": "div = n * (n - 1) / 1",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 1\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "div = n * (n - 1) / 2",
      "mutated_line": "div = n * (n - 1) / -2",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / -2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "tot += min(sa, sb) * (n - min(sa, sb)) * i[1]",
      "mutated_line": "tot += min(sa, sb) * (n - min(sa, sb)) / i[1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) / i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "tot += min(sa, sb) * (n - min(sa, sb)) * i[1]",
      "mutated_line": "tot += min(sa, sb) * (n - min(sa, sb)) + i[1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) + i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "tot += min(sa, sb) * (n - min(sa, sb)) * i[1]",
      "mutated_line": "tot += (min(sa, sb) * (n - min(sa, sb))) ** i[1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += (min(sa, sb) * (n - min(sa, sb))) ** i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "prod[curr] = min(sa, sb) * (n - min(sa, sb))",
      "mutated_line": "prod[curr] = min(sa, sb) / (n - min(sa, sb))",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) / (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "prod[curr] = min(sa, sb) * (n - min(sa, sb))",
      "mutated_line": "prod[curr] = min(sa, sb) + (n - min(sa, sb))",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) + (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "prod[curr] = min(sa, sb) * (n - min(sa, sb))",
      "mutated_line": "prod[curr] = min(sa, sb) ** (n - min(sa, sb))",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) ** (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "curr += 1",
      "mutated_line": "curr += 2",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 2\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "curr += 1",
      "mutated_line": "curr += 0",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 0\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "curr += 1",
      "mutated_line": "curr += 0",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 0\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "curr += 1",
      "mutated_line": "curr += -1",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += -1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "tot -= prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot -= prod[q1] / edges[q1 - 1][1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] / edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "tot -= prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot -= prod[q1] + edges[q1 - 1][1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] + edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "tot -= prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot -= prod[q1] ** edges[q1 - 1][1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] ** edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "tot += prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot += prod[q1] / edges[q1 - 1][1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] / edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "tot += prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot += prod[q1] + edges[q1 - 1][1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] + edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "tot += prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot += prod[q1] ** edges[q1 - 1][1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] ** edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "vis = [False] * MAX",
      "mutated_line": "vis = [True] * MAX",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [True] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp = [0] * MAX",
      "mutated_line": "dp = [1] * MAX",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [1] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp = [0] * MAX",
      "mutated_line": "dp = [-1] * MAX",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [-1] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp = [0] * MAX",
      "mutated_line": "dp = [1] * MAX",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [1] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "prod = [0] * MAX",
      "mutated_line": "prod = [1] * MAX",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [1] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "prod = [0] * MAX",
      "mutated_line": "prod = [-1] * MAX",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [-1] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "prod = [0] * MAX",
      "mutated_line": "prod = [1] * MAX",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [1] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "vis[st] = True",
      "mutated_line": "vis[st] = False",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = False\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if st == parent:",
      "mutated_line": "if st != parent:",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st != parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "div = n * (n - 1) / 2",
      "mutated_line": "div = n * (n + 1) / 2",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n + 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "div = n * (n - 1) / 2",
      "mutated_line": "div = n * (n * 1) / 2",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n * 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "a = i[0][0]",
      "mutated_line": "a = i[0][1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][1]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "a = i[0][0]",
      "mutated_line": "a = i[0][-1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][-1]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "a = i[0][0]",
      "mutated_line": "a = i[0][1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][1]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "b = i[0][1]",
      "mutated_line": "b = i[0][2]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][2]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "b = i[0][1]",
      "mutated_line": "b = i[0][0]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][0]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "b = i[0][1]",
      "mutated_line": "b = i[0][0]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][0]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "b = i[0][1]",
      "mutated_line": "b = i[0][-1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][-1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "tot += min(sa, sb) * (n - min(sa, sb)) * i[1]",
      "mutated_line": "tot += min(sa, sb) / (n - min(sa, sb)) * i[1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) / (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "tot += min(sa, sb) * (n - min(sa, sb)) * i[1]",
      "mutated_line": "tot += (min(sa, sb) + (n - min(sa, sb))) * i[1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += (min(sa, sb) + (n - min(sa, sb))) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "tot += min(sa, sb) * (n - min(sa, sb)) * i[1]",
      "mutated_line": "tot += min(sa, sb) ** (n - min(sa, sb)) * i[1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) ** (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "prod[curr] = min(sa, sb) * (n - min(sa, sb))",
      "mutated_line": "prod[curr] = min(sa, sb) * (n + min(sa, sb))",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n + min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "prod[curr] = min(sa, sb) * (n - min(sa, sb))",
      "mutated_line": "prod[curr] = min(sa, sb) * (n * min(sa, sb))",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n * min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "edges[q1 - 1][1] = q2",
      "mutated_line": "edges[q1 - 1][2] = q2",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][2] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "edges[q1 - 1][1] = q2",
      "mutated_line": "edges[q1 - 1][0] = q2",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][0] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "edges[q1 - 1][1] = q2",
      "mutated_line": "edges[q1 - 1][0] = q2",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][0] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "edges[q1 - 1][1] = q2",
      "mutated_line": "edges[q1 - 1][-1] = q2",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][-1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "results.append(tot * 3 / div)",
      "mutated_line": "results.append(tot * 3 * div)",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 * div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "results.append(tot * 3 / div)",
      "mutated_line": "results.append(tot * 3 // div)",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 // div)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "stack.append((st, -1))",
      "mutated_line": "stack.append((st, +1))",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, +1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "div = n * (n - 1) / 2",
      "mutated_line": "div = n * (n - 2) / 2",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 2) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "div = n * (n - 1) / 2",
      "mutated_line": "div = n * (n - 0) / 2",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 0) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "div = n * (n - 1) / 2",
      "mutated_line": "div = n * (n - 0) / 2",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 0) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "div = n * (n - 1) / 2",
      "mutated_line": "div = n * (n - -1) / 2",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - -1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "a = i[0][0]",
      "mutated_line": "a = i[1][0]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[1][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "a = i[0][0]",
      "mutated_line": "a = i[-1][0]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[-1][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "a = i[0][0]",
      "mutated_line": "a = i[1][0]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[1][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "b = i[0][1]",
      "mutated_line": "b = i[1][1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[1][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "b = i[0][1]",
      "mutated_line": "b = i[-1][1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[-1][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "b = i[0][1]",
      "mutated_line": "b = i[1][1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[1][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "tot += min(sa, sb) * (n - min(sa, sb)) * i[1]",
      "mutated_line": "tot += min(sa, sb) * (n + min(sa, sb)) * i[1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n + min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "tot += min(sa, sb) * (n - min(sa, sb)) * i[1]",
      "mutated_line": "tot += min(sa, sb) * (n * min(sa, sb)) * i[1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n * min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tot += min(sa, sb) * (n - min(sa, sb)) * i[1]",
      "mutated_line": "tot += min(sa, sb) * (n - min(sa, sb)) * i[2]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[2]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tot += min(sa, sb) * (n - min(sa, sb)) * i[1]",
      "mutated_line": "tot += min(sa, sb) * (n - min(sa, sb)) * i[0]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[0]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tot += min(sa, sb) * (n - min(sa, sb)) * i[1]",
      "mutated_line": "tot += min(sa, sb) * (n - min(sa, sb)) * i[0]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[0]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "tot += min(sa, sb) * (n - min(sa, sb)) * i[1]",
      "mutated_line": "tot += min(sa, sb) * (n - min(sa, sb)) * i[-1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[-1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "tot -= prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot -= prod[q1] * edges[q1 - 1][2]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][2]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "tot -= prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot -= prod[q1] * edges[q1 - 1][0]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][0]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "tot -= prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot -= prod[q1] * edges[q1 - 1][0]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][0]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "tot -= prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot -= prod[q1] * edges[q1 - 1][-1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][-1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "edges[q1 - 1][1] = q2",
      "mutated_line": "edges[q1 + 1][1] = q2",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 + 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "edges[q1 - 1][1] = q2",
      "mutated_line": "edges[q1 * 1][1] = q2",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 * 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "tot += prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot += prod[q1] * edges[q1 - 1][2]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][2]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "tot += prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot += prod[q1] * edges[q1 - 1][0]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][0]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "tot += prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot += prod[q1] * edges[q1 - 1][0]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][0]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "tot += prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot += prod[q1] * edges[q1 - 1][-1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][-1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "results.append(tot * 3 / div)",
      "mutated_line": "results.append(tot / 3 / div)",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot / 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "results.append(tot * 3 / div)",
      "mutated_line": "results.append((tot + 3) / div)",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append((tot + 3) / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "results.append(tot * 3 / div)",
      "mutated_line": "results.append(tot ** 3 / div)",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot ** 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "stack.append((st, -1))",
      "mutated_line": "stack.append((st, -2))",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -2))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "stack.append((st, -1))",
      "mutated_line": "stack.append((st, -0))",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -0))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "stack.append((st, -1))",
      "mutated_line": "stack.append((st, -0))",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -0))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "stack.append((st, -1))",
      "mutated_line": "stack.append((st, --1))",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, --1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp[st] += dp[i[0]]",
      "mutated_line": "dp[st] += dp[i[1]]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[1]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp[st] += dp[i[0]]",
      "mutated_line": "dp[st] += dp[i[-1]]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[-1]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp[st] += dp[i[0]]",
      "mutated_line": "dp[st] += dp[i[1]]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[1]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "tot -= prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot -= prod[q1] * edges[q1 + 1][1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 + 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "tot -= prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot -= prod[q1] * edges[q1 * 1][1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 * 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "edges[q1 - 1][1] = q2",
      "mutated_line": "edges[q1 - 2][1] = q2",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 2][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "edges[q1 - 1][1] = q2",
      "mutated_line": "edges[q1 - 0][1] = q2",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 0][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "edges[q1 - 1][1] = q2",
      "mutated_line": "edges[q1 - 0][1] = q2",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 0][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "edges[q1 - 1][1] = q2",
      "mutated_line": "edges[q1 - -1][1] = q2",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - -1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "tot += prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot += prod[q1] * edges[q1 + 1][1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 + 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 57,
      "original_line": "tot += prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot += prod[q1] * edges[q1 * 1][1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 * 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "results.append(tot * 3 / div)",
      "mutated_line": "results.append(tot * 4 / div)",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 4 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "results.append(tot * 3 / div)",
      "mutated_line": "results.append(tot * 2 / div)",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 2 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "results.append(tot * 3 / div)",
      "mutated_line": "results.append(tot * 0 / div)",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 0 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "results.append(tot * 3 / div)",
      "mutated_line": "results.append(tot * 1 / div)",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 1 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "results.append(tot * 3 / div)",
      "mutated_line": "results.append(tot * -3 / div)",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * -3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if vis[i[0]]:",
      "mutated_line": "if vis[i[1]]:",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[1]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if vis[i[0]]:",
      "mutated_line": "if vis[i[-1]]:",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[-1]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if vis[i[0]]:",
      "mutated_line": "if vis[i[1]]:",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[1]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "tot -= prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot -= prod[q1] * edges[q1 - 2][1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 2][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "tot -= prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot -= prod[q1] * edges[q1 - 0][1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 0][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "tot -= prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot -= prod[q1] * edges[q1 - 0][1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 0][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "tot -= prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot -= prod[q1] * edges[q1 - -1][1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - -1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "tot += prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot += prod[q1] * edges[q1 - 2][1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 2][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "tot += prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot += prod[q1] * edges[q1 - 0][1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 0][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "tot += prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot += prod[q1] * edges[q1 - 0][1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 0][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "tot += prod[q1] * edges[q1 - 1][1]",
      "mutated_line": "tot += prod[q1] * edges[q1 - -1][1]",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[0], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - -1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "stack.append((i[0], st))",
      "mutated_line": "stack.append((i[1], st))",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[1], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "stack.append((i[0], st))",
      "mutated_line": "stack.append((i[-1], st))",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[-1], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "stack.append((i[0], st))",
      "mutated_line": "stack.append((i[1], st))",
      "code": "import sys\n\ndef calculate_expected_cost(n, roads, queries):\n    MAX = 100005\n    g = [[] for _ in range(MAX)]\n    vis = [False] * MAX\n    dp = [0] * MAX\n    prod = [0] * MAX\n    edges = []\n    order = []\n\n    def dfs(st):\n        stack = []\n        stack.append((st, -1))\n        vis[st] = True\n        while stack:\n            (st, parent) = stack.pop()\n            order.append(st)\n            vis[st] = True\n            if st == parent:\n                continue\n            for i in g[st]:\n                if vis[i[0]]:\n                    continue\n                stack.append((i[1], st))\n    for (a, b, w) in roads:\n        g[a].append([b, w])\n        g[b].append([a, w])\n        edges.append([[a, b], w])\n    dfs(1)\n    order.reverse()\n    for st in order:\n        dp[st] = 1\n        for i in g[st]:\n            dp[st] += dp[i[0]]\n    tot = 0\n    curr = 1\n    div = n * (n - 1) / 2\n    for i in edges:\n        a = i[0][0]\n        b = i[0][1]\n        sa = dp[a]\n        sb = dp[b]\n        tot += min(sa, sb) * (n - min(sa, sb)) * i[1]\n        prod[curr] = min(sa, sb) * (n - min(sa, sb))\n        curr += 1\n    results = []\n    for (q1, q2) in queries:\n        tot -= prod[q1] * edges[q1 - 1][1]\n        edges[q1 - 1][1] = q2\n        tot += prod[q1] * edges[q1 - 1][1]\n        results.append(tot * 3 / div)\n    return results"
    }
  ]
}