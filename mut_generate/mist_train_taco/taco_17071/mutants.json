{
  "task_id": "taco_17071",
  "entry_point": "calculate_game_score",
  "mutant_count": 65,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):",
      "mutated_line": "if p != 1 or (len(child[p]) == 1 or len(child[p]) == 0):",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 or (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return dfs(1, -1, 0)",
      "mutated_line": "return dfs(2, -1, 0)",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(2, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return dfs(1, -1, 0)",
      "mutated_line": "return dfs(0, -1, 0)",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(0, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return dfs(1, -1, 0)",
      "mutated_line": "return dfs(0, -1, 0)",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(0, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return dfs(1, -1, 0)",
      "mutated_line": "return dfs(-1, -1, 0)",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(-1, -1, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "return dfs(1, -1, 0)",
      "mutated_line": "return dfs(1, +1, 0)",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, +1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return dfs(1, -1, 0)",
      "mutated_line": "return dfs(1, -1, 1)",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return dfs(1, -1, 0)",
      "mutated_line": "return dfs(1, -1, -1)",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return dfs(1, -1, 0)",
      "mutated_line": "return dfs(1, -1, 1)",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 1)"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "m1, m2 = float('inf'), -float('inf')",
      "mutated_line": "(m1, m2) = (float('inf'), +float('inf'))",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), +float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if i == prev:",
      "mutated_line": "if i != prev:",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i != prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):",
      "mutated_line": "if p == 1 and (len(child[p]) == 1 or len(child[p]) == 0):",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p == 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):",
      "mutated_line": "if p != 1 and (len(child[p]) == 1 and len(child[p]) == 0):",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 and len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return dfs(1, -1, 0)",
      "mutated_line": "return dfs(1, -2, 0)",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -2, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return dfs(1, -1, 0)",
      "mutated_line": "return dfs(1, -0, 0)",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return dfs(1, -1, 0)",
      "mutated_line": "return dfs(1, -0, 0)",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return dfs(1, -1, 0)",
      "mutated_line": "return dfs(1, --1, 0)",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, --1, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "child = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n - 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "child = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n * 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "m1, m2 = float('inf'), -float('inf')",
      "mutated_line": "(m1, m2) = (float(''), -float('inf'))",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float(''), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "x = dfs(i, p, turn ^ 1)",
      "mutated_line": "x = dfs(i, p, turn | 1)",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn | 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "m1 = min(m1, x + a[p - 1])",
      "mutated_line": "m1 = min(m1, x - a[p - 1])",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x - a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "m1 = min(m1, x + a[p - 1])",
      "mutated_line": "m1 = min(m1, x * a[p - 1])",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x * a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "m2 = max(m2, x + a[p - 1])",
      "mutated_line": "m2 = max(m2, x - a[p - 1])",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x - a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "m2 = max(m2, x + a[p - 1])",
      "mutated_line": "m2 = max(m2, x * a[p - 1])",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x * a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):",
      "mutated_line": "if p != 2 and (len(child[p]) == 1 or len(child[p]) == 0):",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 2 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):",
      "mutated_line": "if p != 0 and (len(child[p]) == 1 or len(child[p]) == 0):",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 0 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):",
      "mutated_line": "if p != 0 and (len(child[p]) == 1 or len(child[p]) == 0):",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 0 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):",
      "mutated_line": "if p != -1 and (len(child[p]) == 1 or len(child[p]) == 0):",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != -1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):",
      "mutated_line": "if p != 1 and (len(child[p]) != 1 or len(child[p]) == 0):",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) != 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):",
      "mutated_line": "if p != 1 and (len(child[p]) == 1 or len(child[p]) != 0):",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) != 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return a[p - 1]",
      "mutated_line": "return a[p + 1]",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p + 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return a[p - 1]",
      "mutated_line": "return a[p * 1]",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p * 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "child = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 2)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "child = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 0)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "child = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 0)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "child = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + -1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "m1, m2 = float('inf'), -float('inf')",
      "mutated_line": "(m1, m2) = (float('inf'), -float(''))",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float(''))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x = dfs(i, p, turn ^ 1)",
      "mutated_line": "x = dfs(i, p, turn ^ 2)",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 2)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x = dfs(i, p, turn ^ 1)",
      "mutated_line": "x = dfs(i, p, turn ^ 0)",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 0)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x = dfs(i, p, turn ^ 1)",
      "mutated_line": "x = dfs(i, p, turn ^ 0)",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 0)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "x = dfs(i, p, turn ^ 1)",
      "mutated_line": "x = dfs(i, p, turn ^ -1)",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ -1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):",
      "mutated_line": "if p != 1 and (len(child[p]) == 2 or len(child[p]) == 0):",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 2 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):",
      "mutated_line": "if p != 1 and (len(child[p]) == 0 or len(child[p]) == 0):",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 0 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):",
      "mutated_line": "if p != 1 and (len(child[p]) == 0 or len(child[p]) == 0):",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 0 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):",
      "mutated_line": "if p != 1 and (len(child[p]) == -1 or len(child[p]) == 0):",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == -1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):",
      "mutated_line": "if p != 1 and (len(child[p]) == 1 or len(child[p]) == 1):",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 1):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):",
      "mutated_line": "if p != 1 and (len(child[p]) == 1 or len(child[p]) == -1):",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == -1):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):",
      "mutated_line": "if p != 1 and (len(child[p]) == 1 or len(child[p]) == 1):",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 1):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return a[p - 1]",
      "mutated_line": "return a[p - 2]",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 2]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return a[p - 1]",
      "mutated_line": "return a[p - 0]",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 0]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return a[p - 1]",
      "mutated_line": "return a[p - 0]",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 0]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return a[p - 1]",
      "mutated_line": "return a[p - -1]",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - -1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "m1 = min(m1, x + a[p - 1])",
      "mutated_line": "m1 = min(m1, x + a[p + 1])",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p + 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "m1 = min(m1, x + a[p - 1])",
      "mutated_line": "m1 = min(m1, x + a[p * 1])",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p * 1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "m2 = max(m2, x + a[p - 1])",
      "mutated_line": "m2 = max(m2, x + a[p + 1])",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p + 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "m2 = max(m2, x + a[p - 1])",
      "mutated_line": "m2 = max(m2, x + a[p * 1])",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p * 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "m1 = min(m1, x + a[p - 1])",
      "mutated_line": "m1 = min(m1, x + a[p - 2])",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 2])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "m1 = min(m1, x + a[p - 1])",
      "mutated_line": "m1 = min(m1, x + a[p - 0])",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 0])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "m1 = min(m1, x + a[p - 1])",
      "mutated_line": "m1 = min(m1, x + a[p - 0])",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 0])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "m1 = min(m1, x + a[p - 1])",
      "mutated_line": "m1 = min(m1, x + a[p - -1])",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - -1])\n            m2 = max(m2, x + a[p - 1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "m2 = max(m2, x + a[p - 1])",
      "mutated_line": "m2 = max(m2, x + a[p - 2])",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 2])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "m2 = max(m2, x + a[p - 1])",
      "mutated_line": "m2 = max(m2, x + a[p - 0])",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 0])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "m2 = max(m2, x + a[p - 1])",
      "mutated_line": "m2 = max(m2, x + a[p - 0])",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - 0])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "m2 = max(m2, x + a[p - 1])",
      "mutated_line": "m2 = max(m2, x + a[p - -1])",
      "code": "def calculate_game_score(n, k, a, edges):\n    child = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        child[u].append(v)\n        child[v].append(u)\n\n    def dfs(p, prev, turn):\n        (m1, m2) = (float('inf'), -float('inf'))\n        for i in child[p]:\n            if i == prev:\n                continue\n            x = dfs(i, p, turn ^ 1)\n            m1 = min(m1, x + a[p - 1])\n            m2 = max(m2, x + a[p - -1])\n        if p != 1 and (len(child[p]) == 1 or len(child[p]) == 0):\n            return a[p - 1]\n        else:\n            return m2 if turn else m1\n    return dfs(1, -1, 0)"
    }
  ]
}