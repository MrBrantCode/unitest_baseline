{
  "task_id": "taco_3229",
  "entry_point": "minimize_eating_time",
  "mutant_count": 71,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "curr = [1] * n",
      "mutated_line": "curr = [1] / n",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] / n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "curr = [1] * n",
      "mutated_line": "curr = [1] + n",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] + n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "curr = [1] * n",
      "mutated_line": "curr = [1] ** n",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] ** n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "curr[nex] += 1",
      "mutated_line": "curr[nex] -= 1",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] -= 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "out2 += diff",
      "mutated_line": "out2 -= diff",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 -= diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "out = 0",
      "mutated_line": "out = 1",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 1\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "out = 0",
      "mutated_line": "out = -1",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = -1\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "out = 0",
      "mutated_line": "out = 1",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 1\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "out += calc(carrot_lengths[i], curr[i])",
      "mutated_line": "out -= calc(carrot_lengths[i], curr[i])",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out -= calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "assert out == out2",
      "mutated_line": "assert out != out2",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out != out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "smol = l // n",
      "mutated_line": "smol = l / n",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l / n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "smol = l // n",
      "mutated_line": "smol = l * n",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l * n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "tol = l % n",
      "mutated_line": "tol = l * n",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l * n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "tol = l % n",
      "mutated_line": "tol = l + n",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l + n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return smol * smol * n + (2 * smol + 1) * tol",
      "mutated_line": "return smol * smol * n - (2 * smol + 1) * tol",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n - (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return smol * smol * n + (2 * smol + 1) * tol",
      "mutated_line": "return smol * smol * n * ((2 * smol + 1) * tol)",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n * ((2 * smol + 1) * tol)\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(k - n):",
      "mutated_line": "for i in range(k + n):",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k + n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(k - n):",
      "mutated_line": "for i in range(k * n):",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k * n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr[nex] += 1",
      "mutated_line": "curr[nex] += 2",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 2\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr[nex] += 1",
      "mutated_line": "curr[nex] += 0",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 0\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr[nex] += 1",
      "mutated_line": "curr[nex] += 0",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 0\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr[nex] += 1",
      "mutated_line": "curr[nex] += -1",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += -1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return smol * smol * n + (2 * smol + 1) * tol",
      "mutated_line": "return smol * smol / n + (2 * smol + 1) * tol",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol / n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return smol * smol * n + (2 * smol + 1) * tol",
      "mutated_line": "return smol * smol + n + (2 * smol + 1) * tol",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol + n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return smol * smol * n + (2 * smol + 1) * tol",
      "mutated_line": "return (smol * smol) ** n + (2 * smol + 1) * tol",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return (smol * smol) ** n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return smol * smol * n + (2 * smol + 1) * tol",
      "mutated_line": "return smol * smol * n + (2 * smol + 1) / tol",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) / tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return smol * smol * n + (2 * smol + 1) * tol",
      "mutated_line": "return smol * smol * n + (2 * smol + 1 + tol)",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1 + tol)\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return smol * smol * n + (2 * smol + 1) * tol",
      "mutated_line": "return smol * smol * n + (2 * smol + 1) ** tol",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) ** tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "curr = [1] * n",
      "mutated_line": "curr = [2] * n",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [2] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "curr = [1] * n",
      "mutated_line": "curr = [0] * n",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [0] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "curr = [1] * n",
      "mutated_line": "curr = [0] * n",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [0] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "curr = [1] * n",
      "mutated_line": "curr = [-1] * n",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [-1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "out2 = sum([x * x for x in carrot_lengths])",
      "mutated_line": "out2 = sum([x / x for x in carrot_lengths])",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x / x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "out2 = sum([x * x for x in carrot_lengths])",
      "mutated_line": "out2 = sum([x + x for x in carrot_lengths])",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x + x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "out2 = sum([x * x for x in carrot_lengths])",
      "mutated_line": "out2 = sum([x ** x for x in carrot_lengths])",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x ** x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return smol * smol * n + (2 * smol + 1) * tol",
      "mutated_line": "return smol / smol * n + (2 * smol + 1) * tol",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol / smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return smol * smol * n + (2 * smol + 1) * tol",
      "mutated_line": "return (smol + smol) * n + (2 * smol + 1) * tol",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return (smol + smol) * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return smol * smol * n + (2 * smol + 1) * tol",
      "mutated_line": "return smol ** smol * n + (2 * smol + 1) * tol",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol ** smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return smol * smol * n + (2 * smol + 1) * tol",
      "mutated_line": "return smol * smol * n + (2 * smol - 1) * tol",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol - 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return smol * smol * n + (2 * smol + 1) * tol",
      "mutated_line": "return smol * smol * n + 2 * smol * 1 * tol",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + 2 * smol * 1 * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))",
      "mutated_line": "heapq.heappush(q, (calc(v, 2) + calc(v, 1), i))",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) + calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))",
      "mutated_line": "heapq.heappush(q, (calc(v, 2) * calc(v, 1), i))",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) * calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))",
      "mutated_line": "heapq.heappush(q, (calc(v, curr[nex] + 1) + calc(v, curr[nex]), nex))",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) + calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))",
      "mutated_line": "heapq.heappush(q, (calc(v, curr[nex] + 1) * calc(v, curr[nex]), nex))",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) * calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return smol * smol * n + (2 * smol + 1) * tol",
      "mutated_line": "return smol * smol * n + (2 / smol + 1) * tol",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 / smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return smol * smol * n + (2 * smol + 1) * tol",
      "mutated_line": "return smol * smol * n + (2 + smol + 1) * tol",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 + smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return smol * smol * n + (2 * smol + 1) * tol",
      "mutated_line": "return smol * smol * n + (2 ** smol + 1) * tol",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 ** smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return smol * smol * n + (2 * smol + 1) * tol",
      "mutated_line": "return smol * smol * n + (2 * smol + 2) * tol",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 2) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return smol * smol * n + (2 * smol + 1) * tol",
      "mutated_line": "return smol * smol * n + (2 * smol + 0) * tol",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 0) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return smol * smol * n + (2 * smol + 1) * tol",
      "mutated_line": "return smol * smol * n + (2 * smol + 0) * tol",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 0) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return smol * smol * n + (2 * smol + 1) * tol",
      "mutated_line": "return smol * smol * n + (2 * smol + -1) * tol",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + -1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return smol * smol * n + (2 * smol + 1) * tol",
      "mutated_line": "return smol * smol * n + (3 * smol + 1) * tol",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (3 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return smol * smol * n + (2 * smol + 1) * tol",
      "mutated_line": "return smol * smol * n + (1 * smol + 1) * tol",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (1 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return smol * smol * n + (2 * smol + 1) * tol",
      "mutated_line": "return smol * smol * n + (0 * smol + 1) * tol",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (0 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return smol * smol * n + (2 * smol + 1) * tol",
      "mutated_line": "return smol * smol * n + (1 * smol + 1) * tol",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (1 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return smol * smol * n + (2 * smol + 1) * tol",
      "mutated_line": "return smol * smol * n + (-2 * smol + 1) * tol",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (-2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))",
      "mutated_line": "heapq.heappush(q, (calc(v, 3) - calc(v, 1), i))",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 3) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))",
      "mutated_line": "heapq.heappush(q, (calc(v, 1) - calc(v, 1), i))",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 1) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))",
      "mutated_line": "heapq.heappush(q, (calc(v, 0) - calc(v, 1), i))",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 0) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))",
      "mutated_line": "heapq.heappush(q, (calc(v, 1) - calc(v, 1), i))",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 1) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))",
      "mutated_line": "heapq.heappush(q, (calc(v, -2) - calc(v, 1), i))",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, -2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))",
      "mutated_line": "heapq.heappush(q, (calc(v, 2) - calc(v, 2), i))",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 2), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))",
      "mutated_line": "heapq.heappush(q, (calc(v, 2) - calc(v, 0), i))",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 0), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))",
      "mutated_line": "heapq.heappush(q, (calc(v, 2) - calc(v, 0), i))",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 0), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))",
      "mutated_line": "heapq.heappush(q, (calc(v, 2) - calc(v, -1), i))",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, -1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))",
      "mutated_line": "heapq.heappush(q, (calc(v, curr[nex] - 1) - calc(v, curr[nex]), nex))",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] - 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))",
      "mutated_line": "heapq.heappush(q, (calc(v, curr[nex] * 1) - calc(v, curr[nex]), nex))",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] * 1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))",
      "mutated_line": "heapq.heappush(q, (calc(v, curr[nex] + 2) - calc(v, curr[nex]), nex))",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 2) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))",
      "mutated_line": "heapq.heappush(q, (calc(v, curr[nex] + 0) - calc(v, curr[nex]), nex))",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 0) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))",
      "mutated_line": "heapq.heappush(q, (calc(v, curr[nex] + 0) - calc(v, curr[nex]), nex))",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + 0) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))",
      "mutated_line": "heapq.heappush(q, (calc(v, curr[nex] + -1) - calc(v, curr[nex]), nex))",
      "code": "import heapq\n\ndef minimize_eating_time(n, k, carrot_lengths):\n\n    def calc(l, n):\n        smol = l // n\n        tol = l % n\n        return smol * smol * n + (2 * smol + 1) * tol\n    curr = [1] * n\n    q = []\n    for i in range(n):\n        v = carrot_lengths[i]\n        heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\n    out2 = sum([x * x for x in carrot_lengths])\n    for i in range(k - n):\n        (diff, nex) = heapq.heappop(q)\n        curr[nex] += 1\n        v = carrot_lengths[nex]\n        heapq.heappush(q, (calc(v, curr[nex] + -1) - calc(v, curr[nex]), nex))\n        out2 += diff\n    out = 0\n    for i in range(n):\n        out += calc(carrot_lengths[i], curr[i])\n    assert out == out2\n    return out"
    }
  ]
}