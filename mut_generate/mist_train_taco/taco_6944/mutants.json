{
  "task_id": "taco_6944",
  "entry_point": "find_good_set_points",
  "mutant_count": 67,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "n = 0",
      "mutated_line": "n = 1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 1\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "n = 0",
      "mutated_line": "n = -1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = -1\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "n = 0",
      "mutated_line": "n = 1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 1\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "while D % 4 == 0:",
      "mutated_line": "while D % 4 != 0:",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 != 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "ASR",
      "lineno": 5,
      "original_line": "n += 1",
      "mutated_line": "n -= 1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n -= 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "while D % 4 == 0:",
      "mutated_line": "while D * 4 == 0:",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D * 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "while D % 4 == 0:",
      "mutated_line": "while D + 4 == 0:",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D + 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "while D % 4 == 0:",
      "mutated_line": "while D % 4 == 1:",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 1:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "while D % 4 == 0:",
      "mutated_line": "while D % 4 == -1:",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == -1:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "while D % 4 == 0:",
      "mutated_line": "while D % 4 == 1:",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 1:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "n += 1",
      "mutated_line": "n += 2",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 2\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "n += 1",
      "mutated_line": "n += 0",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 0\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "n += 1",
      "mutated_line": "n += 0",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 0\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "n += 1",
      "mutated_line": "n += -1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += -1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "D //= 4",
      "mutated_line": "D //= 5",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 5\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "D //= 4",
      "mutated_line": "D //= 3",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 3\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "D //= 4",
      "mutated_line": "D //= 0",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 0\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "D //= 4",
      "mutated_line": "D //= 1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 1\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "D //= 4",
      "mutated_line": "D //= -4",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= -4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "mutated_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 != 1 else lambda x, y: ~(x >> n) & 1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 != 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]",
      "mutated_line": "points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) or j2(x, y)]",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) or j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return points[:N * N]",
      "mutated_line": "return points[:N / N]",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N / N]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return points[:N * N]",
      "mutated_line": "return points[:N + N]",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N + N]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return points[:N * N]",
      "mutated_line": "return points[:N ** N]",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N ** N]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "while D % 4 == 0:",
      "mutated_line": "while D % 5 == 0:",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 5 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "while D % 4 == 0:",
      "mutated_line": "while D % 3 == 0:",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 3 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "while D % 4 == 0:",
      "mutated_line": "while D % 0 == 0:",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 0 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "while D % 4 == 0:",
      "mutated_line": "while D % 1 == 0:",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 1 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "while D % 4 == 0:",
      "mutated_line": "while D % -4 == 0:",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % -4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "mutated_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D * 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D * 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "mutated_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D + 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D + 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "mutated_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 2 else lambda x, y: ~(x >> n) & 1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 2 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "mutated_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 0 else lambda x, y: ~(x >> n) & 1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 0 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "mutated_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 0 else lambda x, y: ~(x >> n) & 1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 0 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "mutated_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == -1 else lambda x, y: ~(x >> n) & 1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == -1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "mutated_line": "return (lambda x, y: ~(x >> n ^ y >> n) | 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) | 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "mutated_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) | 1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) | 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]",
      "mutated_line": "points = [(x, y) for x in range(2 / N) for y in range(2 * N) if j1(x, y) and j2(x, y)]",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 / N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]",
      "mutated_line": "points = [(x, y) for x in range(2 + N) for y in range(2 * N) if j1(x, y) and j2(x, y)]",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 + N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]",
      "mutated_line": "points = [(x, y) for x in range(2 ** N) for y in range(2 * N) if j1(x, y) and j2(x, y)]",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 ** N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]",
      "mutated_line": "points = [(x, y) for x in range(2 * N) for y in range(2 / N) if j1(x, y) and j2(x, y)]",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 / N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]",
      "mutated_line": "points = [(x, y) for x in range(2 * N) for y in range(2 + N) if j1(x, y) and j2(x, y)]",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 + N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]",
      "mutated_line": "points = [(x, y) for x in range(2 * N) for y in range(2 ** N) if j1(x, y) and j2(x, y)]",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 ** N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "mutated_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 3 == 1 else lambda x, y: ~(x >> n) & 1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 3 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "mutated_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 1 == 1 else lambda x, y: ~(x >> n) & 1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 1 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "mutated_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 0 == 1 else lambda x, y: ~(x >> n) & 1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 0 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "mutated_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 1 == 1 else lambda x, y: ~(x >> n) & 1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 1 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "mutated_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % -2 == 1 else lambda x, y: ~(x >> n) & 1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % -2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "mutated_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 2) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 2) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "mutated_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 0) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 0) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "mutated_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 0) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 0) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "mutated_line": "return (lambda x, y: ~(x >> n ^ y >> n) & -1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & -1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "mutated_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 2",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 2\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "mutated_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 0",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 0\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "mutated_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 0",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 0\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "mutated_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & -1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & -1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]",
      "mutated_line": "points = [(x, y) for x in range(3 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(3 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]",
      "mutated_line": "points = [(x, y) for x in range(1 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(1 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]",
      "mutated_line": "points = [(x, y) for x in range(0 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(0 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]",
      "mutated_line": "points = [(x, y) for x in range(1 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(1 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]",
      "mutated_line": "points = [(x, y) for x in range(-2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(-2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]",
      "mutated_line": "points = [(x, y) for x in range(2 * N) for y in range(3 * N) if j1(x, y) and j2(x, y)]",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(3 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]",
      "mutated_line": "points = [(x, y) for x in range(2 * N) for y in range(1 * N) if j1(x, y) and j2(x, y)]",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(1 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]",
      "mutated_line": "points = [(x, y) for x in range(2 * N) for y in range(0 * N) if j1(x, y) and j2(x, y)]",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(0 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]",
      "mutated_line": "points = [(x, y) for x in range(2 * N) for y in range(1 * N) if j1(x, y) and j2(x, y)]",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(1 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]",
      "mutated_line": "points = [(x, y) for x in range(2 * N) for y in range(-2 * N) if j1(x, y) and j2(x, y)]",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(-2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return (lambda x, y: ~(x >> n ^ y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "mutated_line": "return (lambda x, y: ~(x >> n | y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1",
      "code": "def find_good_set_points(N, D1, D2):\n\n    def judge(D):\n        n = 0\n        while D % 4 == 0:\n            n += 1\n            D //= 4\n        return (lambda x, y: ~(x >> n | y >> n) & 1) if D % 2 == 1 else lambda x, y: ~(x >> n) & 1\n    j1 = judge(D1)\n    j2 = judge(D2)\n    points = [(x, y) for x in range(2 * N) for y in range(2 * N) if j1(x, y) and j2(x, y)]\n    return points[:N * N]"
    }
  ]
}