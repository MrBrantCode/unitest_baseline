{
  "task_id": "taco_18217",
  "entry_point": "solve_linear_equations",
  "mutant_count": 137,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "P_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')",
      "mutated_line": "P_EQ = re.compile('')",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "vars = list(set(vars) - {''}) + ['']",
      "mutated_line": "vars = list(set(vars) - {''}) - ['']",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) - ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "vars = list(set(vars) - {''}) + ['']",
      "mutated_line": "vars = list(set(vars) - {''}) * ['']",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) * ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "if len(vars) - 1 > len(equations):",
      "mutated_line": "if len(vars) - 1 >= len(equations):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 >= len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "if len(vars) - 1 > len(equations):",
      "mutated_line": "if len(vars) - 1 <= len(equations):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 <= len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "if len(vars) - 1 > len(equations):",
      "mutated_line": "if len(vars) - 1 != len(equations):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 != len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "EPS = 1e-10",
      "mutated_line": "EPS = 1.0000000001",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1.0000000001\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "EPS = 1e-10",
      "mutated_line": "EPS = -0.9999999999",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = -0.9999999999\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "EPS = 1e-10",
      "mutated_line": "EPS = 0",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 0\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "EPS = 1e-10",
      "mutated_line": "EPS = 1",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "EPS = 1e-10",
      "mutated_line": "EPS = -1e-10",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = -1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if len(solvedDct) == len(vars) - 1:",
      "mutated_line": "if len(solvedDct) != len(vars) - 1:",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) != len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "if len(vars) - 1 > len(equations):",
      "mutated_line": "if len(vars) + 1 > len(equations):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) + 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "if len(vars) - 1 > len(equations):",
      "mutated_line": "if len(vars) * 1 > len(equations):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) * 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(rev, dct) = (1, defaultdict(int))",
      "mutated_line": "(rev, dct) = (2, defaultdict(int))",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (2, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(rev, dct) = (1, defaultdict(int))",
      "mutated_line": "(rev, dct) = (0, defaultdict(int))",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (0, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(rev, dct) = (1, defaultdict(int))",
      "mutated_line": "(rev, dct) = (0, defaultdict(int))",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (0, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(rev, dct) = (1, defaultdict(int))",
      "mutated_line": "(rev, dct) = (-1, defaultdict(int))",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (-1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for y in range(len(vars) - 1):",
      "mutated_line": "for y in range(len(vars) + 1):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) + 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "for y in range(len(vars) - 1):",
      "mutated_line": "for y in range(len(vars) * 1):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) * 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if px == -1:",
      "mutated_line": "if px != -1:",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px != -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "m[px][j] /= maxP",
      "mutated_line": "m[px][j] *= maxP",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] *= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if yP is None:",
      "mutated_line": "if yP is not None:",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is not None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "UOI",
      "lineno": 48,
      "original_line": "solvedDct[vars[yP]] = -m[x][-1]",
      "mutated_line": "solvedDct[vars[yP]] = +m[x][-1]",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = +m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if len(solvedDct) == len(vars) - 1:",
      "mutated_line": "if len(solvedDct) == len(vars) + 1:",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) + 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if len(solvedDct) == len(vars) - 1:",
      "mutated_line": "if len(solvedDct) == len(vars) * 1:",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) * 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "vars = list(set(vars) - {''}) + ['']",
      "mutated_line": "vars = list(set(vars) + {''}) + ['']",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) + {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "vars = list(set(vars) - {''}) + ['']",
      "mutated_line": "vars = list(set(vars) * {''}) + ['']",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) * {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "vars = list(set(vars) - {''}) + ['']",
      "mutated_line": "vars = list(set(vars) - {''}) + ['MUTATED']",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['MUTATED']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "if len(vars) - 1 > len(equations):",
      "mutated_line": "if len(vars) - 2 > len(equations):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 2 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "if len(vars) - 1 > len(equations):",
      "mutated_line": "if len(vars) - 0 > len(equations):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 0 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "if len(vars) - 1 > len(equations):",
      "mutated_line": "if len(vars) - 0 > len(equations):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 0 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "if len(vars) - 1 > len(equations):",
      "mutated_line": "if len(vars) - -1 > len(equations):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - -1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for m in P_EQ.finditer(eq.replace(' ', '')):",
      "mutated_line": "for m in P_EQ.finditer(eq.replace('', '')):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace('', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for m in P_EQ.finditer(eq.replace(' ', '')):",
      "mutated_line": "for m in P_EQ.finditer(eq.replace(' ', 'MUTATED')):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', 'MUTATED')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if m['eq']:",
      "mutated_line": "if m['']:",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "rev = -1",
      "mutated_line": "rev = +1",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = +1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if gc or gv:",
      "mutated_line": "if gc and gv:",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc and gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "dct[m['var']] += coef * rev",
      "mutated_line": "dct[m['var']] -= coef * rev",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] -= coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for y in range(len(vars) - 1):",
      "mutated_line": "for y in range(len(vars) - 2):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 2):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for y in range(len(vars) - 1):",
      "mutated_line": "for y in range(len(vars) - 0):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 0):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for y in range(len(vars) - 1):",
      "mutated_line": "for y in range(len(vars) - 0):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 0):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for y in range(len(vars) - 1):",
      "mutated_line": "for y in range(len(vars) - -1):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - -1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "if px == -1:",
      "mutated_line": "if px == +1:",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == +1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(maxP, m[px][y]) = (m[px][y], 1)",
      "mutated_line": "(maxP, m[px][y]) = (m[px][y], 2)",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 2)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(maxP, m[px][y]) = (m[px][y], 1)",
      "mutated_line": "(maxP, m[px][y]) = (m[px][y], 0)",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 0)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(maxP, m[px][y]) = (m[px][y], 1)",
      "mutated_line": "(maxP, m[px][y]) = (m[px][y], 0)",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 0)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "(maxP, m[px][y]) = (m[px][y], 1)",
      "mutated_line": "(maxP, m[px][y]) = (m[px][y], -1)",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], -1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for j in range(y + 1, len(vars)):",
      "mutated_line": "for j in range(y - 1, len(vars)):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y - 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "for j in range(y + 1, len(vars)):",
      "mutated_line": "for j in range(y * 1, len(vars)):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y * 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if abs(m[px][j]) < EPS:",
      "mutated_line": "if abs(m[px][j]) <= EPS:",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) <= EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if abs(m[px][j]) < EPS:",
      "mutated_line": "if abs(m[px][j]) >= EPS:",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) >= EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if abs(m[px][j]) < EPS:",
      "mutated_line": "if abs(m[px][j]) != EPS:",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) != EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for x in range(0, len(m)):",
      "mutated_line": "for x in range(1, len(m)):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(1, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for x in range(0, len(m)):",
      "mutated_line": "for x in range(-1, len(m)):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(-1, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for x in range(0, len(m)):",
      "mutated_line": "for x in range(1, len(m)):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(1, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if x == px:",
      "mutated_line": "if x != px:",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x != px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "m[x][j] -= coef * m[px][j]",
      "mutated_line": "m[x][j] += coef * m[px][j]",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] += coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if len(solvedDct) == len(vars) - 1:",
      "mutated_line": "if len(solvedDct) == len(vars) - 2:",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 2:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if len(solvedDct) == len(vars) - 1:",
      "mutated_line": "if len(solvedDct) == len(vars) - 0:",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 0:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if len(solvedDct) == len(vars) - 1:",
      "mutated_line": "if len(solvedDct) == len(vars) - 0:",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 0:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if len(solvedDct) == len(vars) - 1:",
      "mutated_line": "if len(solvedDct) == len(vars) - -1:",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - -1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "rev = -1",
      "mutated_line": "rev = -2",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -2\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "rev = -1",
      "mutated_line": "rev = -0",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -0\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "rev = -1",
      "mutated_line": "rev = -0",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -0\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "rev = -1",
      "mutated_line": "rev = --1",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = --1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dct[m['var']] += coef * rev",
      "mutated_line": "dct[m['var']] += coef / rev",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef / rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dct[m['var']] += coef * rev",
      "mutated_line": "dct[m['var']] += coef + rev",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef + rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "dct[m['var']] += coef * rev",
      "mutated_line": "dct[m['var']] += coef ** rev",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef ** rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if px == -1:",
      "mutated_line": "if px == -2:",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -2:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if px == -1:",
      "mutated_line": "if px == -0:",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -0:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if px == -1:",
      "mutated_line": "if px == -0:",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -0:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if px == -1:",
      "mutated_line": "if px == --1:",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == --1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(y + 1, len(vars)):",
      "mutated_line": "for j in range(y + 2, len(vars)):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 2, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(y + 1, len(vars)):",
      "mutated_line": "for j in range(y + 0, len(vars)):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 0, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(y + 1, len(vars)):",
      "mutated_line": "for j in range(y + 0, len(vars)):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 0, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for j in range(y + 1, len(vars)):",
      "mutated_line": "for j in range(y + -1, len(vars)):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + -1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "m[px][j] = 0",
      "mutated_line": "m[px][j] = 1",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 1\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "m[px][j] = 0",
      "mutated_line": "m[px][j] = -1",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = -1\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "m[px][j] = 0",
      "mutated_line": "m[px][j] = 1",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 1\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(coef, m[x][y]) = (m[x][y], 0)",
      "mutated_line": "(coef, m[x][y]) = (m[x][y], 1)",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 1)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(coef, m[x][y]) = (m[x][y], 0)",
      "mutated_line": "(coef, m[x][y]) = (m[x][y], -1)",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], -1)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(coef, m[x][y]) = (m[x][y], 0)",
      "mutated_line": "(coef, m[x][y]) = (m[x][y], 1)",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 1)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for j in range(y + 1, len(vars)):",
      "mutated_line": "for j in range(y - 1, len(vars)):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y - 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for j in range(y + 1, len(vars)):",
      "mutated_line": "for j in range(y * 1, len(vars)):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y * 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "m[x][j] -= coef * m[px][j]",
      "mutated_line": "m[x][j] -= coef / m[px][j]",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef / m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "m[x][j] -= coef * m[px][j]",
      "mutated_line": "m[x][j] -= coef + m[px][j]",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef + m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "m[x][j] -= coef * m[px][j]",
      "mutated_line": "m[x][j] -= coef ** m[px][j]",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef ** m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if abs(m[x][j]) < EPS:",
      "mutated_line": "if abs(m[x][j]) <= EPS:",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) <= EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if abs(m[x][j]) < EPS:",
      "mutated_line": "if abs(m[x][j]) >= EPS:",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) >= EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if abs(m[x][j]) < EPS:",
      "mutated_line": "if abs(m[x][j]) != EPS:",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) != EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "UOI",
      "lineno": 48,
      "original_line": "solvedDct[vars[yP]] = -m[x][-1]",
      "mutated_line": "solvedDct[vars[yP]] = -m[x][+1]",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][+1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "vars = list(set(vars) - {''}) + ['']",
      "mutated_line": "vars = list(set(vars) - {'MUTATED'}) + ['']",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {'MUTATED'}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(gc, gv) = (m['coef'], m['var'])",
      "mutated_line": "(gc, gv) = (m[''], m['var'])",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m[''], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "(gc, gv) = (m['coef'], m['var'])",
      "mutated_line": "(gc, gv) = (m['coef'], m[''])",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m[''])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)",
      "mutated_line": "coef = 1 if not gc and gc == '+' else -1 if gc == '-' else int(gc)",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc and gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)",
      "mutated_line": "coef = 2 if not gc or gc == '+' else -1 if gc == '-' else int(gc)",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 2 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)",
      "mutated_line": "coef = 0 if not gc or gc == '+' else -1 if gc == '-' else int(gc)",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 0 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)",
      "mutated_line": "coef = 0 if not gc or gc == '+' else -1 if gc == '-' else int(gc)",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 0 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)",
      "mutated_line": "coef = -1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = -1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))",
      "mutated_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) >= 0), default=(-1, -1))",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) >= 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))",
      "mutated_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) <= 0), default=(-1, -1))",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) <= 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))",
      "mutated_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) != 0), default=(-1, -1))",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) != 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))",
      "mutated_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(+1, -1))",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(+1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))",
      "mutated_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, +1))",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, +1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(y + 1, len(vars)):",
      "mutated_line": "for j in range(y + 2, len(vars)):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 2, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(y + 1, len(vars)):",
      "mutated_line": "for j in range(y + 0, len(vars)):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 0, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(y + 1, len(vars)):",
      "mutated_line": "for j in range(y + 0, len(vars)):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 0, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(y + 1, len(vars)):",
      "mutated_line": "for j in range(y + -1, len(vars)):",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + -1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "m[x][j] = 0",
      "mutated_line": "m[x][j] = 1",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 1\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "m[x][j] = 0",
      "mutated_line": "m[x][j] = -1",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = -1\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "m[x][j] = 0",
      "mutated_line": "m[x][j] = 1",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 1\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "solvedDct[vars[yP]] = -m[x][-1]",
      "mutated_line": "solvedDct[vars[yP]] = -m[x][-2]",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-2]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "solvedDct[vars[yP]] = -m[x][-1]",
      "mutated_line": "solvedDct[vars[yP]] = -m[x][-0]",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-0]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "solvedDct[vars[yP]] = -m[x][-1]",
      "mutated_line": "solvedDct[vars[yP]] = -m[x][-0]",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-0]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "solvedDct[vars[yP]] = -m[x][-1]",
      "mutated_line": "solvedDct[vars[yP]] = -m[x][--1]",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][--1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)",
      "mutated_line": "coef = 1 if not gc or gc != '+' else -1 if gc == '-' else int(gc)",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc != '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)",
      "mutated_line": "coef = 1 if not gc or gc == '+' else -1 if gc != '-' else int(gc)",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc != '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)",
      "mutated_line": "coef = 1 if not gc or gc == '+' else +1 if gc == '-' else int(gc)",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else +1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dct[m['var']] += coef * rev",
      "mutated_line": "dct[m['']] += coef * rev",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))",
      "mutated_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 1), default=(-1, -1))",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 1), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))",
      "mutated_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > -1), default=(-1, -1))",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > -1), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))",
      "mutated_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 1), default=(-1, -1))",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 1), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))",
      "mutated_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-2, -1))",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-2, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))",
      "mutated_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-0, -1))",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-0, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))",
      "mutated_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-0, -1))",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-0, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))",
      "mutated_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(--1, -1))",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(--1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))",
      "mutated_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -2))",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -2))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))",
      "mutated_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -0))",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -0))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))",
      "mutated_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -0))",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -0))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))",
      "mutated_line": "(_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, --1))",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, --1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)",
      "mutated_line": "coef = 1 if not gc or gc == '' else -1 if gc == '-' else int(gc)",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '' else -1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)",
      "mutated_line": "coef = 1 if not gc or gc == '+' else -1 if gc == '' else int(gc)",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -1 if gc == '' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)",
      "mutated_line": "coef = 1 if not gc or gc == '+' else -2 if gc == '-' else int(gc)",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -2 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)",
      "mutated_line": "coef = 1 if not gc or gc == '+' else -0 if gc == '-' else int(gc)",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -0 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)",
      "mutated_line": "coef = 1 if not gc or gc == '+' else -0 if gc == '-' else int(gc)",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else -0 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "coef = 1 if not gc or gc == '+' else -1 if gc == '-' else int(gc)",
      "mutated_line": "coef = 1 if not gc or gc == '+' else --1 if gc == '-' else int(gc)",
      "code": "from collections import defaultdict\nfrom functools import reduce\nimport re\nP_EQ = re.compile('(?P<eq>=)|(?P<coef>[+-]?\\\\d*)(?P<var>[a-zA-Z]*)')\n\ndef solve_linear_equations(equations):\n\n    def parse(eq):\n        (rev, dct) = (1, defaultdict(int))\n        for m in P_EQ.finditer(eq.replace(' ', '')):\n            if m['eq']:\n                rev = -1\n            else:\n                (gc, gv) = (m['coef'], m['var'])\n                if gc or gv:\n                    coef = 1 if not gc or gc == '+' else --1 if gc == '-' else int(gc)\n                    dct[m['var']] += coef * rev\n        return dct\n\n    def solveMatrix(m, vars):\n        EPS = 1e-10\n        pivots = {}\n        toDo = set(range(len(m)))\n        for y in range(len(vars) - 1):\n            (_, px) = max(((abs(m[x][y]), x) for x in toDo if abs(m[x][y]) > 0), default=(-1, -1))\n            if px == -1:\n                continue\n            pivots[px] = y\n            toDo.remove(px)\n            (maxP, m[px][y]) = (m[px][y], 1)\n            for j in range(y + 1, len(vars)):\n                m[px][j] /= maxP\n                if abs(m[px][j]) < EPS:\n                    m[px][j] = 0\n            for x in range(0, len(m)):\n                if x == px:\n                    continue\n                (coef, m[x][y]) = (m[x][y], 0)\n                for j in range(y + 1, len(vars)):\n                    m[x][j] -= coef * m[px][j]\n                    if abs(m[x][j]) < EPS:\n                        m[x][j] = 0\n        solvedDct = {}\n        for x in range(len(m)):\n            yP = pivots.get(x, None)\n            if yP is None:\n                continue\n            solvedDct[vars[yP]] = -m[x][-1]\n        if len(solvedDct) == len(vars) - 1:\n            return solvedDct\n    eqsMap = list(map(parse, equations))\n    vars = reduce(set.union, (set(e) for e in eqsMap))\n    vars = list(set(vars) - {''}) + ['']\n    if len(vars) - 1 > len(equations):\n        return None\n    m = [[eqm[v] for v in vars] for eqm in eqsMap]\n    return solveMatrix(m, vars)"
    }
  ]
}