{
  "task_id": "taco_9566",
  "entry_point": "find_optimum_cost",
  "mutant_count": 97,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "low = -1000",
      "mutated_line": "low = +1000",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = +1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "high = 1000",
      "mutated_line": "high = 1001",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1001\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "high = 1000",
      "mutated_line": "high = 999",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 999\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "high = 1000",
      "mutated_line": "high = 0",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 0\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "high = 1000",
      "mutated_line": "high = 1",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "high = 1000",
      "mutated_line": "high = -1000",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = -1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "eps = 0.001",
      "mutated_line": "eps = 1.001",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 1.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "eps = 0.001",
      "mutated_line": "eps = -0.999",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = -0.999\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "eps = 0.001",
      "mutated_line": "eps = 0",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "eps = 0.001",
      "mutated_line": "eps = 1",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 1\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "eps = 0.001",
      "mutated_line": "eps = -0.001",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = -0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if line[1] == 0:",
      "mutated_line": "if line[1] != 0:",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] != 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while high - low > eps:",
      "mutated_line": "while high - low >= eps:",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low >= eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while high - low > eps:",
      "mutated_line": "while high - low <= eps:",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low <= eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while high - low > eps:",
      "mutated_line": "while high - low != eps:",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low != eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "avg = (low + high) / 2",
      "mutated_line": "avg = (low + high) * 2",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) * 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "avg = (low + high) / 2",
      "mutated_line": "avg = (low + high) // 2",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) // 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "x_diff = (x1 - x2) * (x1 - x2)",
      "mutated_line": "x_diff = (x1 - x2) / (x1 - x2)",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) / (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "x_diff = (x1 - x2) * (x1 - x2)",
      "mutated_line": "x_diff = x1 - x2 + (x1 - x2)",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = x1 - x2 + (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "x_diff = (x1 - x2) * (x1 - x2)",
      "mutated_line": "x_diff = (x1 - x2) ** (x1 - x2)",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) ** (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "y_diff = (y1 - y2) * (y1 - y2)",
      "mutated_line": "y_diff = (y1 - y2) / (y1 - y2)",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) / (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "y_diff = (y1 - y2) * (y1 - y2)",
      "mutated_line": "y_diff = y1 - y2 + (y1 - y2)",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = y1 - y2 + (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "y_diff = (y1 - y2) * (y1 - y2)",
      "mutated_line": "y_diff = (y1 - y2) ** (y1 - y2)",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) ** (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "y = -(a * x + c) / b",
      "mutated_line": "y = -(a * x + c) * b",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) * b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "y = -(a * x + c) / b",
      "mutated_line": "y = -(a * x + c) // b",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) // b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res = 0.0",
      "mutated_line": "res = 1.0",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 1.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res = 0.0",
      "mutated_line": "res = -1.0",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = -1.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "res = 0.0",
      "mutated_line": "res = 1",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 1\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "res += distance(x, x1, y, y1)",
      "mutated_line": "res -= distance(x, x1, y, y1)",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res -= distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "low = -1000",
      "mutated_line": "low = -1001",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1001\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "low = -1000",
      "mutated_line": "low = -999",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -999\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "low = -1000",
      "mutated_line": "low = -0",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -0\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "low = -1000",
      "mutated_line": "low = -1",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "low = -1000",
      "mutated_line": "low = --1000",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = --1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if line[1] == 0:",
      "mutated_line": "if line[1] == 1:",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 1:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if line[1] == 0:",
      "mutated_line": "if line[1] == -1:",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == -1:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if line[1] == 0:",
      "mutated_line": "if line[1] == 1:",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 1:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "while high - low > eps:",
      "mutated_line": "while high + low > eps:",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high + low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "while high - low > eps:",
      "mutated_line": "while high * low > eps:",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high * low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "mid1 = low + (high - low) / 3",
      "mutated_line": "mid1 = low - (high - low) / 3",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low - (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "mid1 = low + (high - low) / 3",
      "mutated_line": "mid1 = low * ((high - low) / 3)",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low * ((high - low) / 3)\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "mid2 = high - (high - low) / 3",
      "mutated_line": "mid2 = high + (high - low) / 3",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high + (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "mid2 = high - (high - low) / 3",
      "mutated_line": "mid2 = high * ((high - low) / 3)",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high * ((high - low) / 3)\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if dist1 < dist2:",
      "mutated_line": "if dist1 <= dist2:",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 <= dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if dist1 < dist2:",
      "mutated_line": "if dist1 >= dist2:",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 >= dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if dist1 < dist2:",
      "mutated_line": "if dist1 != dist2:",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 != dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "avg = (low + high) / 2",
      "mutated_line": "avg = (low - high) / 2",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low - high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "avg = (low + high) / 2",
      "mutated_line": "avg = low * high / 2",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = low * high / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "avg = (low + high) / 2",
      "mutated_line": "avg = (low + high) / 3",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 3\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "avg = (low + high) / 2",
      "mutated_line": "avg = (low + high) / 1",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 1\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "avg = (low + high) / 2",
      "mutated_line": "avg = (low + high) / 0",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 0\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "avg = (low + high) / 2",
      "mutated_line": "avg = (low + high) / 1",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 1\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "avg = (low + high) / 2",
      "mutated_line": "avg = (low + high) / -2",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / -2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return round(compute(avg, line, points), 2)",
      "mutated_line": "return round(compute(avg, line, points), 3)",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 3)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return round(compute(avg, line, points), 2)",
      "mutated_line": "return round(compute(avg, line, points), 1)",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 1)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return round(compute(avg, line, points), 2)",
      "mutated_line": "return round(compute(avg, line, points), 0)",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 0)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return round(compute(avg, line, points), 2)",
      "mutated_line": "return round(compute(avg, line, points), 1)",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 1)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return round(compute(avg, line, points), 2)",
      "mutated_line": "return round(compute(avg, line, points), -2)",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), -2)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "x_diff = (x1 - x2) * (x1 - x2)",
      "mutated_line": "x_diff = (x1 + x2) * (x1 - x2)",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 + x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "x_diff = (x1 - x2) * (x1 - x2)",
      "mutated_line": "x_diff = x1 * x2 * (x1 - x2)",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = x1 * x2 * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "x_diff = (x1 - x2) * (x1 - x2)",
      "mutated_line": "x_diff = (x1 - x2) * (x1 + x2)",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 + x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "x_diff = (x1 - x2) * (x1 - x2)",
      "mutated_line": "x_diff = (x1 - x2) * (x1 * x2)",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 * x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "y_diff = (y1 - y2) * (y1 - y2)",
      "mutated_line": "y_diff = (y1 + y2) * (y1 - y2)",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 + y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "y_diff = (y1 - y2) * (y1 - y2)",
      "mutated_line": "y_diff = y1 * y2 * (y1 - y2)",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = y1 * y2 * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "y_diff = (y1 - y2) * (y1 - y2)",
      "mutated_line": "y_diff = (y1 - y2) * (y1 + y2)",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 + y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "y_diff = (y1 - y2) * (y1 - y2)",
      "mutated_line": "y_diff = (y1 - y2) * (y1 * y2)",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 * y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return sqrt(x_diff + y_diff)",
      "mutated_line": "return sqrt(x_diff - y_diff)",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff - y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return sqrt(x_diff + y_diff)",
      "mutated_line": "return sqrt(x_diff * y_diff)",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff * y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "y = -(a * x + c) / b",
      "mutated_line": "y = +(a * x + c) / b",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = +(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if line[1] == 0:",
      "mutated_line": "if line[2] == 0:",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[2] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if line[1] == 0:",
      "mutated_line": "if line[0] == 0:",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[0] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if line[1] == 0:",
      "mutated_line": "if line[0] == 0:",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[0] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if line[1] == 0:",
      "mutated_line": "if line[-1] == 0:",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[-1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return float('inf')",
      "mutated_line": "return float('')",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "mid1 = low + (high - low) / 3",
      "mutated_line": "mid1 = low + (high - low) * 3",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) * 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "mid1 = low + (high - low) / 3",
      "mutated_line": "mid1 = low + (high - low) // 3",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) // 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "mid2 = high - (high - low) / 3",
      "mutated_line": "mid2 = high - (high - low) * 3",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) * 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "mid2 = high - (high - low) / 3",
      "mutated_line": "mid2 = high - (high - low) // 3",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) // 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "y = -(a * x + c) / b",
      "mutated_line": "y = -(a * x - c) / b",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x - c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "y = -(a * x + c) / b",
      "mutated_line": "y = -(a * x * c) / b",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x * c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "mid1 = low + (high - low) / 3",
      "mutated_line": "mid1 = low + (high + low) / 3",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high + low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "mid1 = low + (high - low) / 3",
      "mutated_line": "mid1 = low + high * low / 3",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + high * low / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mid1 = low + (high - low) / 3",
      "mutated_line": "mid1 = low + (high - low) / 4",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 4\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mid1 = low + (high - low) / 3",
      "mutated_line": "mid1 = low + (high - low) / 2",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 2\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mid1 = low + (high - low) / 3",
      "mutated_line": "mid1 = low + (high - low) / 0",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 0\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mid1 = low + (high - low) / 3",
      "mutated_line": "mid1 = low + (high - low) / 1",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 1\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "mid1 = low + (high - low) / 3",
      "mutated_line": "mid1 = low + (high - low) / -3",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / -3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "mid2 = high - (high - low) / 3",
      "mutated_line": "mid2 = high - (high + low) / 3",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high + low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "mid2 = high - (high - low) / 3",
      "mutated_line": "mid2 = high - high * low / 3",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - high * low / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mid2 = high - (high - low) / 3",
      "mutated_line": "mid2 = high - (high - low) / 4",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 4\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mid2 = high - (high - low) / 3",
      "mutated_line": "mid2 = high - (high - low) / 2",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 2\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mid2 = high - (high - low) / 3",
      "mutated_line": "mid2 = high - (high - low) / 0",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 0\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mid2 = high - (high - low) / 3",
      "mutated_line": "mid2 = high - (high - low) / 1",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 1\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mid2 = high - (high - low) / 3",
      "mutated_line": "mid2 = high - (high - low) / -3",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a * x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / -3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "y = -(a * x + c) / b",
      "mutated_line": "y = -(a / x + c) / b",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a / x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "y = -(a * x + c) / b",
      "mutated_line": "y = -(a + x + c) / b",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a + x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "y = -(a * x + c) / b",
      "mutated_line": "y = -(a ** x + c) / b",
      "code": "from typing import List\nfrom math import sqrt\n\ndef find_optimum_cost(line: List[int], points: List[List[int]]) -> float:\n\n    def distance(x1, x2, y1, y2):\n        x_diff = (x1 - x2) * (x1 - x2)\n        y_diff = (y1 - y2) * (y1 - y2)\n        return sqrt(x_diff + y_diff)\n\n    def compute(x, line, points):\n        (a, b, c) = line\n        y = -(a ** x + c) / b\n        res = 0.0\n        for (x1, y1) in points:\n            res += distance(x, x1, y, y1)\n        return res\n    low = -1000\n    high = 1000\n    eps = 0.001\n    if line[1] == 0:\n        return float('inf')\n    while high - low > eps:\n        mid1 = low + (high - low) / 3\n        mid2 = high - (high - low) / 3\n        dist1 = compute(mid1, line, points)\n        dist2 = compute(mid2, line, points)\n        if dist1 < dist2:\n            high = mid2\n        else:\n            low = mid1\n    avg = (low + high) / 2\n    return round(compute(avg, line, points), 2)"
    }
  ]
}