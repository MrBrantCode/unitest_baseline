{
  "task_id": "taco_1947",
  "entry_point": "count_decinc_subarrays",
  "mutant_count": 73,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 1\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = -1\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 1\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "ans += j - i",
      "mutated_line": "ans -= j - i",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans -= j - i\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "p.append(n + 1)  # Append a sentinel value to simplify the logic",
      "mutated_line": "p.append(n - 1)",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n - 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "p.append(n + 1)  # Append a sentinel value to simplify the logic",
      "mutated_line": "p.append(n * 1)",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n * 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while j + 1 <= n:",
      "mutated_line": "while j + 1 < n:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 < n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while j + 1 <= n:",
      "mutated_line": "while j + 1 > n:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 > n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while j + 1 <= n:",
      "mutated_line": "while j + 1 == n:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 == n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j -= 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "u = 0",
      "mutated_line": "u = 1",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 1\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "u = 0",
      "mutated_line": "u = -1",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = -1\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "u = 0",
      "mutated_line": "u = 1",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 1\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "d = n + 1",
      "mutated_line": "d = n - 1",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n - 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "d = n + 1",
      "mutated_line": "d = n * 1",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n * 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans += j - i",
      "mutated_line": "ans += j + i",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j + i\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans += j - i",
      "mutated_line": "ans += j * i",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j * i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "p.append(n + 1)  # Append a sentinel value to simplify the logic",
      "mutated_line": "p.append(n + 2)",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 2)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "p.append(n + 1)  # Append a sentinel value to simplify the logic",
      "mutated_line": "p.append(n + 0)",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 0)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "p.append(n + 1)  # Append a sentinel value to simplify the logic",
      "mutated_line": "p.append(n + 0)",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 0)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "p.append(n + 1)  # Append a sentinel value to simplify the logic",
      "mutated_line": "p.append(n + -1)",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + -1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "while j + 1 <= n:",
      "mutated_line": "while j - 1 <= n:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j - 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "while j + 1 <= n:",
      "mutated_line": "while j * 1 <= n:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j * 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if v != -1:",
      "mutated_line": "if v == -1:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v == -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if u < p[j] < d:",
      "mutated_line": "if u <= p[j] < d:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u <= p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if u < p[j] < d:",
      "mutated_line": "if u >= p[j] < d:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u >= p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if u < p[j] < d:",
      "mutated_line": "if u != p[j] < d:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u != p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 2\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 0\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 0\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += -1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "d = n + 1",
      "mutated_line": "d = n + 2",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 2\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "d = n + 1",
      "mutated_line": "d = n + 0",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 0\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "d = n + 1",
      "mutated_line": "d = n + 0",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 0\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "d = n + 1",
      "mutated_line": "d = n + -1",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + -1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while j + 1 <= n:",
      "mutated_line": "while j + 2 <= n:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 2 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while j + 1 <= n:",
      "mutated_line": "while j + 0 <= n:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 0 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while j + 1 <= n:",
      "mutated_line": "while j + 0 <= n:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 0 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while j + 1 <= n:",
      "mutated_line": "while j + -1 <= n:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + -1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "v = cache.get(key, -1)",
      "mutated_line": "v = cache.get(key, +1)",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, +1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "if v != -1:",
      "mutated_line": "if v != +1:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != +1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if p[j] < p[j + 1]:",
      "mutated_line": "if p[j] <= p[j + 1]:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] <= p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if p[j] < p[j + 1]:",
      "mutated_line": "if p[j] >= p[j + 1]:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] >= p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if p[j] < p[j + 1]:",
      "mutated_line": "if p[j] != p[j + 1]:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] != p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif u < p[j]:",
      "mutated_line": "elif u <= p[j]:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u <= p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif u < p[j]:",
      "mutated_line": "elif u >= p[j]:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u >= p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "elif u < p[j]:",
      "mutated_line": "elif u != p[j]:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u != p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "v = cache.get(key, -1)",
      "mutated_line": "v = cache.get(key, -2)",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -2)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "v = cache.get(key, -1)",
      "mutated_line": "v = cache.get(key, -0)",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -0)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "v = cache.get(key, -1)",
      "mutated_line": "v = cache.get(key, -0)",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -0)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "v = cache.get(key, -1)",
      "mutated_line": "v = cache.get(key, --1)",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, --1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if v != -1:",
      "mutated_line": "if v != -2:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -2:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if v != -1:",
      "mutated_line": "if v != -0:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -0:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if v != -1:",
      "mutated_line": "if v != -0:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -0:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if v != -1:",
      "mutated_line": "if v != --1:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != --1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "elif p[j] > p[j + 1]:",
      "mutated_line": "elif p[j] >= p[j + 1]:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] >= p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "elif p[j] > p[j + 1]:",
      "mutated_line": "elif p[j] <= p[j + 1]:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] <= p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "elif p[j] > p[j + 1]:",
      "mutated_line": "elif p[j] != p[j + 1]:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] != p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif d > p[j]:",
      "mutated_line": "elif d >= p[j]:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d >= p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif d > p[j]:",
      "mutated_line": "elif d <= p[j]:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d <= p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif d > p[j]:",
      "mutated_line": "elif d != p[j]:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d != p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if p[j] < p[j + 1]:",
      "mutated_line": "if p[j] < p[j - 1]:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j - 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if p[j] < p[j + 1]:",
      "mutated_line": "if p[j] < p[j * 1]:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j * 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if p[j] < p[j + 1]:",
      "mutated_line": "if p[j] < p[j + 2]:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 2]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if p[j] < p[j + 1]:",
      "mutated_line": "if p[j] < p[j + 0]:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 0]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if p[j] < p[j + 1]:",
      "mutated_line": "if p[j] < p[j + 0]:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 0]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if p[j] < p[j + 1]:",
      "mutated_line": "if p[j] < p[j + -1]:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + -1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "elif p[j] > p[j + 1]:",
      "mutated_line": "elif p[j] > p[j - 1]:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j - 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "elif p[j] > p[j + 1]:",
      "mutated_line": "elif p[j] > p[j * 1]:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j * 1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "elif p[j] > p[j + 1]:",
      "mutated_line": "elif p[j] > p[j + 2]:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 2]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "elif p[j] > p[j + 1]:",
      "mutated_line": "elif p[j] > p[j + 0]:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 0]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "elif p[j] > p[j + 1]:",
      "mutated_line": "elif p[j] > p[j + 0]:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + 0]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "elif p[j] > p[j + 1]:",
      "mutated_line": "elif p[j] > p[j + -1]:",
      "code": "def count_decinc_subarrays(n, p):\n    p.append(n + 1)\n    cache = {}\n\n    def check(i, u, d):\n        keys = []\n        j = i\n        while j + 1 <= n:\n            key = (j, u, d)\n            v = cache.get(key, -1)\n            if v != -1:\n                j = v\n                break\n            keys.append(key)\n            if u < p[j] < d:\n                if p[j] < p[j + 1]:\n                    u = max(u, p[j])\n                elif p[j] > p[j + -1]:\n                    d = min(d, p[j])\n            elif u < p[j]:\n                u = p[j]\n            elif d > p[j]:\n                d = p[j]\n            else:\n                break\n            j += 1\n        for key in keys:\n            cache[key] = j\n        return j\n    ans = 0\n    for i in range(n):\n        u = 0\n        d = n + 1\n        j = check(i, u, d)\n        ans += j - i\n    return ans"
    }
  ]
}