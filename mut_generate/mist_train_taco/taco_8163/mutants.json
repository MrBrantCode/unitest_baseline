{
  "task_id": "taco_8163",
  "entry_point": "sieve_of_eratosthenes",
  "mutant_count": 99,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "LIMIT = 100025",
      "mutated_line": "LIMIT = 100026",
      "code": "import math\nLIMIT = 100026\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "LIMIT = 100025",
      "mutated_line": "LIMIT = 100024",
      "code": "import math\nLIMIT = 100024\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "LIMIT = 100025",
      "mutated_line": "LIMIT = 0",
      "code": "import math\nLIMIT = 0\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "LIMIT = 100025",
      "mutated_line": "LIMIT = 1",
      "code": "import math\nLIMIT = 1\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "LIMIT = 100025",
      "mutated_line": "LIMIT = -100025",
      "code": "import math\nLIMIT = -100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "is_prime = [True for i in range(LIMIT + 1)]",
      "mutated_line": "is_prime = [False for i in range(LIMIT + 1)]",
      "code": "import math\nLIMIT = 100025\nis_prime = [False for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distance_to_next_prime = [0 for i in range(200000)]",
      "mutated_line": "distance_to_next_prime = [1 for i in range(200000)]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [1 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distance_to_next_prime = [0 for i in range(200000)]",
      "mutated_line": "distance_to_next_prime = [-1 for i in range(200000)]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [-1 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distance_to_next_prime = [0 for i in range(200000)]",
      "mutated_line": "distance_to_next_prime = [1 for i in range(200000)]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [1 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "is_prime[0] = is_prime[1] = False",
      "mutated_line": "is_prime[0] = is_prime[1] = True",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = True\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "is_prime[0] = is_prime[1] = False",
      "mutated_line": "is_prime[1] = is_prime[1] = False",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[1] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "is_prime[0] = is_prime[1] = False",
      "mutated_line": "is_prime[-1] = is_prime[1] = False",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[-1] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "is_prime[0] = is_prime[1] = False",
      "mutated_line": "is_prime[1] = is_prime[1] = False",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[1] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "is_prime[0] = is_prime[1] = False",
      "mutated_line": "is_prime[0] = is_prime[2] = False",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[2] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "is_prime[0] = is_prime[1] = False",
      "mutated_line": "is_prime[0] = is_prime[0] = False",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[0] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "is_prime[0] = is_prime[1] = False",
      "mutated_line": "is_prime[0] = is_prime[0] = False",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[0] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "is_prime[0] = is_prime[1] = False",
      "mutated_line": "is_prime[0] = is_prime[-1] = False",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[-1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2, int(math.sqrt(LIMIT))):",
      "mutated_line": "for i in range(3, int(math.sqrt(LIMIT))):",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(3, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2, int(math.sqrt(LIMIT))):",
      "mutated_line": "for i in range(1, int(math.sqrt(LIMIT))):",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(1, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2, int(math.sqrt(LIMIT))):",
      "mutated_line": "for i in range(0, int(math.sqrt(LIMIT))):",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(0, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2, int(math.sqrt(LIMIT))):",
      "mutated_line": "for i in range(1, int(math.sqrt(LIMIT))):",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(1, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(2, int(math.sqrt(LIMIT))):",
      "mutated_line": "for i in range(-2, int(math.sqrt(LIMIT))):",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(-2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(LIMIT - 1, -1, -1):",
      "mutated_line": "for i in range(LIMIT + 1, -1, -1):",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT + 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(LIMIT - 1, -1, -1):",
      "mutated_line": "for i in range(LIMIT * 1, -1, -1):",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT * 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "for i in range(LIMIT - 1, -1, -1):",
      "mutated_line": "for i in range(LIMIT - 1, +1, -1):",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, +1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "for i in range(LIMIT - 1, -1, -1):",
      "mutated_line": "for i in range(LIMIT - 1, -1, +1):",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, +1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "moves = float('inf')",
      "mutated_line": "moves = float('')",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "best_row = 0",
      "mutated_line": "best_row = 1",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 1\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "best_row = 0",
      "mutated_line": "best_row = -1",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = -1\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "best_row = 0",
      "mutated_line": "best_row = 1",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 1\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "best_row += distance_to_next_prime[num]",
      "mutated_line": "best_row -= distance_to_next_prime[num]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row -= distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if best_row < moves:",
      "mutated_line": "if best_row <= moves:",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row <= moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if best_row < moves:",
      "mutated_line": "if best_row >= moves:",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row >= moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if best_row < moves:",
      "mutated_line": "if best_row != moves:",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row != moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "best_column = 0",
      "mutated_line": "best_column = 1",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 1\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "best_column = 0",
      "mutated_line": "best_column = -1",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = -1\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "best_column = 0",
      "mutated_line": "best_column = 1",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 1\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "best_column += distance_to_next_prime[num]",
      "mutated_line": "best_column -= distance_to_next_prime[num]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column -= distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if best_column < moves:",
      "mutated_line": "if best_column <= moves:",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column <= moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if best_column < moves:",
      "mutated_line": "if best_column >= moves:",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column >= moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if best_column < moves:",
      "mutated_line": "if best_column != moves:",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column != moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "is_prime = [True for i in range(LIMIT + 1)]",
      "mutated_line": "is_prime = [True for i in range(LIMIT - 1)]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT - 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "is_prime = [True for i in range(LIMIT + 1)]",
      "mutated_line": "is_prime = [True for i in range(LIMIT * 1)]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT * 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distance_to_next_prime = [0 for i in range(200000)]",
      "mutated_line": "distance_to_next_prime = [0 for i in range(200001)]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200001)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distance_to_next_prime = [0 for i in range(200000)]",
      "mutated_line": "distance_to_next_prime = [0 for i in range(199999)]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(199999)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distance_to_next_prime = [0 for i in range(200000)]",
      "mutated_line": "distance_to_next_prime = [0 for i in range(0)]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(0)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distance_to_next_prime = [0 for i in range(200000)]",
      "mutated_line": "distance_to_next_prime = [0 for i in range(1)]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(1)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "distance_to_next_prime = [0 for i in range(200000)]",
      "mutated_line": "distance_to_next_prime = [0 for i in range(-200000)]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(-200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "j = 2",
      "mutated_line": "j = 3",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 3\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "j = 2",
      "mutated_line": "j = 1",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 1\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "j = 2",
      "mutated_line": "j = 0",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 0\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "j = 2",
      "mutated_line": "j = 1",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 1\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "j = 2",
      "mutated_line": "j = -2",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = -2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while i * j <= LIMIT:",
      "mutated_line": "while i * j < LIMIT:",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j < LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while i * j <= LIMIT:",
      "mutated_line": "while i * j > LIMIT:",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j > LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while i * j <= LIMIT:",
      "mutated_line": "while i * j == LIMIT:",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j == LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j -= 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(LIMIT - 1, -1, -1):",
      "mutated_line": "for i in range(LIMIT - 2, -1, -1):",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 2, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(LIMIT - 1, -1, -1):",
      "mutated_line": "for i in range(LIMIT - 0, -1, -1):",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 0, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(LIMIT - 1, -1, -1):",
      "mutated_line": "for i in range(LIMIT - 0, -1, -1):",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 0, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(LIMIT - 1, -1, -1):",
      "mutated_line": "for i in range(LIMIT - -1, -1, -1):",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - -1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(LIMIT - 1, -1, -1):",
      "mutated_line": "for i in range(LIMIT - 1, -2, -1):",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -2, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(LIMIT - 1, -1, -1):",
      "mutated_line": "for i in range(LIMIT - 1, -0, -1):",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -0, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(LIMIT - 1, -1, -1):",
      "mutated_line": "for i in range(LIMIT - 1, -0, -1):",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -0, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(LIMIT - 1, -1, -1):",
      "mutated_line": "for i in range(LIMIT - 1, --1, -1):",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, --1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(LIMIT - 1, -1, -1):",
      "mutated_line": "for i in range(LIMIT - 1, -1, -2):",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -2):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(LIMIT - 1, -1, -1):",
      "mutated_line": "for i in range(LIMIT - 1, -1, -0):",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -0):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(LIMIT - 1, -1, -1):",
      "mutated_line": "for i in range(LIMIT - 1, -1, -0):",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -0):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(LIMIT - 1, -1, -1):",
      "mutated_line": "for i in range(LIMIT - 1, -1, --1):",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, --1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "distance_to_next_prime[i] = 0",
      "mutated_line": "distance_to_next_prime[i] = 1",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 1\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "distance_to_next_prime[i] = 0",
      "mutated_line": "distance_to_next_prime[i] = -1",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = -1\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "distance_to_next_prime[i] = 0",
      "mutated_line": "distance_to_next_prime[i] = 1",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 1\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]",
      "mutated_line": "distance_to_next_prime[i] = 1 - distance_to_next_prime[i + 1]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 - distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]",
      "mutated_line": "distance_to_next_prime[i] = 1 * distance_to_next_prime[i + 1]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 * distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "is_prime = [True for i in range(LIMIT + 1)]",
      "mutated_line": "is_prime = [True for i in range(LIMIT + 2)]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 2)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "is_prime = [True for i in range(LIMIT + 1)]",
      "mutated_line": "is_prime = [True for i in range(LIMIT + 0)]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 0)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "is_prime = [True for i in range(LIMIT + 1)]",
      "mutated_line": "is_prime = [True for i in range(LIMIT + 0)]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 0)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "is_prime = [True for i in range(LIMIT + 1)]",
      "mutated_line": "is_prime = [True for i in range(LIMIT + -1)]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + -1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "while i * j <= LIMIT:",
      "mutated_line": "while i / j <= LIMIT:",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i / j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "while i * j <= LIMIT:",
      "mutated_line": "while i + j <= LIMIT:",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i + j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "while i * j <= LIMIT:",
      "mutated_line": "while i ** j <= LIMIT:",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i ** j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "is_prime[i * j] = False",
      "mutated_line": "is_prime[i * j] = True",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = True\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 2\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 0\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 0\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += -1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]",
      "mutated_line": "distance_to_next_prime[i] = 2 + distance_to_next_prime[i + 1]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 2 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]",
      "mutated_line": "distance_to_next_prime[i] = 0 + distance_to_next_prime[i + 1]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 0 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]",
      "mutated_line": "distance_to_next_prime[i] = 0 + distance_to_next_prime[i + 1]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 0 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]",
      "mutated_line": "distance_to_next_prime[i] = -1 + distance_to_next_prime[i + 1]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = -1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "is_prime[i * j] = False",
      "mutated_line": "is_prime[i / j] = False",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i / j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "is_prime[i * j] = False",
      "mutated_line": "is_prime[i + j] = False",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i + j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "is_prime[i * j] = False",
      "mutated_line": "is_prime[i ** j] = False",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i ** j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]",
      "mutated_line": "distance_to_next_prime[i] = 1 + distance_to_next_prime[i - 1]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i - 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]",
      "mutated_line": "distance_to_next_prime[i] = 1 + distance_to_next_prime[i * 1]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i * 1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]",
      "mutated_line": "distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 2]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 2]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]",
      "mutated_line": "distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 0]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 0]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]",
      "mutated_line": "distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 0]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 0]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "distance_to_next_prime[i] = 1 + distance_to_next_prime[i + 1]",
      "mutated_line": "distance_to_next_prime[i] = 1 + distance_to_next_prime[i + -1]",
      "code": "import math\nLIMIT = 100025\nis_prime = [True for i in range(LIMIT + 1)]\ndistance_to_next_prime = [0 for i in range(200000)]\n\ndef sieve_of_eratosthenes():\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(math.sqrt(LIMIT))):\n        if is_prime[i]:\n            j = 2\n            while i * j <= LIMIT:\n                is_prime[i * j] = False\n                j += 1\n\ndef fill_next_primes():\n    for i in range(LIMIT - 1, -1, -1):\n        if is_prime[i]:\n            distance_to_next_prime[i] = 0\n        else:\n            distance_to_next_prime[i] = 1 + distance_to_next_prime[i + -1]\n\ndef min_moves_to_prime_matrix(n, m, matrix):\n    sieve_of_eratosthenes()\n    fill_next_primes()\n    moves = float('inf')\n    for index_row in range(n):\n        best_row = 0\n        for index_column in range(m):\n            num = int(matrix[index_row][index_column])\n            best_row += distance_to_next_prime[num]\n        if best_row < moves:\n            moves = best_row\n    for index_column in range(m):\n        best_column = 0\n        for index_row in range(n):\n            num = int(matrix[index_row][index_column])\n            best_column += distance_to_next_prime[num]\n        if best_column < moves:\n            moves = best_column\n    return moves"
    }
  ]
}