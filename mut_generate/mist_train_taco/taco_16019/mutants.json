{
  "task_id": "taco_16019",
  "entry_point": "find_partition",
  "mutant_count": 72,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 != 1:",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 != 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n * 2 == 1:",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n * 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n + 2 == 1:",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n + 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 2:",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 2:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 0:",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 0:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == 0:",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 0:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 2 == -1:",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == -1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(0, n, 2):",
      "mutated_line": "for i in range(1, n, 2):",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(1, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(0, n, 2):",
      "mutated_line": "for i in range(-1, n, 2):",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(-1, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(0, n, 2):",
      "mutated_line": "for i in range(1, n, 2):",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(1, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(0, n, 2):",
      "mutated_line": "for i in range(0, n, 3):",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 3):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(0, n, 2):",
      "mutated_line": "for i in range(0, n, 1):",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 1):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(0, n, 2):",
      "mutated_line": "for i in range(0, n, 0):",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 0):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(0, n, 2):",
      "mutated_line": "for i in range(0, n, 1):",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 1):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(0, n, 2):",
      "mutated_line": "for i in range(0, n, -2):",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, -2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if a[i] != a[i + 1]:",
      "mutated_line": "if a[i] == a[i + 1]:",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] == a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 3 == 1:",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 3 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 1 == 1:",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 1 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 0 == 1:",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 0 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % 1 == 1:",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 1 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if n % 2 == 1:",
      "mutated_line": "if n % -2 == 1:",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % -2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "return -1, None",
      "mutated_line": "return (+1, None)",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (+1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return -1, None",
      "mutated_line": "return (-2, None)",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-2, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return -1, None",
      "mutated_line": "return (-0, None)",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-0, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return -1, None",
      "mutated_line": "return (-0, None)",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-0, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return -1, None",
      "mutated_line": "return (--1, None)",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (--1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if a[i] != a[i + 1]:",
      "mutated_line": "if a[i] != a[i - 1]:",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i - 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if a[i] != a[i + 1]:",
      "mutated_line": "if a[i] != a[i * 1]:",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i * 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if a[i] != a[i + 1]:",
      "mutated_line": "if a[i] != a[i + 2]:",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 2]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if a[i] != a[i + 1]:",
      "mutated_line": "if a[i] != a[i + 0]:",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 0]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if a[i] != a[i + 1]:",
      "mutated_line": "if a[i] != a[i + 0]:",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 0]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if a[i] != a[i + 1]:",
      "mutated_line": "if a[i] != a[i + -1]:",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + -1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "segments.append((i + 1, i + 1))",
      "mutated_line": "segments.append((i - 1, i + 1))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i - 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "segments.append((i + 1, i + 1))",
      "mutated_line": "segments.append((i * 1, i + 1))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i * 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "segments.append((i + 1, i + 1))",
      "mutated_line": "segments.append((i + 1, i - 1))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i - 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "segments.append((i + 1, i + 1))",
      "mutated_line": "segments.append((i + 1, i * 1))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i * 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "segments.append((i + 2, i + 2))",
      "mutated_line": "segments.append((i - 2, i + 2))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i - 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "segments.append((i + 2, i + 2))",
      "mutated_line": "segments.append((i * 2, i + 2))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i * 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "segments.append((i + 2, i + 2))",
      "mutated_line": "segments.append((i + 2, i - 2))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i - 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "segments.append((i + 2, i + 2))",
      "mutated_line": "segments.append((i + 2, i * 2))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i * 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "segments.append((i + 1, i + 2))",
      "mutated_line": "segments.append((i - 1, i + 2))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i - 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "segments.append((i + 1, i + 2))",
      "mutated_line": "segments.append((i * 1, i + 2))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i * 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "segments.append((i + 1, i + 2))",
      "mutated_line": "segments.append((i + 1, i - 2))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i - 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "segments.append((i + 1, i + 2))",
      "mutated_line": "segments.append((i + 1, i * 2))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i * 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "segments.append((i + 1, i + 1))",
      "mutated_line": "segments.append((i + 2, i + 1))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 2, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "segments.append((i + 1, i + 1))",
      "mutated_line": "segments.append((i + 0, i + 1))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 0, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "segments.append((i + 1, i + 1))",
      "mutated_line": "segments.append((i + 0, i + 1))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 0, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "segments.append((i + 1, i + 1))",
      "mutated_line": "segments.append((i + -1, i + 1))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + -1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "segments.append((i + 1, i + 1))",
      "mutated_line": "segments.append((i + 1, i + 2))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 2))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "segments.append((i + 1, i + 1))",
      "mutated_line": "segments.append((i + 1, i + 0))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 0))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "segments.append((i + 1, i + 1))",
      "mutated_line": "segments.append((i + 1, i + 0))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 0))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "segments.append((i + 1, i + 1))",
      "mutated_line": "segments.append((i + 1, i + -1))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + -1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "segments.append((i + 2, i + 2))",
      "mutated_line": "segments.append((i + 3, i + 2))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 3, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "segments.append((i + 2, i + 2))",
      "mutated_line": "segments.append((i + 1, i + 2))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 1, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "segments.append((i + 2, i + 2))",
      "mutated_line": "segments.append((i + 0, i + 2))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 0, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "segments.append((i + 2, i + 2))",
      "mutated_line": "segments.append((i + 1, i + 2))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 1, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "segments.append((i + 2, i + 2))",
      "mutated_line": "segments.append((i + -2, i + 2))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + -2, i + 2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "segments.append((i + 2, i + 2))",
      "mutated_line": "segments.append((i + 2, i + 3))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 3))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "segments.append((i + 2, i + 2))",
      "mutated_line": "segments.append((i + 2, i + 1))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 1))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "segments.append((i + 2, i + 2))",
      "mutated_line": "segments.append((i + 2, i + 0))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 0))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "segments.append((i + 2, i + 2))",
      "mutated_line": "segments.append((i + 2, i + 1))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 1))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "segments.append((i + 2, i + 2))",
      "mutated_line": "segments.append((i + 2, i + -2))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + -2))\n        else:\n            segments.append((i + 1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "segments.append((i + 1, i + 2))",
      "mutated_line": "segments.append((i + 2, i + 2))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 2, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "segments.append((i + 1, i + 2))",
      "mutated_line": "segments.append((i + 0, i + 2))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 0, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "segments.append((i + 1, i + 2))",
      "mutated_line": "segments.append((i + 0, i + 2))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 0, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "segments.append((i + 1, i + 2))",
      "mutated_line": "segments.append((i + -1, i + 2))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + -1, i + 2))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "segments.append((i + 1, i + 2))",
      "mutated_line": "segments.append((i + 1, i + 3))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 3))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "segments.append((i + 1, i + 2))",
      "mutated_line": "segments.append((i + 1, i + 1))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 1))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "segments.append((i + 1, i + 2))",
      "mutated_line": "segments.append((i + 1, i + 0))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 0))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "segments.append((i + 1, i + 2))",
      "mutated_line": "segments.append((i + 1, i + 1))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + 1))\n    return (len(segments), segments)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "segments.append((i + 1, i + 2))",
      "mutated_line": "segments.append((i + 1, i + -2))",
      "code": "def find_partition(a: list) -> tuple:\n    \"\"\"\n    Finds a partition of the array `a` into segments such that the sum of the alternating sums of all segments is zero.\n\n    Parameters:\n    a (list): A list of integers where each element is either -1 or 1.\n\n    Returns:\n    tuple: A tuple where the first element is an integer indicating the number of segments (or -1 if no valid partition exists),\n           and the second element is a list of tuples representing the segments (or None if no valid partition exists).\n    \"\"\"\n    n = len(a)\n    if n % 2 == 1:\n        return (-1, None)\n    segments = []\n    for i in range(0, n, 2):\n        if a[i] != a[i + 1]:\n            segments.append((i + 1, i + 1))\n            segments.append((i + 2, i + 2))\n        else:\n            segments.append((i + 1, i + -2))\n    return (len(segments), segments)"
    }
  ]
}