{
  "task_id": "taco_3785",
  "entry_point": "find_lexicographically_smallest_string",
  "mutant_count": 94,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if L == 1:",
      "mutated_line": "if L != 1:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L != 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "S += S",
      "mutated_line": "S -= S",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S -= S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "f = [-1] * len(S)",
      "mutated_line": "f = [-1] / len(S)",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] / len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "f = [-1] * len(S)",
      "mutated_line": "f = [-1] + len(S)",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] + len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "f = [-1] * len(S)",
      "mutated_line": "f = [-1] ** len(S)",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] ** len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = 0",
      "mutated_line": "k = 1",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 1\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = 0",
      "mutated_line": "k = -1",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = -1\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "k = 0",
      "mutated_line": "k = 1",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 1\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if L == 1:",
      "mutated_line": "if L == 2:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 2:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if L == 1:",
      "mutated_line": "if L == 0:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 0:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if L == 1:",
      "mutated_line": "if L == 0:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 0:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if L == 1:",
      "mutated_line": "if L == -1:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == -1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, len(S)):",
      "mutated_line": "for j in range(2, len(S)):",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(2, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, len(S)):",
      "mutated_line": "for j in range(0, len(S)):",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(0, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, len(S)):",
      "mutated_line": "for j in range(0, len(S)):",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(0, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, len(S)):",
      "mutated_line": "for j in range(-1, len(S)):",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(-1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "while i != -1 and sj != S[k + i + 1]:",
      "mutated_line": "while i != -1 or sj != S[k + i + 1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 or sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if sj != S[k + i + 1]:",
      "mutated_line": "if sj == S[k + i + 1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj == S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "f = [-1] * len(S)",
      "mutated_line": "f = [+1] * len(S)",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [+1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "i = f[j - k - 1]",
      "mutated_line": "i = f[j - k + 1]",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k + 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "i = f[j - k - 1]",
      "mutated_line": "i = f[(j - k) * 1]",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[(j - k) * 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while i != -1 and sj != S[k + i + 1]:",
      "mutated_line": "while i == -1 and sj != S[k + i + 1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i == -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while i != -1 and sj != S[k + i + 1]:",
      "mutated_line": "while i != -1 and sj == S[k + i + 1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj == S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if sj < S[k + i + 1]:",
      "mutated_line": "if sj <= S[k + i + 1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj <= S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if sj < S[k + i + 1]:",
      "mutated_line": "if sj >= S[k + i + 1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj >= S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if sj < S[k + i + 1]:",
      "mutated_line": "if sj != S[k + i + 1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj != S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if sj < S[k]:",
      "mutated_line": "if sj <= S[k]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj <= S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if sj < S[k]:",
      "mutated_line": "if sj >= S[k]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj >= S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if sj < S[k]:",
      "mutated_line": "if sj != S[k]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj != S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "f[j - k] = -1",
      "mutated_line": "f[j - k] = +1",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = +1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "f[j - k] = i + 1",
      "mutated_line": "f[j - k] = i - 1",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i - 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "f[j - k] = i + 1",
      "mutated_line": "f[j - k] = i * 1",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i * 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return S[k:k + l]",
      "mutated_line": "return S[k:k - l]",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k - l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "return S[k:k + l]",
      "mutated_line": "return S[k:k * l]",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k * l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return ''.join(sorted(S))",
      "mutated_line": "return 'MUTATED'.join(sorted(S))",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return 'MUTATED'.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "f = [-1] * len(S)",
      "mutated_line": "f = [-2] * len(S)",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-2] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "f = [-1] * len(S)",
      "mutated_line": "f = [-0] * len(S)",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-0] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "f = [-1] * len(S)",
      "mutated_line": "f = [-0] * len(S)",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-0] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "f = [-1] * len(S)",
      "mutated_line": "f = [--1] * len(S)",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [--1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "i = f[j - k - 1]",
      "mutated_line": "i = f[j + k - 1]",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j + k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "i = f[j - k - 1]",
      "mutated_line": "i = f[j * k - 1]",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j * k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "i = f[j - k - 1]",
      "mutated_line": "i = f[j - k - 2]",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 2]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "i = f[j - k - 1]",
      "mutated_line": "i = f[j - k - 0]",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 0]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "i = f[j - k - 1]",
      "mutated_line": "i = f[j - k - 0]",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 0]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "i = f[j - k - 1]",
      "mutated_line": "i = f[j - k - -1]",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - -1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "while i != -1 and sj != S[k + i + 1]:",
      "mutated_line": "while i != +1 and sj != S[k + i + 1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != +1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "k = j - i - 1",
      "mutated_line": "k = j - i + 1",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i + 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "k = j - i - 1",
      "mutated_line": "k = (j - i) * 1",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = (j - i) * 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if sj != S[k + i + 1]:",
      "mutated_line": "if sj != S[k + i - 1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i - 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if sj != S[k + i + 1]:",
      "mutated_line": "if sj != S[(k + i) * 1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[(k + i) * 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "f[j - k] = -1",
      "mutated_line": "f[j + k] = -1",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j + k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "f[j - k] = -1",
      "mutated_line": "f[j * k] = -1",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j * k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "f[j - k] = -1",
      "mutated_line": "f[j - k] = -2",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -2\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "f[j - k] = -1",
      "mutated_line": "f[j - k] = -0",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -0\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "f[j - k] = -1",
      "mutated_line": "f[j - k] = -0",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -0\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "f[j - k] = -1",
      "mutated_line": "f[j - k] = --1",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = --1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "f[j - k] = i + 1",
      "mutated_line": "f[j + k] = i + 1",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j + k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "f[j - k] = i + 1",
      "mutated_line": "f[j * k] = i + 1",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j * k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "f[j - k] = i + 1",
      "mutated_line": "f[j - k] = i + 2",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 2\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "f[j - k] = i + 1",
      "mutated_line": "f[j - k] = i + 0",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 0\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "f[j - k] = i + 1",
      "mutated_line": "f[j - k] = i + 0",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 0\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "f[j - k] = i + 1",
      "mutated_line": "f[j - k] = i + -1",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + -1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while i != -1 and sj != S[k + i + 1]:",
      "mutated_line": "while i != -2 and sj != S[k + i + 1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -2 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while i != -1 and sj != S[k + i + 1]:",
      "mutated_line": "while i != -0 and sj != S[k + i + 1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -0 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while i != -1 and sj != S[k + i + 1]:",
      "mutated_line": "while i != -0 and sj != S[k + i + 1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -0 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while i != -1 and sj != S[k + i + 1]:",
      "mutated_line": "while i != --1 and sj != S[k + i + 1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != --1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "while i != -1 and sj != S[k + i + 1]:",
      "mutated_line": "while i != -1 and sj != S[k + i - 1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i - 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "while i != -1 and sj != S[k + i + 1]:",
      "mutated_line": "while i != -1 and sj != S[(k + i) * 1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[(k + i) * 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if sj < S[k + i + 1]:",
      "mutated_line": "if sj < S[k + i - 1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i - 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if sj < S[k + i + 1]:",
      "mutated_line": "if sj < S[(k + i) * 1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[(k + i) * 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "k = j - i - 1",
      "mutated_line": "k = j + i - 1",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j + i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "k = j - i - 1",
      "mutated_line": "k = j * i - 1",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j * i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "k = j - i - 1",
      "mutated_line": "k = j - i - 2",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 2\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "k = j - i - 1",
      "mutated_line": "k = j - i - 0",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 0\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "k = j - i - 1",
      "mutated_line": "k = j - i - 0",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 0\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "k = j - i - 1",
      "mutated_line": "k = j - i - -1",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - -1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if sj != S[k + i + 1]:",
      "mutated_line": "if sj != S[k - i + 1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k - i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if sj != S[k + i + 1]:",
      "mutated_line": "if sj != S[k * i + 1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k * i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if sj != S[k + i + 1]:",
      "mutated_line": "if sj != S[k + i + 2]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 2]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if sj != S[k + i + 1]:",
      "mutated_line": "if sj != S[k + i + 0]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 0]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if sj != S[k + i + 1]:",
      "mutated_line": "if sj != S[k + i + 0]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 0]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if sj != S[k + i + 1]:",
      "mutated_line": "if sj != S[k + i + -1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + -1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "while i != -1 and sj != S[k + i + 1]:",
      "mutated_line": "while i != -1 and sj != S[k - i + 1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k - i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "while i != -1 and sj != S[k + i + 1]:",
      "mutated_line": "while i != -1 and sj != S[k * i + 1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k * i + 1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while i != -1 and sj != S[k + i + 1]:",
      "mutated_line": "while i != -1 and sj != S[k + i + 2]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 2]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while i != -1 and sj != S[k + i + 1]:",
      "mutated_line": "while i != -1 and sj != S[k + i + 0]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 0]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while i != -1 and sj != S[k + i + 1]:",
      "mutated_line": "while i != -1 and sj != S[k + i + 0]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 0]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while i != -1 and sj != S[k + i + 1]:",
      "mutated_line": "while i != -1 and sj != S[k + i + -1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + -1]:\n                if sj < S[k + i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if sj < S[k + i + 1]:",
      "mutated_line": "if sj < S[k - i + 1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k - i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if sj < S[k + i + 1]:",
      "mutated_line": "if sj < S[k * i + 1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k * i + 1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if sj < S[k + i + 1]:",
      "mutated_line": "if sj < S[k + i + 2]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 2]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if sj < S[k + i + 1]:",
      "mutated_line": "if sj < S[k + i + 0]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 0]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if sj < S[k + i + 1]:",
      "mutated_line": "if sj < S[k + i + 0]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + 0]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if sj < S[k + i + 1]:",
      "mutated_line": "if sj < S[k + i + -1]:",
      "code": "def find_lexicographically_smallest_string(S: str, L: int) -> str:\n\n    def least_rotation(S: str) -> int:\n        f = [-1] * len(S)\n        k = 0\n        for j in range(1, len(S)):\n            sj = S[j]\n            i = f[j - k - 1]\n            while i != -1 and sj != S[k + i + 1]:\n                if sj < S[k + i + -1]:\n                    k = j - i - 1\n                i = f[i]\n            if sj != S[k + i + 1]:\n                if sj < S[k]:\n                    k = j\n                f[j - k] = -1\n            else:\n                f[j - k] = i + 1\n        return k\n    if L == 1:\n        l = len(S)\n        S += S\n        k = least_rotation(S)\n        return S[k:k + l]\n    else:\n        return ''.join(sorted(S))"
    }
  ]
}