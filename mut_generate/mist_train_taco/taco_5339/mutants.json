{
  "task_id": "taco_5339",
  "entry_point": "find_longest_valid_control_strings",
  "mutant_count": 202,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "sz = 1",
      "mutated_line": "sz = 2",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 2\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "sz = 1",
      "mutated_line": "sz = 0",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 0\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "sz = 1",
      "mutated_line": "sz = 0",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 0\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "sz = 1",
      "mutated_line": "sz = -1",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = -1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "p = 1000",
      "mutated_line": "p = 1001",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1001\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "p = 1000",
      "mutated_line": "p = 999",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 999\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "p = 1000",
      "mutated_line": "p = 0",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 0\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "p = 1000",
      "mutated_line": "p = 1",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "p = 1000",
      "mutated_line": "p = -1000",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = -1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "m = 0",
      "mutated_line": "m = 1",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 1\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "m = 0",
      "mutated_line": "m = -1",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = -1\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "m = 0",
      "mutated_line": "m = 1",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 1\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "while p > 1:",
      "mutated_line": "while p >= 1:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p >= 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "while p > 1:",
      "mutated_line": "while p <= 1:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p <= 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "while p > 1:",
      "mutated_line": "while p != 1:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p != 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 47,
      "original_line": "p -= 1",
      "mutated_line": "p += 1",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p += 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "while m < M:",
      "mutated_line": "while m <= M:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m <= M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "while m < M:",
      "mutated_line": "while m >= M:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m >= M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "while m < M:",
      "mutated_line": "while m != M:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m != M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 54,
      "original_line": "m += 1",
      "mutated_line": "m -= 1",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m -= 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "B[q][1] += 1",
      "mutated_line": "B[q][1] -= 1",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] -= 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "R = [0 for x in range(1000)]",
      "mutated_line": "R = [1 for x in range(1000)]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [1 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "R = [0 for x in range(1000)]",
      "mutated_line": "R = [-1 for x in range(1000)]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [-1 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "R = [0 for x in range(1000)]",
      "mutated_line": "R = [1 for x in range(1000)]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [1 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for p in range(1, sz):",
      "mutated_line": "for p in range(2, sz):",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(2, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for p in range(1, sz):",
      "mutated_line": "for p in range(0, sz):",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(0, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for p in range(1, sz):",
      "mutated_line": "for p in range(0, sz):",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(0, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "for p in range(1, sz):",
      "mutated_line": "for p in range(-1, sz):",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(-1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if n > R[d]:",
      "mutated_line": "if n >= R[d]:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n >= R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if n > R[d]:",
      "mutated_line": "if n <= R[d]:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n <= R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if n > R[d]:",
      "mutated_line": "if n != R[d]:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n != R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "while p > 1:",
      "mutated_line": "while p > 2:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 2:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "while p > 1:",
      "mutated_line": "while p > 0:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 0:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "while p > 1:",
      "mutated_line": "while p > 0:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 0:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "while p > 1:",
      "mutated_line": "while p > -1:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > -1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "p -= 1",
      "mutated_line": "p -= 2",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 2\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "p -= 1",
      "mutated_line": "p -= 0",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 0\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "p -= 1",
      "mutated_line": "p -= 0",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 0\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "p -= 1",
      "mutated_line": "p -= -1",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= -1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if R[p] > m:",
      "mutated_line": "if R[p] >= m:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] >= m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if R[p] > m:",
      "mutated_line": "if R[p] <= m:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] <= m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if R[p] > m:",
      "mutated_line": "if R[p] != m:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] != m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "m += 1",
      "mutated_line": "m += 2",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 2\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "m += 1",
      "mutated_line": "m += 0",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 0\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "m += 1",
      "mutated_line": "m += 0",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 0\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "m += 1",
      "mutated_line": "m += -1",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += -1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B = [[0, 0, -1, -1]]",
      "mutated_line": "B = [[1, 0, -1, -1]]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[1, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B = [[0, 0, -1, -1]]",
      "mutated_line": "B = [[-1, 0, -1, -1]]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[-1, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B = [[0, 0, -1, -1]]",
      "mutated_line": "B = [[1, 0, -1, -1]]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[1, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B = [[0, 0, -1, -1]]",
      "mutated_line": "B = [[0, 1, -1, -1]]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 1, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B = [[0, 0, -1, -1]]",
      "mutated_line": "B = [[0, -1, -1, -1]]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, -1, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B = [[0, 0, -1, -1]]",
      "mutated_line": "B = [[0, 1, -1, -1]]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 1, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "B = [[0, 0, -1, -1]]",
      "mutated_line": "B = [[0, 0, +1, -1]]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, +1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "B = [[0, 0, -1, -1]]",
      "mutated_line": "B = [[0, 0, -1, +1]]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, +1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "D = {1: 0}",
      "mutated_line": "D = {2: 0}",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {2: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "D = {1: 0}",
      "mutated_line": "D = {0: 0}",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {0: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "D = {1: 0}",
      "mutated_line": "D = {0: 0}",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {0: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "D = {1: 0}",
      "mutated_line": "D = {-1: 0}",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {-1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "D = {1: 0}",
      "mutated_line": "D = {1: 1}",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 1}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "D = {1: 0}",
      "mutated_line": "D = {1: -1}",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: -1}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "D = {1: 0}",
      "mutated_line": "D = {1: 1}",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 1}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for x in range(1, N):",
      "mutated_line": "for x in range(2, N):",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(2, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for x in range(1, N):",
      "mutated_line": "for x in range(0, N):",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(0, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for x in range(1, N):",
      "mutated_line": "for x in range(0, N):",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(0, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for x in range(1, N):",
      "mutated_line": "for x in range(-1, N):",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(-1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if dr == 'L':",
      "mutated_line": "if dr != 'L':",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr != 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "B[q][1] += 1",
      "mutated_line": "B[q][1] += 2",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 2\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "B[q][1] += 1",
      "mutated_line": "B[q][1] += 0",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 0\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "B[q][1] += 1",
      "mutated_line": "B[q][1] += 0",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 0\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "B[q][1] += 1",
      "mutated_line": "B[q][1] += -1",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += -1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "d = B[p][0]",
      "mutated_line": "d = B[p][1]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][1]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "d = B[p][0]",
      "mutated_line": "d = B[p][-1]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][-1]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "d = B[p][0]",
      "mutated_line": "d = B[p][1]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][1]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "n = B[p][1]",
      "mutated_line": "n = B[p][2]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][2]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "n = B[p][1]",
      "mutated_line": "n = B[p][0]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][0]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "n = B[p][1]",
      "mutated_line": "n = B[p][0]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][0]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "n = B[p][1]",
      "mutated_line": "n = B[p][-1]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][-1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "while R[p] > m:",
      "mutated_line": "while R[p] >= m:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] >= m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "while R[p] > m:",
      "mutated_line": "while R[p] <= m:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] <= m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "while R[p] > m:",
      "mutated_line": "while R[p] != m:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] != m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "m += 1",
      "mutated_line": "m -= 1",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m -= 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "st.append('0')",
      "mutated_line": "st.append('')",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B = [[0, 0, -1, -1]]",
      "mutated_line": "B = [[0, 0, -2, -1]]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -2, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B = [[0, 0, -1, -1]]",
      "mutated_line": "B = [[0, 0, -0, -1]]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -0, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B = [[0, 0, -1, -1]]",
      "mutated_line": "B = [[0, 0, -0, -1]]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -0, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B = [[0, 0, -1, -1]]",
      "mutated_line": "B = [[0, 0, --1, -1]]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, --1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B = [[0, 0, -1, -1]]",
      "mutated_line": "B = [[0, 0, -1, -2]]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -2]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B = [[0, 0, -1, -1]]",
      "mutated_line": "B = [[0, 0, -1, -0]]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -0]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B = [[0, 0, -1, -1]]",
      "mutated_line": "B = [[0, 0, -1, -0]]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -0]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "B = [[0, 0, -1, -1]]",
      "mutated_line": "B = [[0, 0, -1, --1]]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, --1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "N = int(test_case[k][0])",
      "mutated_line": "N = int(test_case[k][1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][1])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "N = int(test_case[k][0])",
      "mutated_line": "N = int(test_case[k][-1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][-1])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "N = int(test_case[k][0])",
      "mutated_line": "N = int(test_case[k][1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][1])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dr = st[1]",
      "mutated_line": "dr = st[2]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[2]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dr = st[1]",
      "mutated_line": "dr = st[0]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[0]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dr = st[1]",
      "mutated_line": "dr = st[0]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[0]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dr = st[1]",
      "mutated_line": "dr = st[-1]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[-1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d = B[p][0]",
      "mutated_line": "d = B[p][1]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][1]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d = B[p][0]",
      "mutated_line": "d = B[p][-1]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][-1]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "d = B[p][0]",
      "mutated_line": "d = B[p][1]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][1]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if dr == 'L':",
      "mutated_line": "if dr == '':",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == '':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if q == -1:",
      "mutated_line": "if q != -1:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q != -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "sz += 1",
      "mutated_line": "sz -= 1",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz -= 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if q == -1:",
      "mutated_line": "if q != -1:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q != -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "sz += 1",
      "mutated_line": "sz -= 1",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz -= 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "B[q][1] += 1",
      "mutated_line": "B[q][2] += 1",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][2] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "B[q][1] += 1",
      "mutated_line": "B[q][0] += 1",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][0] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "B[q][1] += 1",
      "mutated_line": "B[q][0] += 1",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][0] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "B[q][1] += 1",
      "mutated_line": "B[q][-1] += 1",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][-1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "R = [0 for x in range(1000)]",
      "mutated_line": "R = [0 for x in range(1001)]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1001)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "R = [0 for x in range(1000)]",
      "mutated_line": "R = [0 for x in range(999)]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(999)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "R = [0 for x in range(1000)]",
      "mutated_line": "R = [0 for x in range(0)]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(0)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "R = [0 for x in range(1000)]",
      "mutated_line": "R = [0 for x in range(1)]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "R = [0 for x in range(1000)]",
      "mutated_line": "R = [0 for x in range(-1000)]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(-1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "m += 1",
      "mutated_line": "m += 2",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 2\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "m += 1",
      "mutated_line": "m += 0",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 0\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "m += 1",
      "mutated_line": "m += 0",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 0\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "m += 1",
      "mutated_line": "m += -1",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += -1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "p = int(st[0])",
      "mutated_line": "p = int(st[1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[1])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "p = int(st[0])",
      "mutated_line": "p = int(st[-1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[-1])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "p = int(st[0])",
      "mutated_line": "p = int(st[1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[1])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "c = int(st[2])",
      "mutated_line": "c = int(st[3])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[3])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "c = int(st[2])",
      "mutated_line": "c = int(st[1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[1])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "c = int(st[2])",
      "mutated_line": "c = int(st[0])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[0])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "c = int(st[2])",
      "mutated_line": "c = int(st[1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[1])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "c = int(st[2])",
      "mutated_line": "c = int(st[-2])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[-2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q = B[p][2]",
      "mutated_line": "q = B[p][3]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q = B[p][2]",
      "mutated_line": "q = B[p][1]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][1]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q = B[p][2]",
      "mutated_line": "q = B[p][0]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][0]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q = B[p][2]",
      "mutated_line": "q = B[p][1]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][1]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q = B[p][2]",
      "mutated_line": "q = B[p][-2]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][-2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "if q == -1:",
      "mutated_line": "if q == +1:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == +1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sz += 1",
      "mutated_line": "sz += 2",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 2\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sz += 1",
      "mutated_line": "sz += 0",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 0\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sz += 1",
      "mutated_line": "sz += 0",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 0\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "sz += 1",
      "mutated_line": "sz += -1",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += -1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "q = B[p][3]",
      "mutated_line": "q = B[p][4]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][4]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "q = B[p][3]",
      "mutated_line": "q = B[p][2]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "q = B[p][3]",
      "mutated_line": "q = B[p][0]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][0]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "q = B[p][3]",
      "mutated_line": "q = B[p][1]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][1]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "q = B[p][3]",
      "mutated_line": "q = B[p][-3]",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][-3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "if q == -1:",
      "mutated_line": "if q == +1:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == +1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sz += 1",
      "mutated_line": "sz += 2",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 2\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sz += 1",
      "mutated_line": "sz += 0",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 0\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sz += 1",
      "mutated_line": "sz += 0",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 0\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sz += 1",
      "mutated_line": "sz += -1",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += -1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if q == -1:",
      "mutated_line": "if q == -2:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -2:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if q == -1:",
      "mutated_line": "if q == -0:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -0:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if q == -1:",
      "mutated_line": "if q == -0:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -0:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if q == -1:",
      "mutated_line": "if q == --1:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == --1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "B[p][2] = sz",
      "mutated_line": "B[p][3] = sz",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "B[p][2] = sz",
      "mutated_line": "B[p][1] = sz",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][1] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "B[p][2] = sz",
      "mutated_line": "B[p][0] = sz",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][0] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "B[p][2] = sz",
      "mutated_line": "B[p][1] = sz",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][1] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "B[p][2] = sz",
      "mutated_line": "B[p][-2] = sz",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][-2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if q == -1:",
      "mutated_line": "if q == -2:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -2:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if q == -1:",
      "mutated_line": "if q == -0:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -0:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if q == -1:",
      "mutated_line": "if q == -0:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -0:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if q == -1:",
      "mutated_line": "if q == --1:",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == --1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "B[p][3] = sz",
      "mutated_line": "B[p][4] = sz",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][4] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "B[p][3] = sz",
      "mutated_line": "B[p][2] = sz",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "B[p][3] = sz",
      "mutated_line": "B[p][0] = sz",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][0] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "B[p][3] = sz",
      "mutated_line": "B[p][1] = sz",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][1] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "B[p][3] = sz",
      "mutated_line": "B[p][-3] = sz",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][-3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d - 1, 0, -1, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d - 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d * 1, 0, -1, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d * 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, 1, -1, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 1, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, -1, -1, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, -1, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, 1, -1, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 1, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, 0, +1, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, +1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, 0, -1, +1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, +1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d - 1, 0, -1, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d - 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d * 1, 0, -1, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d * 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, 1, -1, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 1, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, -1, -1, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, -1, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, 1, -1, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 1, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, 0, +1, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, +1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, 0, -1, +1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, +1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 2, 0, -1, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 2, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 0, 0, -1, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 0, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 0, 0, -1, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 0, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + -1, 0, -1, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + -1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, 0, -2, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -2, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, 0, -0, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -0, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, 0, -0, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -0, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, 0, --1, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, --1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, 0, -1, -2])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -2])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, 0, -1, -0])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -0])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, 0, -1, -0])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -0])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, 0, -1, --1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, --1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 2, 0, -1, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 2, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 0, 0, -1, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 0, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 0, 0, -1, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 0, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + -1, 0, -1, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + -1, 0, -1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, 0, -2, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -2, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, 0, -0, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -0, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, 0, -0, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -0, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, 0, --1, -1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, --1, -1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, 0, -1, -2])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -2])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, 0, -1, -0])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -0])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, 0, -1, -0])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -0])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "B.append([d + 1, 0, -1, -1])",
      "mutated_line": "B.append([d + 1, 0, -1, --1])",
      "code": "def find_longest_valid_control_strings(test_cases):\n    results = []\n    for test_case in test_cases:\n        M = len(test_case)\n        B = [[0, 0, -1, -1]]\n        sz = 1\n        for k in range(M):\n            D = {1: 0}\n            N = int(test_case[k][0])\n            for x in range(1, N):\n                st = test_case[k][x].split()\n                p = int(st[0])\n                dr = st[1]\n                c = int(st[2])\n                p = D[p]\n                d = B[p][0]\n                if dr == 'L':\n                    q = B[p][2]\n                    if q == -1:\n                        q = sz\n                        B[p][2] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, -1])\n                else:\n                    q = B[p][3]\n                    if q == -1:\n                        q = sz\n                        B[p][3] = sz\n                        sz += 1\n                        B.append([d + 1, 0, -1, --1])\n                D[c] = q\n                B[q][1] += 1\n        R = [0 for x in range(1000)]\n        for p in range(1, sz):\n            d = B[p][0]\n            n = B[p][1]\n            if n > R[d]:\n                R[d] = n\n        st = []\n        p = 1000\n        m = 0\n        while p > 1:\n            p -= 1\n            if R[p] > m:\n                while R[p] > m:\n                    st.append(str(p))\n                    m += 1\n        while m < M:\n            st.append('0')\n            m += 1\n        results.append(st)\n    return results"
    }
  ]
}