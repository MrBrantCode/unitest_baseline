{
  "task_id": "taco_1897",
  "entry_point": "calculate_unburnt_nations",
  "mutant_count": 271,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "component_id = 1",
      "mutated_line": "component_id = 2",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 2\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "component_id = 1",
      "mutated_line": "component_id = 0",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 0\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "component_id = 1",
      "mutated_line": "component_id = 0",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 0\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "component_id = 1",
      "mutated_line": "component_id = -1",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = -1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "co = 0",
      "mutated_line": "co = 1",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 1\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "co = 0",
      "mutated_line": "co = -1",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = -1\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "co = 0",
      "mutated_line": "co = 1",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 1\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 3,
      "original_line": "return y >= 0 and x >= 0 and y < M and x < N",
      "mutated_line": "return y >= 0 or x >= 0 or y < M or (x < N)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 or x >= 0 or y < M or (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = 1",
      "mutated_line": "c = 2",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 2\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = 1",
      "mutated_line": "c = 0",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 0\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = 1",
      "mutated_line": "c = 0",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 0\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = 1",
      "mutated_line": "c = -1",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = -1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if grid[x-1][y-1] == \"0\":",
      "mutated_line": "if grid[x - 1][y - 1] != '0':",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] != '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return y >= 0 and x >= 0 and y < M and x < N",
      "mutated_line": "return y > 0 and x >= 0 and (y < M) and (x < N)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y > 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return y >= 0 and x >= 0 and y < M and x < N",
      "mutated_line": "return y < 0 and x >= 0 and (y < M) and (x < N)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y < 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return y >= 0 and x >= 0 and y < M and x < N",
      "mutated_line": "return y == 0 and x >= 0 and (y < M) and (x < N)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y == 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return y >= 0 and x >= 0 and y < M and x < N",
      "mutated_line": "return y >= 0 and x > 0 and (y < M) and (x < N)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x > 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return y >= 0 and x >= 0 and y < M and x < N",
      "mutated_line": "return y >= 0 and x < 0 and (y < M) and (x < N)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x < 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return y >= 0 and x >= 0 and y < M and x < N",
      "mutated_line": "return y >= 0 and x == 0 and (y < M) and (x < N)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x == 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return y >= 0 and x >= 0 and y < M and x < N",
      "mutated_line": "return y >= 0 and x >= 0 and (y <= M) and (x < N)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y <= M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return y >= 0 and x >= 0 and y < M and x < N",
      "mutated_line": "return y >= 0 and x >= 0 and (y >= M) and (x < N)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y >= M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return y >= 0 and x >= 0 and y < M and x < N",
      "mutated_line": "return y >= 0 and x >= 0 and (y != M) and (x < N)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y != M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return y >= 0 and x >= 0 and y < M and x < N",
      "mutated_line": "return y >= 0 and x >= 0 and (y < M) and (x <= N)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x <= N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return y >= 0 and x >= 0 and y < M and x < N",
      "mutated_line": "return y >= 0 and x >= 0 and (y < M) and (x >= N)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x >= N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return y >= 0 and x >= 0 and y < M and x < N",
      "mutated_line": "return y >= 0 and x >= 0 and (y < M) and (x != N)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x != N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mark[top[0]][top[1]] = True",
      "mutated_line": "mark[top[0]][top[1]] = False",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = False\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(2, 0), (-1, 0), (0, 1), (0, -1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(2, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(0, 0), (-1, 0), (0, 1), (0, -1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(0, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(-1, 0), (-1, 0), (0, 1), (0, -1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(-1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, 1), (-1, 0), (0, 1), (0, -1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 1), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, -1), (-1, 0), (0, 1), (0, -1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, -1), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, 1), (-1, 0), (0, 1), (0, -1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 1), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, 0), (+1, 0), (0, 1), (0, -1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (+1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, 0), (-1, 1), (0, 1), (0, -1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 1), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, 0), (-1, -1), (0, 1), (0, -1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, -1), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, 0), (-1, 1), (0, 1), (0, -1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 1), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, 0), (-1, 0), (1, 1), (0, -1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (1, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, 0), (-1, 0), (-1, 1), (0, -1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (-1, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, 0), (-1, 0), (1, 1), (0, -1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (1, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, 0), (-1, 0), (0, 2), (0, -1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 2), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, 0), (-1, 0), (0, 0), (0, -1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 0), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, 0), (-1, 0), (0, 0), (0, -1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 0), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, 0), (-1, 0), (0, -1), (0, -1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, -1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, 0), (-1, 0), (0, 1), (1, -1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (1, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, 0), (-1, 0), (0, 1), (-1, -1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (-1, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, 0), (-1, 0), (0, 1), (1, -1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (1, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, +1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, +1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mark = [[False for _ in range(M)] for _ in range(N)]",
      "mutated_line": "mark = [[True for _ in range(M)] for _ in range(N)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[True for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "parent = [[0 for _ in range(M)] for _ in range(N)]",
      "mutated_line": "parent = [[1 for _ in range(M)] for _ in range(N)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[1 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "parent = [[0 for _ in range(M)] for _ in range(N)]",
      "mutated_line": "parent = [[-1 for _ in range(M)] for _ in range(N)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[-1 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "parent = [[0 for _ in range(M)] for _ in range(N)]",
      "mutated_line": "parent = [[1 for _ in range(M)] for _ in range(N)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[1 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if grid[i][j] == \"1\":",
      "mutated_line": "if grid[i][j] != '1':",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] != '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "co += 1",
      "mutated_line": "co -= 1",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co -= 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if grid[x-1][y-1] == \"0\":",
      "mutated_line": "if grid[x - 1][y - 1] == '':",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if f[parent[x-1][y-1]] == True:",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] != True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return y >= 0 and x >= 0 and y < M and x < N",
      "mutated_line": "return y >= 1 and x >= 0 and (y < M) and (x < N)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 1 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return y >= 0 and x >= 0 and y < M and x < N",
      "mutated_line": "return y >= -1 and x >= 0 and (y < M) and (x < N)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= -1 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return y >= 0 and x >= 0 and y < M and x < N",
      "mutated_line": "return y >= 1 and x >= 0 and (y < M) and (x < N)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 1 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return y >= 0 and x >= 0 and y < M and x < N",
      "mutated_line": "return y >= 0 and x >= 1 and (y < M) and (x < N)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 1 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return y >= 0 and x >= 0 and y < M and x < N",
      "mutated_line": "return y >= 0 and x >= -1 and (y < M) and (x < N)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= -1 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return y >= 0 and x >= 0 and y < M and x < N",
      "mutated_line": "return y >= 0 and x >= 1 and (y < M) and (x < N)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 1 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "top = q.pop(0)",
      "mutated_line": "top = q.pop(1)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(1)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "top = q.pop(0)",
      "mutated_line": "top = q.pop(-1)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(-1)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "top = q.pop(0)",
      "mutated_line": "top = q.pop(1)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(1)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) or grid[top[0] + k[0]][top[1] + k[1]] == '1' or mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) or grid[top[0] + k[0]][top[1] + k[1]] == '1' or mark[top[0] + k[0]][top[1] + k[1]] == False:\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "c += 1",
      "mutated_line": "c -= 1",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c -= 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, 0), (-2, 0), (0, 1), (0, -1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-2, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, 0), (-0, 0), (0, 1), (0, -1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-0, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, 0), (-0, 0), (0, 1), (0, -1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-0, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, 0), (--1, 0), (0, 1), (0, -1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (--1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -2)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -2)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -0)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -0)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -0)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -0)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, upward, right, left (i, j)",
      "mutated_line": "dif = [(1, 0), (-1, 0), (0, 1), (0, --1)]",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, --1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if grid[i][j] == \"1\":",
      "mutated_line": "if grid[i][j] == '':",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "co += 1",
      "mutated_line": "co += 2",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 2\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "co += 1",
      "mutated_line": "co += 0",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 0\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "co += 1",
      "mutated_line": "co += 0",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 0\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "co += 1",
      "mutated_line": "co += -1",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += -1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if mark[i][j] == False:",
      "mutated_line": "if mark[i][j] != False:",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] != False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "component_id += 1",
      "mutated_line": "component_id -= 1",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id -= 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "if grid[x-1][y-1] == \"0\":",
      "mutated_line": "if grid[x - 1][y + 1] == '0':",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y + 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "if grid[x-1][y-1] == \"0\":",
      "mutated_line": "if grid[x - 1][y * 1] == '0':",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y * 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if f[parent[x-1][y-1]] == True:",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == False:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "co = co - d[parent[x-1][y-1]]",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co + d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "co = co - d[parent[x-1][y-1]]",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co * d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "f[parent[x-1][y-1]] = False",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = True\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "parent[top[0]][top[1]] = component_id",
      "mutated_line": "parent[top[0]][top[2]] = component_id",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[2]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "parent[top[0]][top[1]] = component_id",
      "mutated_line": "parent[top[0]][top[0]] = component_id",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[0]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "parent[top[0]][top[1]] = component_id",
      "mutated_line": "parent[top[0]][top[0]] = component_id",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[0]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "parent[top[0]][top[1]] = component_id",
      "mutated_line": "parent[top[0]][top[-1]] = component_id",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[-1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mark[top[0]][top[1]] = True",
      "mutated_line": "mark[top[0]][top[2]] = True",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[2]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mark[top[0]][top[1]] = True",
      "mutated_line": "mark[top[0]][top[0]] = True",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[0]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mark[top[0]][top[1]] = True",
      "mutated_line": "mark[top[0]][top[0]] = True",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[0]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mark[top[0]][top[1]] = True",
      "mutated_line": "mark[top[0]][top[-1]] = True",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[-1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] != '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] != '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] != False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] != False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mark[top[0] + k[0]][top[1] + k[1]] = True",
      "mutated_line": "mark[top[0] + k[0]][top[1] + k[1]] = False",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = False\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "c += 1",
      "mutated_line": "c += 2",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 2\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 0\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 0\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "c += 1",
      "mutated_line": "c += -1",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += -1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if mark[i][j] == False:",
      "mutated_line": "if mark[i][j] == True:",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == True:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "f[component_id] = True",
      "mutated_line": "f[component_id] = False",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = False\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "component_id += 1",
      "mutated_line": "component_id += 2",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 2\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "component_id += 1",
      "mutated_line": "component_id += 0",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 0\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "component_id += 1",
      "mutated_line": "component_id += 0",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 0\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "component_id += 1",
      "mutated_line": "component_id += -1",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += -1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "if grid[x-1][y-1] == \"0\":",
      "mutated_line": "if grid[x + 1][y - 1] == '0':",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x + 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "if grid[x-1][y-1] == \"0\":",
      "mutated_line": "if grid[x * 1][y - 1] == '0':",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x * 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if grid[x-1][y-1] == \"0\":",
      "mutated_line": "if grid[x - 1][y - 2] == '0':",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 2] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if grid[x-1][y-1] == \"0\":",
      "mutated_line": "if grid[x - 1][y - 0] == '0':",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 0] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if grid[x-1][y-1] == \"0\":",
      "mutated_line": "if grid[x - 1][y - 0] == '0':",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 0] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if grid[x-1][y-1] == \"0\":",
      "mutated_line": "if grid[x - 1][y - -1] == '0':",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - -1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "parent[top[0]][top[1]] = component_id",
      "mutated_line": "parent[top[1]][top[1]] = component_id",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[1]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "parent[top[0]][top[1]] = component_id",
      "mutated_line": "parent[top[-1]][top[1]] = component_id",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[-1]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "parent[top[0]][top[1]] = component_id",
      "mutated_line": "parent[top[1]][top[1]] = component_id",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[1]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mark[top[0]][top[1]] = True",
      "mutated_line": "mark[top[1]][top[1]] = True",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[1]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mark[top[0]][top[1]] = True",
      "mutated_line": "mark[top[-1]][top[1]] = True",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[-1]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mark[top[0]][top[1]] = True",
      "mutated_line": "mark[top[1]][top[1]] = True",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[1]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] - k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] - k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] * k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] * k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] - k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] - k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] * k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] * k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == True):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == True):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "mark[top[0] + k[0]][top[1] + k[1]] = True",
      "mutated_line": "mark[top[0] + k[0]][top[1] - k[1]] = True",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] - k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "mark[top[0] + k[0]][top[1] + k[1]] = True",
      "mutated_line": "mark[top[0] + k[0]][top[1] * k[1]] = True",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] * k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "parent[top[0] + k[0]][top[1] + k[1]] = component_id",
      "mutated_line": "parent[top[0] + k[0]][top[1] - k[1]] = component_id",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] - k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "parent[top[0] + k[0]][top[1] + k[1]] = component_id",
      "mutated_line": "parent[top[0] + k[0]][top[1] * k[1]] = component_id",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] * k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if grid[x-1][y-1] == \"0\":",
      "mutated_line": "if grid[x - 2][y - 1] == '0':",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 2][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if grid[x-1][y-1] == \"0\":",
      "mutated_line": "if grid[x - 0][y - 1] == '0':",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 0][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if grid[x-1][y-1] == \"0\":",
      "mutated_line": "if grid[x - 0][y - 1] == '0':",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 0][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if grid[x-1][y-1] == \"0\":",
      "mutated_line": "if grid[x - -1][y - 1] == '0':",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - -1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "if f[parent[x-1][y-1]] == True:",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y + 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "if f[parent[x-1][y-1]] == True:",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y * 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "f[parent[x-1][y-1]] = False",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y + 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "f[parent[x-1][y-1]] = False",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y * 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] - k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] - k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] * k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] * k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] - k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] - k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] * k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] * k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "mark[top[0] + k[0]][top[1] + k[1]] = True",
      "mutated_line": "mark[top[0] - k[0]][top[1] + k[1]] = True",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] - k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "mark[top[0] + k[0]][top[1] + k[1]] = True",
      "mutated_line": "mark[top[0] * k[0]][top[1] + k[1]] = True",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] * k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "parent[top[0] + k[0]][top[1] + k[1]] = component_id",
      "mutated_line": "parent[top[0] - k[0]][top[1] + k[1]] = component_id",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] - k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "parent[top[0] + k[0]][top[1] + k[1]] = component_id",
      "mutated_line": "parent[top[0] * k[0]][top[1] + k[1]] = component_id",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] * k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "q.append((top[0] + k[0], top[1] + k[1]))",
      "mutated_line": "q.append((top[0] - k[0], top[1] + k[1]))",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] - k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "q.append((top[0] + k[0], top[1] + k[1]))",
      "mutated_line": "q.append((top[0] * k[0], top[1] + k[1]))",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] * k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "q.append((top[0] + k[0], top[1] + k[1]))",
      "mutated_line": "q.append((top[0] + k[0], top[1] - k[1]))",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] - k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "q.append((top[0] + k[0], top[1] + k[1]))",
      "mutated_line": "q.append((top[0] + k[0], top[1] * k[1]))",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] * k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "if f[parent[x-1][y-1]] == True:",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x + 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "if f[parent[x-1][y-1]] == True:",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x * 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if f[parent[x-1][y-1]] == True:",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 2]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if f[parent[x-1][y-1]] == True:",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 0]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if f[parent[x-1][y-1]] == True:",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 0]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if f[parent[x-1][y-1]] == True:",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - -1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "co = co - d[parent[x-1][y-1]]",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y + 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "co = co - d[parent[x-1][y-1]]",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y * 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "f[parent[x-1][y-1]] = False",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x + 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "f[parent[x-1][y-1]] = False",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x * 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "f[parent[x-1][y-1]] = False",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 2]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "f[parent[x-1][y-1]] = False",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 0]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "f[parent[x-1][y-1]] = False",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 0]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "f[parent[x-1][y-1]] = False",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - -1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[1] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[1] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[-1] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[-1] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[1] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[1] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[1], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[1], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[-1], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[-1], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[1], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[1], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[2] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[2] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[0] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[0] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[0] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[0] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[-1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[-1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[2]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[2]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[0]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[0]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[0]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[0]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[-1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[-1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] - k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] - k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] * k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] * k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] - k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] - k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] * k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] * k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mark[top[0] + k[0]][top[1] + k[1]] = True",
      "mutated_line": "mark[top[0] + k[0]][top[2] + k[1]] = True",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[2] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mark[top[0] + k[0]][top[1] + k[1]] = True",
      "mutated_line": "mark[top[0] + k[0]][top[0] + k[1]] = True",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[0] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mark[top[0] + k[0]][top[1] + k[1]] = True",
      "mutated_line": "mark[top[0] + k[0]][top[0] + k[1]] = True",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[0] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mark[top[0] + k[0]][top[1] + k[1]] = True",
      "mutated_line": "mark[top[0] + k[0]][top[-1] + k[1]] = True",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[-1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mark[top[0] + k[0]][top[1] + k[1]] = True",
      "mutated_line": "mark[top[0] + k[0]][top[1] + k[2]] = True",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[2]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mark[top[0] + k[0]][top[1] + k[1]] = True",
      "mutated_line": "mark[top[0] + k[0]][top[1] + k[0]] = True",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[0]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mark[top[0] + k[0]][top[1] + k[1]] = True",
      "mutated_line": "mark[top[0] + k[0]][top[1] + k[0]] = True",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[0]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mark[top[0] + k[0]][top[1] + k[1]] = True",
      "mutated_line": "mark[top[0] + k[0]][top[1] + k[-1]] = True",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[-1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "parent[top[0] + k[0]][top[1] + k[1]] = component_id",
      "mutated_line": "parent[top[0] + k[0]][top[2] + k[1]] = component_id",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[2] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "parent[top[0] + k[0]][top[1] + k[1]] = component_id",
      "mutated_line": "parent[top[0] + k[0]][top[0] + k[1]] = component_id",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[0] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "parent[top[0] + k[0]][top[1] + k[1]] = component_id",
      "mutated_line": "parent[top[0] + k[0]][top[0] + k[1]] = component_id",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[0] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "parent[top[0] + k[0]][top[1] + k[1]] = component_id",
      "mutated_line": "parent[top[0] + k[0]][top[-1] + k[1]] = component_id",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[-1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "parent[top[0] + k[0]][top[1] + k[1]] = component_id",
      "mutated_line": "parent[top[0] + k[0]][top[1] + k[2]] = component_id",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[2]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "parent[top[0] + k[0]][top[1] + k[1]] = component_id",
      "mutated_line": "parent[top[0] + k[0]][top[1] + k[0]] = component_id",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[0]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "parent[top[0] + k[0]][top[1] + k[1]] = component_id",
      "mutated_line": "parent[top[0] + k[0]][top[1] + k[0]] = component_id",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[0]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "parent[top[0] + k[0]][top[1] + k[1]] = component_id",
      "mutated_line": "parent[top[0] + k[0]][top[1] + k[-1]] = component_id",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[-1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if f[parent[x-1][y-1]] == True:",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 2][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if f[parent[x-1][y-1]] == True:",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 0][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if f[parent[x-1][y-1]] == True:",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 0][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if f[parent[x-1][y-1]] == True:",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - -1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "co = co - d[parent[x-1][y-1]]",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x + 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "co = co - d[parent[x-1][y-1]]",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x * 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "co = co - d[parent[x-1][y-1]]",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 2]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "co = co - d[parent[x-1][y-1]]",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 0]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "co = co - d[parent[x-1][y-1]]",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 0]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "co = co - d[parent[x-1][y-1]]",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - -1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "f[parent[x-1][y-1]] = False",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 2][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "f[parent[x-1][y-1]] = False",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 0][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "f[parent[x-1][y-1]] = False",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 0][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "f[parent[x-1][y-1]] = False",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - -1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[2] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[2] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[0] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[0] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[0] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[0] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[-1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[-1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[2]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[2]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[0]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[0]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[0]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[0]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[-1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[-1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[2] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[2] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[0] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[0] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[0] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[0] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[-1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[-1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[2]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[2]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[0]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[0]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[0]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[0]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[-1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[-1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mark[top[0] + k[0]][top[1] + k[1]] = True",
      "mutated_line": "mark[top[1] + k[0]][top[1] + k[1]] = True",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[1] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mark[top[0] + k[0]][top[1] + k[1]] = True",
      "mutated_line": "mark[top[-1] + k[0]][top[1] + k[1]] = True",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[-1] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mark[top[0] + k[0]][top[1] + k[1]] = True",
      "mutated_line": "mark[top[1] + k[0]][top[1] + k[1]] = True",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[1] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mark[top[0] + k[0]][top[1] + k[1]] = True",
      "mutated_line": "mark[top[0] + k[1]][top[1] + k[1]] = True",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[1]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mark[top[0] + k[0]][top[1] + k[1]] = True",
      "mutated_line": "mark[top[0] + k[-1]][top[1] + k[1]] = True",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[-1]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "mark[top[0] + k[0]][top[1] + k[1]] = True",
      "mutated_line": "mark[top[0] + k[1]][top[1] + k[1]] = True",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[1]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "parent[top[0] + k[0]][top[1] + k[1]] = component_id",
      "mutated_line": "parent[top[1] + k[0]][top[1] + k[1]] = component_id",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[1] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "parent[top[0] + k[0]][top[1] + k[1]] = component_id",
      "mutated_line": "parent[top[-1] + k[0]][top[1] + k[1]] = component_id",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[-1] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "parent[top[0] + k[0]][top[1] + k[1]] = component_id",
      "mutated_line": "parent[top[1] + k[0]][top[1] + k[1]] = component_id",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[1] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "parent[top[0] + k[0]][top[1] + k[1]] = component_id",
      "mutated_line": "parent[top[0] + k[1]][top[1] + k[1]] = component_id",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[1]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "parent[top[0] + k[0]][top[1] + k[1]] = component_id",
      "mutated_line": "parent[top[0] + k[-1]][top[1] + k[1]] = component_id",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[-1]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "parent[top[0] + k[0]][top[1] + k[1]] = component_id",
      "mutated_line": "parent[top[0] + k[1]][top[1] + k[1]] = component_id",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[1]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q.append((top[0] + k[0], top[1] + k[1]))",
      "mutated_line": "q.append((top[1] + k[0], top[1] + k[1]))",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[1] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q.append((top[0] + k[0], top[1] + k[1]))",
      "mutated_line": "q.append((top[-1] + k[0], top[1] + k[1]))",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[-1] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q.append((top[0] + k[0], top[1] + k[1]))",
      "mutated_line": "q.append((top[1] + k[0], top[1] + k[1]))",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[1] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q.append((top[0] + k[0], top[1] + k[1]))",
      "mutated_line": "q.append((top[0] + k[1], top[1] + k[1]))",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[1], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q.append((top[0] + k[0], top[1] + k[1]))",
      "mutated_line": "q.append((top[0] + k[-1], top[1] + k[1]))",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[-1], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q.append((top[0] + k[0], top[1] + k[1]))",
      "mutated_line": "q.append((top[0] + k[1], top[1] + k[1]))",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[1], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q.append((top[0] + k[0], top[1] + k[1]))",
      "mutated_line": "q.append((top[0] + k[0], top[2] + k[1]))",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[2] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q.append((top[0] + k[0], top[1] + k[1]))",
      "mutated_line": "q.append((top[0] + k[0], top[0] + k[1]))",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[0] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q.append((top[0] + k[0], top[1] + k[1]))",
      "mutated_line": "q.append((top[0] + k[0], top[0] + k[1]))",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[0] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q.append((top[0] + k[0], top[1] + k[1]))",
      "mutated_line": "q.append((top[0] + k[0], top[-1] + k[1]))",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[-1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q.append((top[0] + k[0], top[1] + k[1]))",
      "mutated_line": "q.append((top[0] + k[0], top[1] + k[2]))",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[2]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q.append((top[0] + k[0], top[1] + k[1]))",
      "mutated_line": "q.append((top[0] + k[0], top[1] + k[0]))",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[0]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q.append((top[0] + k[0], top[1] + k[1]))",
      "mutated_line": "q.append((top[0] + k[0], top[1] + k[0]))",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[0]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "q.append((top[0] + k[0], top[1] + k[1]))",
      "mutated_line": "q.append((top[0] + k[0], top[1] + k[-1]))",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[-1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "co = co - d[parent[x-1][y-1]]",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 2][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "co = co - d[parent[x-1][y-1]]",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 0][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "co = co - d[parent[x-1][y-1]]",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 0][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "co = co - d[parent[x-1][y-1]]",
      "mutated_line": "results.append(co)",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - -1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[1] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[1] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[-1] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[-1] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[1] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[1] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[1]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[1]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[-1]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[-1]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[1]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[1]][top[1] + k[1]] == '1' and (mark[top[0] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[1] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[1] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[-1] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[-1] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[1] + k[0]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[1] + k[0]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[1]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[1]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[-1]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[-1]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if (valid(top[0] + k[0], top[1] + k[1])) and (grid[top[0] + k[0]][top[1] + k[1]] == \"1\") and mark[top[0] + k[0]][top[1] + k[1]] == False:",
      "mutated_line": "if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[1]][top[1] + k[1]] == False):",
      "code": "def calculate_unburnt_nations(N, M, Q, grid, attacks):\n\n    def valid(x, y):\n        return y >= 0 and x >= 0 and (y < M) and (x < N)\n\n    def dfs(start):\n        nonlocal component_id\n        c = 1\n        q = [start]\n        while q:\n            top = q.pop(0)\n            parent[top[0]][top[1]] = component_id\n            mark[top[0]][top[1]] = True\n            for k in dif:\n                if valid(top[0] + k[0], top[1] + k[1]) and grid[top[0] + k[0]][top[1] + k[1]] == '1' and (mark[top[0] + k[1]][top[1] + k[1]] == False):\n                    mark[top[0] + k[0]][top[1] + k[1]] = True\n                    parent[top[0] + k[0]][top[1] + k[1]] = component_id\n                    c += 1\n                    q.append((top[0] + k[0], top[1] + k[1]))\n        return c\n    dif = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    mark = [[False for _ in range(M)] for _ in range(N)]\n    parent = [[0 for _ in range(M)] for _ in range(N)]\n    component_id = 1\n    co = 0\n    d = {}\n    f = {}\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '1':\n                co += 1\n                if mark[i][j] == False:\n                    tI = dfs((i, j))\n                    d[component_id] = tI\n                    f[component_id] = True\n                    component_id += 1\n    results = []\n    for (x, y) in attacks:\n        if grid[x - 1][y - 1] == '0':\n            results.append(co)\n        elif f[parent[x - 1][y - 1]] == True:\n            co = co - d[parent[x - 1][y - 1]]\n            f[parent[x - 1][y - 1]] = False\n            results.append(co)\n        else:\n            results.append(co)\n    return results"
    }
  ]
}