{
  "task_id": "taco_7243",
  "entry_point": "decrypt_canisal_cipher",
  "mutant_count": 139,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 5,
      "original_line": "if len(C) == 1 and M == 0:",
      "mutated_line": "if len(C) == 1 or M == 0:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 or M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 - 7",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 - 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 * 7",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 * 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "L = [0] * 10",
      "mutated_line": "L = [0] / 10",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] / 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "L = [0] * 10",
      "mutated_line": "L = [0] + 10",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] + 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "L = [0] * 10",
      "mutated_line": "L = [0] ** 10",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] ** 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "b = 1",
      "mutated_line": "b = 2",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 2\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "b = 1",
      "mutated_line": "b = 0",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 0\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "b = 1",
      "mutated_line": "b = 0",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 0\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "b = 1",
      "mutated_line": "b = -1",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = -1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "L[c] += b",
      "mutated_line": "L[c] -= b",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] -= b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return \"-1\"",
      "mutated_line": "return ''",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return ''"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if len(C) == 1 and M == 0:",
      "mutated_line": "if len(C) != 1 and M == 0:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) != 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if len(C) == 1 and M == 0:",
      "mutated_line": "if len(C) == 1 and M != 0:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M != 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return \"0\"",
      "mutated_line": "return ''",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return ''\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 * 9 + 7",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 * 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 + 9 + 7",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 + 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 8",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 8\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 6",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 6\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 0",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 0\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 1",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 1\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + -7",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + -7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "L = [0] * 10",
      "mutated_line": "L = [0] * 11",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 11\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "L = [0] * 10",
      "mutated_line": "L = [0] * 9",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 9\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "L = [0] * 10",
      "mutated_line": "L = [0] * 0",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 0\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "L = [0] * 10",
      "mutated_line": "L = [0] * 1",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 1\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "L = [0] * 10",
      "mutated_line": "L = [0] * -10",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * -10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "b = b * 10 % mod",
      "mutated_line": "b = b * 10 * mod",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 * mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "b = b * 10 % mod",
      "mutated_line": "b = b * 10 + mod",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 + mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for t_half1 in combinations(range(10), 5):",
      "mutated_line": "for t_half1 in combinations(range(10), 6):",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 6):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for t_half1 in combinations(range(10), 5):",
      "mutated_line": "for t_half1 in combinations(range(10), 4):",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 4):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for t_half1 in combinations(range(10), 5):",
      "mutated_line": "for t_half1 in combinations(range(10), 0):",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 0):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for t_half1 in combinations(range(10), 5):",
      "mutated_line": "for t_half1 in combinations(range(10), 1):",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 1):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for t_half1 in combinations(range(10), 5):",
      "mutated_line": "for t_half1 in combinations(range(10), -5):",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), -5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if int(C[0]) < 5:",
      "mutated_line": "if int(C[0]) <= 5:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) <= 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if int(C[0]) < 5:",
      "mutated_line": "if int(C[0]) >= 5:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) >= 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if int(C[0]) < 5:",
      "mutated_line": "if int(C[0]) != 5:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) != 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if len(C) == 1 and M == 0:",
      "mutated_line": "if len(C) == 2 and M == 0:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 2 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if len(C) == 1 and M == 0:",
      "mutated_line": "if len(C) == 0 and M == 0:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 0 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if len(C) == 1 and M == 0:",
      "mutated_line": "if len(C) == 0 and M == 0:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 0 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if len(C) == 1 and M == 0:",
      "mutated_line": "if len(C) == -1 and M == 0:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == -1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if len(C) == 1 and M == 0:",
      "mutated_line": "if len(C) == 1 and M == 1:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 1:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if len(C) == 1 and M == 0:",
      "mutated_line": "if len(C) == 1 and M == -1:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == -1:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if len(C) == 1 and M == 0:",
      "mutated_line": "if len(C) == 1 and M == 1:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 1:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 11 ** 9 + 7",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 11 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 9 ** 9 + 7",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 9 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 0 ** 9 + 7",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 0 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 1 ** 9 + 7",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 1 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = -10 ** 9 + 7",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = -10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 10 + 7",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 10 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 8 + 7",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 8 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 0 + 7",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 0 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 1 + 7",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 1 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** -9 + 7",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** -9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "L = [0] * 10",
      "mutated_line": "L = [1] * 10",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [1] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "L = [0] * 10",
      "mutated_line": "L = [-1] * 10",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [-1] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "L = [0] * 10",
      "mutated_line": "L = [1] * 10",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [1] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "for c in C[::-1]:",
      "mutated_line": "for c in C[::+1]:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::+1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "b = b * 10 % mod",
      "mutated_line": "b = b / 10 % mod",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b / 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "b = b * 10 % mod",
      "mutated_line": "b = (b + 10) % mod",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = (b + 10) % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "b = b * 10 % mod",
      "mutated_line": "b = b ** 10 % mod",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b ** 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for t_half1 in combinations(range(10), 5):",
      "mutated_line": "for t_half1 in combinations(range(11), 5):",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(11), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for t_half1 in combinations(range(10), 5):",
      "mutated_line": "for t_half1 in combinations(range(9), 5):",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(9), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for t_half1 in combinations(range(10), 5):",
      "mutated_line": "for t_half1 in combinations(range(0), 5):",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(0), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for t_half1 in combinations(range(10), 5):",
      "mutated_line": "for t_half1 in combinations(range(1), 5):",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(1), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for t_half1 in combinations(range(10), 5):",
      "mutated_line": "for t_half1 in combinations(range(-10), 5):",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(-10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "t_half2 = list(set(range(10)) - set(t_half1))",
      "mutated_line": "t_half2 = list(set(range(10)) + set(t_half1))",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) + set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "t_half2 = list(set(range(10)) - set(t_half1))",
      "mutated_line": "t_half2 = list(set(range(10)) * set(t_half1))",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) * set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if int(C[0]) < 5:",
      "mutated_line": "if int(C[0]) < 6:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 6:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if int(C[0]) < 5:",
      "mutated_line": "if int(C[0]) < 4:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 4:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if int(C[0]) < 5:",
      "mutated_line": "if int(C[0]) < 0:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 0:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if int(C[0]) < 5:",
      "mutated_line": "if int(C[0]) < 1:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 1:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if int(C[0]) < 5:",
      "mutated_line": "if int(C[0]) < -5:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < -5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if (M - s) % mod in s1:",
      "mutated_line": "if (M - s) % mod not in s1:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod not in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for c in C[::-1]:",
      "mutated_line": "for c in C[::-2]:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-2]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for c in C[::-1]:",
      "mutated_line": "for c in C[::-0]:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-0]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for c in C[::-1]:",
      "mutated_line": "for c in C[::-0]:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-0]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for c in C[::-1]:",
      "mutated_line": "for c in C[::--1]:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::--1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "b = b * 10 % mod",
      "mutated_line": "b = b * 11 % mod",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 11 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "b = b * 10 % mod",
      "mutated_line": "b = b * 9 % mod",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 9 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "b = b * 10 % mod",
      "mutated_line": "b = b * 0 % mod",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 0 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "b = b * 10 % mod",
      "mutated_line": "b = b * 1 % mod",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 1 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "b = b * 10 % mod",
      "mutated_line": "b = b * -10 % mod",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * -10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}",
      "mutated_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) * mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) * mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}",
      "mutated_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) + mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) + mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}",
      "mutated_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) * mod: t1 for t1 in reversed(list(permutations(t_half1)))}",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) * mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}",
      "mutated_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) + mod: t1 for t1 in reversed(list(permutations(t_half1)))}",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) + mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if (M - s) % mod in s1:",
      "mutated_line": "if (M - s) * mod in s1:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) * mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if (M - s) % mod in s1:",
      "mutated_line": "if M - s + mod in s1:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if M - s + mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "t = s1[(M - s) % mod] + t2",
      "mutated_line": "t = s1[(M - s) % mod] - t2",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] - t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "t = s1[(M - s) % mod] + t2",
      "mutated_line": "t = s1[(M - s) % mod] * t2",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] * t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if t[int(C[0])] != 0:",
      "mutated_line": "if t[int(C[0])] == 0:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] == 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(L1, L2) = (L[:5], L[5:])",
      "mutated_line": "(L1, L2) = (L[:6], L[5:])",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:6], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(L1, L2) = (L[:5], L[5:])",
      "mutated_line": "(L1, L2) = (L[:4], L[5:])",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:4], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(L1, L2) = (L[:5], L[5:])",
      "mutated_line": "(L1, L2) = (L[:0], L[5:])",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:0], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(L1, L2) = (L[:5], L[5:])",
      "mutated_line": "(L1, L2) = (L[:1], L[5:])",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:1], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(L1, L2) = (L[:5], L[5:])",
      "mutated_line": "(L1, L2) = (L[:-5], L[5:])",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:-5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(L1, L2) = (L[:5], L[5:])",
      "mutated_line": "(L1, L2) = (L[:5], L[6:])",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[6:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(L1, L2) = (L[:5], L[5:])",
      "mutated_line": "(L1, L2) = (L[:5], L[4:])",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[4:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(L1, L2) = (L[:5], L[5:])",
      "mutated_line": "(L1, L2) = (L[:5], L[0:])",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[0:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(L1, L2) = (L[:5], L[5:])",
      "mutated_line": "(L1, L2) = (L[:5], L[1:])",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[1:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(L1, L2) = (L[:5], L[5:])",
      "mutated_line": "(L1, L2) = (L[:5], L[-5:])",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[-5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if int(C[0]) < 5:",
      "mutated_line": "if int(C[1]) < 5:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[1]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if int(C[0]) < 5:",
      "mutated_line": "if int(C[-1]) < 5:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[-1]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if int(C[0]) < 5:",
      "mutated_line": "if int(C[1]) < 5:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[1]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}",
      "mutated_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] == 0}",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] == 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "s = sum((l * n for (l, n) in zip(L2, t2)))",
      "mutated_line": "s = sum((l / n for (l, n) in zip(L2, t2)))",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l / n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "s = sum((l * n for (l, n) in zip(L2, t2)))",
      "mutated_line": "s = sum((l + n for (l, n) in zip(L2, t2)))",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l + n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "s = sum((l * n for (l, n) in zip(L2, t2)))",
      "mutated_line": "s = sum((l ** n for (l, n) in zip(L2, t2)))",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l ** n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if (M - s) % mod in s1:",
      "mutated_line": "if (M + s) % mod in s1:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M + s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if (M - s) % mod in s1:",
      "mutated_line": "if M * s % mod in s1:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if M * s % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if t[int(C[0])] != 0:",
      "mutated_line": "if t[int(C[0])] != 1:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 1:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if t[int(C[0])] != 0:",
      "mutated_line": "if t[int(C[0])] != -1:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != -1:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if t[int(C[0])] != 0:",
      "mutated_line": "if t[int(C[0])] != 1:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 1:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "t_half2 = list(set(range(10)) - set(t_half1))",
      "mutated_line": "t_half2 = list(set(range(11)) - set(t_half1))",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(11)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "t_half2 = list(set(range(10)) - set(t_half1))",
      "mutated_line": "t_half2 = list(set(range(9)) - set(t_half1))",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(9)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "t_half2 = list(set(range(10)) - set(t_half1))",
      "mutated_line": "t_half2 = list(set(range(0)) - set(t_half1))",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(0)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "t_half2 = list(set(range(10)) - set(t_half1))",
      "mutated_line": "t_half2 = list(set(range(1)) - set(t_half1))",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(1)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "t_half2 = list(set(range(10)) - set(t_half1))",
      "mutated_line": "t_half2 = list(set(range(-10)) - set(t_half1))",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(-10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}",
      "mutated_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 1}",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 1}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}",
      "mutated_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != -1}",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != -1}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}",
      "mutated_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 1}",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 1}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "t = s1[(M - s) % mod] + t2",
      "mutated_line": "t = s1[(M - s) * mod] + t2",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) * mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "t = s1[(M - s) % mod] + t2",
      "mutated_line": "t = s1[M - s + mod] + t2",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[M - s + mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}",
      "mutated_line": "s1 = {sum((l / n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l / n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}",
      "mutated_line": "s1 = {sum((l + n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l + n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}",
      "mutated_line": "s1 = {sum((l ** n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l ** n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}",
      "mutated_line": "s1 = {sum((l / n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l / n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}",
      "mutated_line": "s1 = {sum((l + n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l + n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}",
      "mutated_line": "s1 = {sum((l ** n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l ** n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "t = s1[(M - s) % mod] + t2",
      "mutated_line": "t = s1[(M + s) % mod] + t2",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M + s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "t = s1[(M - s) % mod] + t2",
      "mutated_line": "t = s1[M * s % mod] + t2",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[M * s % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return ''.join(map(lambda x: str(t[x]), C))",
      "mutated_line": "return 'MUTATED'.join(map(lambda x: str(t[x]), C))",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return 'MUTATED'.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if t[int(C[0])] != 0:",
      "mutated_line": "if t[int(C[1])] != 0:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[1])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if t[int(C[0])] != 0:",
      "mutated_line": "if t[int(C[-1])] != 0:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[-1])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if t[int(C[0])] != 0:",
      "mutated_line": "if t[int(C[1])] != 0:",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[1])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}",
      "mutated_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[1])] != 0}",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[1])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}",
      "mutated_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[-1])] != 0}",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[-1])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[0])] != 0}",
      "mutated_line": "s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[1])] != 0}",
      "code": "from itertools import permutations, combinations\n\ndef decrypt_canisal_cipher(M, C):\n    C = list(map(int, C))\n    if len(C) == 1 and M == 0:\n        return '0'\n    mod = 10 ** 9 + 7\n    L = [0] * 10\n    b = 1\n    for c in C[::-1]:\n        L[c] += b\n        b = b * 10 % mod\n    for t_half1 in combinations(range(10), 5):\n        (L1, L2) = (L[:5], L[5:])\n        t_half2 = list(set(range(10)) - set(t_half1))\n        if int(C[0]) < 5:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1))) if t1[int(C[1])] != 0}\n        else:\n            s1 = {sum((l * n for (l, n) in zip(L1, t1))) % mod: t1 for t1 in reversed(list(permutations(t_half1)))}\n        for t2 in permutations(t_half2):\n            s = sum((l * n for (l, n) in zip(L2, t2)))\n            if (M - s) % mod in s1:\n                t = s1[(M - s) % mod] + t2\n                if t[int(C[0])] != 0:\n                    return ''.join(map(lambda x: str(t[x]), C))\n    return '-1'"
    }
  ]
}