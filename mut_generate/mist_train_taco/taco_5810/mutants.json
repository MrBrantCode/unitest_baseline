{
  "task_id": "taco_5810",
  "entry_point": "count_valid_combinations",
  "mutant_count": 67,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[0][0][0] = 1",
      "mutated_line": "dp[0][0][0] = 2",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 2\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[0][0][0] = 1",
      "mutated_line": "dp[0][0][0] = 0",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 0\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[0][0][0] = 1",
      "mutated_line": "dp[0][0][0] = 0",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 0\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[0][0][0] = 1",
      "mutated_line": "dp[0][0][0] = -1",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = -1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[0][0][0] = 1",
      "mutated_line": "dp[0][0][1] = 1",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][1] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[0][0][0] = 1",
      "mutated_line": "dp[0][0][-1] = 1",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][-1] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[0][0][0] = 1",
      "mutated_line": "dp[0][0][1] = 1",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][1] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, 11):",
      "mutated_line": "for i in range(2, 11):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(2, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, 11):",
      "mutated_line": "for i in range(0, 11):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(0, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, 11):",
      "mutated_line": "for i in range(0, 11):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(0, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, 11):",
      "mutated_line": "for i in range(-1, 11):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(-1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, 11):",
      "mutated_line": "for i in range(1, 12):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 12):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, 11):",
      "mutated_line": "for i in range(1, 10):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 10):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, 11):",
      "mutated_line": "for i in range(1, 0):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 0):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, 11):",
      "mutated_line": "for i in range(1, 1):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 1):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(1, 11):",
      "mutated_line": "for i in range(1, -11):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, -11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[0][0][0] = 1",
      "mutated_line": "dp[0][1][0] = 1",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][1][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[0][0][0] = 1",
      "mutated_line": "dp[0][-1][0] = 1",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][-1][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[0][0][0] = 1",
      "mutated_line": "dp[0][1][0] = 1",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][1][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp = [defaultdict(Counter) for _ in range(11)]",
      "mutated_line": "dp = [defaultdict(Counter) for _ in range(12)]",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(12)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp = [defaultdict(Counter) for _ in range(11)]",
      "mutated_line": "dp = [defaultdict(Counter) for _ in range(10)]",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(10)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp = [defaultdict(Counter) for _ in range(11)]",
      "mutated_line": "dp = [defaultdict(Counter) for _ in range(0)]",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(0)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp = [defaultdict(Counter) for _ in range(11)]",
      "mutated_line": "dp = [defaultdict(Counter) for _ in range(1)]",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(1)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "dp = [defaultdict(Counter) for _ in range(11)]",
      "mutated_line": "dp = [defaultdict(Counter) for _ in range(-11)]",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(-11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[0][0][0] = 1",
      "mutated_line": "dp[1][0][0] = 1",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[1][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[0][0][0] = 1",
      "mutated_line": "dp[-1][0][0] = 1",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[-1][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "dp[0][0][0] = 1",
      "mutated_line": "dp[1][0][0] = 1",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[1][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "dp[i][used | 2 ** j][total + j * i] += count",
      "mutated_line": "dp[i][used | 2 ** j][total + j * i] -= count",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] -= count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))",
      "mutated_line": "return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k != s))",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k != s))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for (used, counter) in dp[i - 1].items():",
      "mutated_line": "for (used, counter) in dp[i + 1].items():",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i + 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for (used, counter) in dp[i - 1].items():",
      "mutated_line": "for (used, counter) in dp[i * 1].items():",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i * 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "for j in filter(lambda x: used & 2 ** x == 0, range(10)):",
      "mutated_line": "for j in filter(lambda x: used & 2 ** x != 0, range(10)):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x != 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in filter(lambda x: used & 2 ** x == 0, range(10)):",
      "mutated_line": "for j in filter(lambda x: used & 2 ** x == 0, range(11)):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(11)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in filter(lambda x: used & 2 ** x == 0, range(10)):",
      "mutated_line": "for j in filter(lambda x: used & 2 ** x == 0, range(9)):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(9)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in filter(lambda x: used & 2 ** x == 0, range(10)):",
      "mutated_line": "for j in filter(lambda x: used & 2 ** x == 0, range(0)):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(0)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in filter(lambda x: used & 2 ** x == 0, range(10)):",
      "mutated_line": "for j in filter(lambda x: used & 2 ** x == 0, range(1)):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(1)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in filter(lambda x: used & 2 ** x == 0, range(10)):",
      "mutated_line": "for j in filter(lambda x: used & 2 ** x == 0, range(-10)):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(-10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (used, counter) in dp[i - 1].items():",
      "mutated_line": "for (used, counter) in dp[i - 2].items():",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 2].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (used, counter) in dp[i - 1].items():",
      "mutated_line": "for (used, counter) in dp[i - 0].items():",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 0].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (used, counter) in dp[i - 1].items():",
      "mutated_line": "for (used, counter) in dp[i - 0].items():",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 0].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for (used, counter) in dp[i - 1].items():",
      "mutated_line": "for (used, counter) in dp[i - -1].items():",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - -1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for j in filter(lambda x: used & 2 ** x == 0, range(10)):",
      "mutated_line": "for j in filter(lambda x: used | 2 ** x == 0, range(10)):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used | 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in filter(lambda x: used & 2 ** x == 0, range(10)):",
      "mutated_line": "for j in filter(lambda x: used & 2 ** x == 1, range(10)):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 1, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in filter(lambda x: used & 2 ** x == 0, range(10)):",
      "mutated_line": "for j in filter(lambda x: used & 2 ** x == -1, range(10)):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == -1, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in filter(lambda x: used & 2 ** x == 0, range(10)):",
      "mutated_line": "for j in filter(lambda x: used & 2 ** x == 1, range(10)):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 1, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[i][used | 2 ** j][total + j * i] += count",
      "mutated_line": "dp[i][used | 2 ** j][total - j * i] += count",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total - j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[i][used | 2 ** j][total + j * i] += count",
      "mutated_line": "dp[i][used | 2 ** j][total * (j * i)] += count",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total * (j * i)] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for j in filter(lambda x: used & 2 ** x == 0, range(10)):",
      "mutated_line": "for j in filter(lambda x: used & 2 * x == 0, range(10)):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 * x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for j in filter(lambda x: used & 2 ** x == 0, range(10)):",
      "mutated_line": "for j in filter(lambda x: used & 2 + x == 0, range(10)):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 + x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[i][used | 2 ** j][total + j * i] += count",
      "mutated_line": "dp[i][used & 2 ** j][total + j * i] += count",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used & 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[i][used | 2 ** j][total + j * i] += count",
      "mutated_line": "dp[i][used ^ 2 ** j][total + j * i] += count",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used ^ 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[i][used | 2 ** j][total + j * i] += count",
      "mutated_line": "dp[i][used | 2 ** j][total + j / i] += count",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j / i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[i][used | 2 ** j][total + j * i] += count",
      "mutated_line": "dp[i][used | 2 ** j][total + (j + i)] += count",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + (j + i)] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[i][used | 2 ** j][total + j * i] += count",
      "mutated_line": "dp[i][used | 2 ** j][total + j ** i] += count",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j ** i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in filter(lambda x: used & 2 ** x == 0, range(10)):",
      "mutated_line": "for j in filter(lambda x: used & 3 ** x == 0, range(10)):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 3 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in filter(lambda x: used & 2 ** x == 0, range(10)):",
      "mutated_line": "for j in filter(lambda x: used & 1 ** x == 0, range(10)):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 1 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in filter(lambda x: used & 2 ** x == 0, range(10)):",
      "mutated_line": "for j in filter(lambda x: used & 0 ** x == 0, range(10)):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 0 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in filter(lambda x: used & 2 ** x == 0, range(10)):",
      "mutated_line": "for j in filter(lambda x: used & 1 ** x == 0, range(10)):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 1 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in filter(lambda x: used & 2 ** x == 0, range(10)):",
      "mutated_line": "for j in filter(lambda x: used & -2 ** x == 0, range(10)):",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & -2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[i][used | 2 ** j][total + j * i] += count",
      "mutated_line": "dp[i][used | 2 * j][total + j * i] += count",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 * j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "dp[i][used | 2 ** j][total + j * i] += count",
      "mutated_line": "dp[i][used | 2 + j][total + j * i] += count",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 2 + j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[i][used | 2 ** j][total + j * i] += count",
      "mutated_line": "dp[i][used | 3 ** j][total + j * i] += count",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 3 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[i][used | 2 ** j][total + j * i] += count",
      "mutated_line": "dp[i][used | 1 ** j][total + j * i] += count",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 1 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[i][used | 2 ** j][total + j * i] += count",
      "mutated_line": "dp[i][used | 0 ** j][total + j * i] += count",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 0 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[i][used | 2 ** j][total + j * i] += count",
      "mutated_line": "dp[i][used | 1 ** j][total + j * i] += count",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | 1 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "dp[i][used | 2 ** j][total + j * i] += count",
      "mutated_line": "dp[i][used | -2 ** j][total + j * i] += count",
      "code": "def count_valid_combinations(n: int, s: int) -> int:\n    \"\"\"\n    Counts the number of valid combinations of n numbers (each from 0 to 9) such that:\n    k1 + 2 * k2 + 3 * k3 + ... + n * kn = s\n    and no number appears more than once in the sequence.\n\n    Parameters:\n    n (int): The number of integers in the sequence.\n    s (int): The target sum.\n\n    Returns:\n    int: The number of valid combinations.\n    \"\"\"\n    from collections import defaultdict, Counter\n    dp = [defaultdict(Counter) for _ in range(11)]\n    dp[0][0][0] = 1\n    for i in range(1, 11):\n        for (used, counter) in dp[i - 1].items():\n            for j in filter(lambda x: used & 2 ** x == 0, range(10)):\n                for (total, count) in counter.items():\n                    dp[i][used | -2 ** j][total + j * i] += count\n    return sum((v for counter in dp[n].values() for (k, v) in counter.items() if k == s))"
    }
  ]
}