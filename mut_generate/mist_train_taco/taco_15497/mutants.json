{
  "task_id": "taco_15497",
  "entry_point": "two_stacks_operations",
  "mutant_count": 45,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if op[0] == 'push1':",
      "mutated_line": "if op[0] != 'push1':",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] != 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if op[0] == 'push1':",
      "mutated_line": "if op[0] == '':",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == '':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "elif op[0] == 'push2':",
      "mutated_line": "elif op[0] != 'push2':",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] != 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if op[0] == 'push1':",
      "mutated_line": "if op[1] == 'push1':",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[1] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if op[0] == 'push1':",
      "mutated_line": "if op[-1] == 'push1':",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[-1] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if op[0] == 'push1':",
      "mutated_line": "if op[1] == 'push1':",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[1] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "arr.insert(0, op[1])",
      "mutated_line": "arr.insert(1, op[1])",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(1, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "arr.insert(0, op[1])",
      "mutated_line": "arr.insert(-1, op[1])",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(-1, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "arr.insert(0, op[1])",
      "mutated_line": "arr.insert(1, op[1])",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(1, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif op[0] == 'push2':",
      "mutated_line": "elif op[0] == '':",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == '':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "elif op[0] == 'pop1':",
      "mutated_line": "elif op[0] != 'pop1':",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] != 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "arr.insert(0, op[1])",
      "mutated_line": "arr.insert(0, op[2])",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[2])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "arr.insert(0, op[1])",
      "mutated_line": "arr.insert(0, op[0])",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[0])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "arr.insert(0, op[1])",
      "mutated_line": "arr.insert(0, op[0])",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[0])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "arr.insert(0, op[1])",
      "mutated_line": "arr.insert(0, op[-1])",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[-1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif op[0] == 'push2':",
      "mutated_line": "elif op[1] == 'push2':",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[1] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif op[0] == 'push2':",
      "mutated_line": "elif op[-1] == 'push2':",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[-1] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "elif op[0] == 'push2':",
      "mutated_line": "elif op[1] == 'push2':",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[1] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif op[0] == 'pop1':",
      "mutated_line": "elif op[0] == '':",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == '':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "elif op[0] == 'pop2':",
      "mutated_line": "elif op[0] != 'pop2':",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] != 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "arr.append(op[1])",
      "mutated_line": "arr.append(op[2])",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[2])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "arr.append(op[1])",
      "mutated_line": "arr.append(op[0])",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[0])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "arr.append(op[1])",
      "mutated_line": "arr.append(op[0])",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[0])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "arr.append(op[1])",
      "mutated_line": "arr.append(op[-1])",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[-1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif op[0] == 'pop1':",
      "mutated_line": "elif op[1] == 'pop1':",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[1] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif op[0] == 'pop1':",
      "mutated_line": "elif op[-1] == 'pop1':",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[-1] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "elif op[0] == 'pop1':",
      "mutated_line": "elif op[1] == 'pop1':",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[1] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif op[0] == 'pop2':",
      "mutated_line": "elif op[0] == '':",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == '':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(+1)",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(+1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif op[0] == 'pop2':",
      "mutated_line": "elif op[1] == 'pop2':",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[1] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif op[0] == 'pop2':",
      "mutated_line": "elif op[-1] == 'pop2':",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[-1] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif op[0] == 'pop2':",
      "mutated_line": "elif op[1] == 'pop2':",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[1] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "results.append(arr.pop(0))",
      "mutated_line": "results.append(arr.pop(1))",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(1))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "results.append(arr.pop(0))",
      "mutated_line": "results.append(arr.pop(-1))",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(-1))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "results.append(arr.pop(0))",
      "mutated_line": "results.append(arr.pop(1))",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(1))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-2)",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-2)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-0)",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-0)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-0)",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-0)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(--1)",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(--1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-1)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(+1)",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(+1)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-2)",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-2)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-0)",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(-0)",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(-0)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "results.append(-1)",
      "mutated_line": "results.append(--1)",
      "code": "def two_stacks_operations(arr, operations):\n    \"\"\"\n    Perform a series of operations on two stacks implemented in a single array.\n\n    Parameters:\n    - arr (list): The array to be used for implementing the two stacks.\n    - operations (list of tuples): Each tuple represents an operation. The first element of the tuple is the operation type ('push1', 'push2', 'pop1', 'pop2') and the second element is the value to be pushed (only for 'push1' and 'push2').\n\n    Returns:\n    - list: A list of results corresponding to the operations performed. For 'push1' and 'push2', the result is None. For 'pop1' and 'pop2', the result is the popped value or -1 if the stack is empty.\n    \"\"\"\n    results = []\n    for op in operations:\n        if op[0] == 'push1':\n            arr.insert(0, op[1])\n            results.append(None)\n        elif op[0] == 'push2':\n            arr.append(op[1])\n            results.append(None)\n        elif op[0] == 'pop1':\n            if arr:\n                results.append(arr.pop(0))\n            else:\n                results.append(-1)\n        elif op[0] == 'pop2':\n            if arr:\n                results.append(arr.pop())\n            else:\n                results.append(--1)\n    return results"
    }
  ]
}