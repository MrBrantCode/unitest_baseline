{
  "task_id": "taco_2341",
  "entry_point": "find_shortest_cycle_length",
  "mutant_count": 105,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "N = 64",
      "mutated_line": "N = 65",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 65\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "N = 64",
      "mutated_line": "N = 63",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 63\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "N = 64",
      "mutated_line": "N = 0",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 0\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "N = 64",
      "mutated_line": "N = 1",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 1\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "N = 64",
      "mutated_line": "N = -64",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = -64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = 100000",
      "mutated_line": "INF = 100001",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100001\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = 100000",
      "mutated_line": "INF = 99999",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 99999\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = 100000",
      "mutated_line": "INF = 0",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 0\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = 100000",
      "mutated_line": "INF = 1",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 1\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "INF = 100000",
      "mutated_line": "INF = -100000",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = -100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "t = [0] * N",
      "mutated_line": "t = [0] / N",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] / N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "t = [0] * N",
      "mutated_line": "t = [0] + N",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] + N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "t = [0] * N",
      "mutated_line": "t = [0] ** N",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] ** N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "t[j] += v >> j & 1",
      "mutated_line": "t[j] -= v >> j & 1",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] -= v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if len(g[i]) == 2:",
      "mutated_line": "if len(g[i]) != 2:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) != 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dist = [INF] * n",
      "mutated_line": "dist = [INF] / n",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] / n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dist = [INF] * n",
      "mutated_line": "dist = [INF] + n",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] + n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "dist = [INF] * n",
      "mutated_line": "dist = [INF] ** n",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] ** n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = 1",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 1\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = -1",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = -1\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = 1",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 1\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "return -1 if ans == INF else ans",
      "mutated_line": "return -1 if ans != INF else ans",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans != INF else ans"
    },
    {
      "operator": "UOI",
      "lineno": 52,
      "original_line": "return -1 if ans == INF else ans",
      "mutated_line": "return +1 if ans == INF else ans",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return +1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "t = [0] * N",
      "mutated_line": "t = [1] * N",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [1] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "t = [0] * N",
      "mutated_line": "t = [-1] * N",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [-1] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "t = [0] * N",
      "mutated_line": "t = [1] * N",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [1] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "t[j] += v >> j & 1",
      "mutated_line": "t[j] += v >> j | 1",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j | 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if t[j] >= 3:",
      "mutated_line": "if t[j] > 3:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] > 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if t[j] >= 3:",
      "mutated_line": "if t[j] < 3:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] < 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if t[j] >= 3:",
      "mutated_line": "if t[j] == 3:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] == 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if v >> j & 1 == 1:",
      "mutated_line": "if v >> j & 1 != 1:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 != 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if len(g[i]) == 2:",
      "mutated_line": "if len(g[i]) == 3:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 3:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if len(g[i]) == 2:",
      "mutated_line": "if len(g[i]) == 1:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 1:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if len(g[i]) == 2:",
      "mutated_line": "if len(g[i]) == 0:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 0:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if len(g[i]) == 2:",
      "mutated_line": "if len(g[i]) == 1:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 1:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if len(g[i]) == 2:",
      "mutated_line": "if len(g[i]) == -2:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == -2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return -1 if ans == INF else ans",
      "mutated_line": "return -2 if ans == INF else ans",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -2 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return -1 if ans == INF else ans",
      "mutated_line": "return -0 if ans == INF else ans",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -0 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return -1 if ans == INF else ans",
      "mutated_line": "return -0 if ans == INF else ans",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -0 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return -1 if ans == INF else ans",
      "mutated_line": "return --1 if ans == INF else ans",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return --1 if ans == INF else ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "a = list(filter(lambda x: x > 0, a))",
      "mutated_line": "a = list(filter(lambda x: x >= 0, a))",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x >= 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "a = list(filter(lambda x: x > 0, a))",
      "mutated_line": "a = list(filter(lambda x: x <= 0, a))",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x <= 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "a = list(filter(lambda x: x > 0, a))",
      "mutated_line": "a = list(filter(lambda x: x != 0, a))",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x != 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "t[j] += v >> j & 1",
      "mutated_line": "t[j] += v >> j & 2",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 2\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "t[j] += v >> j & 1",
      "mutated_line": "t[j] += v >> j & 0",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 0\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "t[j] += v >> j & 1",
      "mutated_line": "t[j] += v >> j & 0",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 0\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "t[j] += v >> j & 1",
      "mutated_line": "t[j] += v >> j & -1",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & -1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if t[j] >= 3:",
      "mutated_line": "if t[j] >= 4:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 4:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if t[j] >= 3:",
      "mutated_line": "if t[j] >= 2:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 2:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if t[j] >= 3:",
      "mutated_line": "if t[j] >= 0:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 0:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if t[j] >= 3:",
      "mutated_line": "if t[j] >= 1:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 1:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if t[j] >= 3:",
      "mutated_line": "if t[j] >= -3:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= -3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 3",
      "mutated_line": "return 4",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 4\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 3",
      "mutated_line": "return 2",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 2\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 3",
      "mutated_line": "return 0",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 0\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 3",
      "mutated_line": "return 1",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 1\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 3",
      "mutated_line": "return -3",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return -3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if v >> j & 1 == 1:",
      "mutated_line": "if v >> j | 1 == 1:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j | 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if v >> j & 1 == 1:",
      "mutated_line": "if v >> j & 1 == 2:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 2:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if v >> j & 1 == 1:",
      "mutated_line": "if v >> j & 1 == 0:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 0:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if v >> j & 1 == 1:",
      "mutated_line": "if v >> j & 1 == 0:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 0:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if v >> j & 1 == 1:",
      "mutated_line": "if v >> j & 1 == -1:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == -1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if dist[v] == INF:",
      "mutated_line": "if dist[v] != INF:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] != INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "a = list(filter(lambda x: x > 0, a))",
      "mutated_line": "a = list(filter(lambda x: x > 1, a))",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 1, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "a = list(filter(lambda x: x > 0, a))",
      "mutated_line": "a = list(filter(lambda x: x > -1, a))",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > -1, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "a = list(filter(lambda x: x > 0, a))",
      "mutated_line": "a = list(filter(lambda x: x > 1, a))",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 1, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if v >> j & 1 == 1:",
      "mutated_line": "if v >> j & 2 == 1:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 2 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if v >> j & 1 == 1:",
      "mutated_line": "if v >> j & 0 == 1:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 0 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if v >> j & 1 == 1:",
      "mutated_line": "if v >> j & 0 == 1:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 0 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if v >> j & 1 == 1:",
      "mutated_line": "if v >> j & -1 == 1:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & -1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "adj[g[i][0]].add(g[i][1])",
      "mutated_line": "adj[g[i][0]].add(g[i][2])",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][2])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "adj[g[i][0]].add(g[i][1])",
      "mutated_line": "adj[g[i][0]].add(g[i][0])",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][0])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "adj[g[i][0]].add(g[i][1])",
      "mutated_line": "adj[g[i][0]].add(g[i][0])",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][0])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "adj[g[i][0]].add(g[i][1])",
      "mutated_line": "adj[g[i][0]].add(g[i][-1])",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][-1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "adj[g[i][1]].add(g[i][0])",
      "mutated_line": "adj[g[i][1]].add(g[i][1])",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][1])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "adj[g[i][1]].add(g[i][0])",
      "mutated_line": "adj[g[i][1]].add(g[i][-1])",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][-1])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "adj[g[i][1]].add(g[i][0])",
      "mutated_line": "adj[g[i][1]].add(g[i][1])",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][1])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "dist[v] = dist[u] + 1",
      "mutated_line": "dist[v] = dist[u] - 1",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] - 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "dist[v] = dist[u] + 1",
      "mutated_line": "dist[v] = dist[u] * 1",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] * 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "elif dist[v] + 1 != dist[u]:",
      "mutated_line": "elif dist[v] + 1 == dist[u]:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 == dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "dist[v] = dist[u] + 1",
      "mutated_line": "dist[v] = dist[u] + 2",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 2\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "dist[v] = dist[u] + 1",
      "mutated_line": "dist[v] = dist[u] + 0",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 0\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "dist[v] = dist[u] + 1",
      "mutated_line": "dist[v] = dist[u] + 0",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 0\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "dist[v] = dist[u] + 1",
      "mutated_line": "dist[v] = dist[u] + -1",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + -1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "elif dist[v] + 1 != dist[u]:",
      "mutated_line": "elif dist[v] - 1 != dist[u]:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] - 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "elif dist[v] + 1 != dist[u]:",
      "mutated_line": "elif dist[v] * 1 != dist[u]:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] * 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "return dist[v] + dist[u] + 1",
      "mutated_line": "return dist[v] + dist[u] - 1",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] - 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "return dist[v] + dist[u] + 1",
      "mutated_line": "return (dist[v] + dist[u]) * 1",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return (dist[v] + dist[u]) * 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "adj[g[i][0]].add(g[i][1])",
      "mutated_line": "adj[g[i][1]].add(g[i][1])",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][1]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "adj[g[i][0]].add(g[i][1])",
      "mutated_line": "adj[g[i][-1]].add(g[i][1])",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][-1]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "adj[g[i][0]].add(g[i][1])",
      "mutated_line": "adj[g[i][1]].add(g[i][1])",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][1]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "adj[g[i][1]].add(g[i][0])",
      "mutated_line": "adj[g[i][2]].add(g[i][0])",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][2]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "adj[g[i][1]].add(g[i][0])",
      "mutated_line": "adj[g[i][0]].add(g[i][0])",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][0]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "adj[g[i][1]].add(g[i][0])",
      "mutated_line": "adj[g[i][0]].add(g[i][0])",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][0]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "adj[g[i][1]].add(g[i][0])",
      "mutated_line": "adj[g[i][-1]].add(g[i][0])",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][-1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "elif dist[v] + 1 != dist[u]:",
      "mutated_line": "elif dist[v] + 2 != dist[u]:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 2 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "elif dist[v] + 1 != dist[u]:",
      "mutated_line": "elif dist[v] + 0 != dist[u]:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 0 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "elif dist[v] + 1 != dist[u]:",
      "mutated_line": "elif dist[v] + 0 != dist[u]:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 0 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "elif dist[v] + 1 != dist[u]:",
      "mutated_line": "elif dist[v] + -1 != dist[u]:",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + -1 != dist[u]:\n                    return dist[v] + dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "return dist[v] + dist[u] + 1",
      "mutated_line": "return dist[v] - dist[u] + 1",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] - dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "return dist[v] + dist[u] + 1",
      "mutated_line": "return dist[v] * dist[u] + 1",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] * dist[u] + 1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return dist[v] + dist[u] + 1",
      "mutated_line": "return dist[v] + dist[u] + 2",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 2\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return dist[v] + dist[u] + 1",
      "mutated_line": "return dist[v] + dist[u] + 0",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 0\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return dist[v] + dist[u] + 1",
      "mutated_line": "return dist[v] + dist[u] + 0",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + 0\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return dist[v] + dist[u] + 1",
      "mutated_line": "return dist[v] + dist[u] + -1",
      "code": "from collections import deque\n\ndef find_shortest_cycle_length(n, a):\n    N = 64\n    INF = 100000\n    a = list(filter(lambda x: x > 0, a))\n    n = len(a)\n    adj = [set() for _ in range(n)]\n    t = [0] * N\n    g = [[] for _ in range(N)]\n    for j in range(N):\n        for i in range(n):\n            v = a[i]\n            t[j] += v >> j & 1\n            if t[j] >= 3:\n                return 3\n            if v >> j & 1 == 1:\n                g[j].append(i)\n    for i in range(N):\n        if len(g[i]) == 2:\n            adj[g[i][0]].add(g[i][1])\n            adj[g[i][1]].add(g[i][0])\n\n    def bfs(start):\n        dist = [INF] * n\n        q = deque([start])\n        dist[start] = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] == INF:\n                    q.append(v)\n                    dist[v] = dist[u] + 1\n                elif dist[v] + 1 != dist[u]:\n                    return dist[v] + dist[u] + -1\n        return INF\n    ans = INF\n    for i in range(n):\n        ans = min(ans, bfs(i))\n    return -1 if ans == INF else ans"
    }
  ]
}