{
  "task_id": "taco_5923",
  "entry_point": "calculate_minimum_pipe_cost",
  "mutant_count": 41,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 * 20",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 * 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 + 20",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 + 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 11 ** 20",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 11 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 9 ** 20",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 9 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 0 ** 20",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 0 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 1 ** 20",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 1 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = -10 ** 20",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = -10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 ** 21",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 21\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 ** 19",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 19\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 ** 0",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 0\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 ** 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 1\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "inf = 10 ** 20",
      "mutated_line": "inf = 10 ** -20",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** -20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 1\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = -1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = -1\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dist[start] = 0",
      "mutated_line": "dist[start] = 1",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 1\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(2, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(0, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(0, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(-1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n - 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n * 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]",
      "mutated_line": "total_cost = source_dist[i] + base_dist[g1] - base_dist[g2]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] - base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]",
      "mutated_line": "total_cost = (source_dist[i] + base_dist[g1]) * base_dist[g2]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = (source_dist[i] + base_dist[g1]) * base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if min_cost > total_cost:",
      "mutated_line": "if min_cost >= total_cost:",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost >= total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if min_cost > total_cost:",
      "mutated_line": "if min_cost <= total_cost:",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost <= total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if min_cost > total_cost:",
      "mutated_line": "if min_cost != total_cost:",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost != total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "visited[u] = True",
      "mutated_line": "visited[u] = False",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = False\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 2):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 0):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 0):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + -1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]",
      "mutated_line": "total_cost = source_dist[i] - base_dist[g1] + base_dist[g2]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] - base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]",
      "mutated_line": "total_cost = source_dist[i] * base_dist[g1] + base_dist[g2]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] * base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "pq = [(0, start)]",
      "mutated_line": "pq = [(1, start)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(1, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "pq = [(0, start)]",
      "mutated_line": "pq = [(-1, start)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(-1, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "pq = [(0, start)]",
      "mutated_line": "pq = [(1, start)]",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(1, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "new_cost = cost + weight",
      "mutated_line": "new_cost = cost - weight",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost - weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "new_cost = cost + weight",
      "mutated_line": "new_cost = cost * weight",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost * weight\n                if dist[v] > new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if dist[v] > new_cost:",
      "mutated_line": "if dist[v] >= new_cost:",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] >= new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if dist[v] > new_cost:",
      "mutated_line": "if dist[v] <= new_cost:",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] <= new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if dist[v] > new_cost:",
      "mutated_line": "if dist[v] != new_cost:",
      "code": "import heapq\nfrom collections import defaultdict\n\ndef calculate_minimum_pipe_cost(n, m, s, g1, g2, roads):\n    inf = 10 ** 20\n    e = defaultdict(list)\n    for (a, b, c) in roads:\n        e[a].append((b, c))\n\n    def dijkstra(start):\n        dist = defaultdict(lambda : inf)\n        dist[start] = 0\n        pq = [(0, start)]\n        visited = defaultdict(bool)\n        while pq:\n            (cost, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for (v, weight) in e[u]:\n                if visited[v]:\n                    continue\n                new_cost = cost + weight\n                if dist[v] != new_cost:\n                    dist[v] = new_cost\n                    heapq.heappush(pq, (new_cost, v))\n        return dist\n    source_dist = dijkstra(s)\n    min_cost = inf\n    for i in range(1, n + 1):\n        base_dist = dijkstra(i)\n        total_cost = source_dist[i] + base_dist[g1] + base_dist[g2]\n        if min_cost > total_cost:\n            min_cost = total_cost\n    return min_cost"
    }
  ]
}