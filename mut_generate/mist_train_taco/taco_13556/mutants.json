{
  "task_id": "taco_13556",
  "entry_point": "min_convenience_points_to_free_memory",
  "mutant_count": 45,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if sum(a) < m:",
      "mutated_line": "if sum(a) <= m:",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) <= m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if sum(a) < m:",
      "mutated_line": "if sum(a) >= m:",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) >= m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if sum(a) < m:",
      "mutated_line": "if sum(a) != m:",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) != m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "p1 = [0] + list(accumulate(sorted(b1, reverse=True)))",
      "mutated_line": "p1 = [0] - list(accumulate(sorted(b1, reverse=True)))",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] - list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "p1 = [0] + list(accumulate(sorted(b1, reverse=True)))",
      "mutated_line": "p1 = [0] * list(accumulate(sorted(b1, reverse=True)))",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] * list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "p2 = [0] + list(accumulate(sorted(b2, reverse=True)))",
      "mutated_line": "p2 = [0] - list(accumulate(sorted(b2, reverse=True)))",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] - list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "p2 = [0] + list(accumulate(sorted(b2, reverse=True)))",
      "mutated_line": "p2 = [0] * list(accumulate(sorted(b2, reverse=True)))",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] * list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return +1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if b[i] == 1:",
      "mutated_line": "if b[i] != 1:",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] != 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "answer = float('inf')",
      "mutated_line": "answer = float('')",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if k < len(p2):",
      "mutated_line": "if k <= len(p2):",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k <= len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if k < len(p2):",
      "mutated_line": "if k >= len(p2):",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k >= len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if k < len(p2):",
      "mutated_line": "if k != len(p2):",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k != len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if p1[j] >= m:",
      "mutated_line": "if p1[j] > m:",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] > m:\n            return answer\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if p1[j] >= m:",
      "mutated_line": "if p1[j] < m:",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] < m:\n            return answer\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if p1[j] >= m:",
      "mutated_line": "if p1[j] == m:",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] == m:\n            return answer\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -2\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -0\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -0\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return --1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if b[i] == 1:",
      "mutated_line": "if b[i] == 2:",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 2:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if b[i] == 1:",
      "mutated_line": "if b[i] == 0:",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 0:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if b[i] == 1:",
      "mutated_line": "if b[i] == 0:",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 0:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if b[i] == 1:",
      "mutated_line": "if b[i] == -1:",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == -1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "p1 = [0] + list(accumulate(sorted(b1, reverse=True)))",
      "mutated_line": "p1 = [1] + list(accumulate(sorted(b1, reverse=True)))",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [1] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "p1 = [0] + list(accumulate(sorted(b1, reverse=True)))",
      "mutated_line": "p1 = [-1] + list(accumulate(sorted(b1, reverse=True)))",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [-1] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "p1 = [0] + list(accumulate(sorted(b1, reverse=True)))",
      "mutated_line": "p1 = [1] + list(accumulate(sorted(b1, reverse=True)))",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [1] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "p2 = [0] + list(accumulate(sorted(b2, reverse=True)))",
      "mutated_line": "p2 = [1] + list(accumulate(sorted(b2, reverse=True)))",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [1] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "p2 = [0] + list(accumulate(sorted(b2, reverse=True)))",
      "mutated_line": "p2 = [-1] + list(accumulate(sorted(b2, reverse=True)))",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [-1] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "p2 = [0] + list(accumulate(sorted(b2, reverse=True)))",
      "mutated_line": "p2 = [1] + list(accumulate(sorted(b2, reverse=True)))",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [1] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "k = bisect_left(p2, m - p1[j])",
      "mutated_line": "k = bisect_left(p2, m + p1[j])",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m + p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "k = bisect_left(p2, m - p1[j])",
      "mutated_line": "k = bisect_left(p2, m * p1[j])",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m * p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "answer = min(j + 2 * k, answer)",
      "mutated_line": "answer = min(j - 2 * k, answer)",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j - 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "answer = min(j + 2 * k, answer)",
      "mutated_line": "answer = min(j * (2 * k), answer)",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j * (2 * k), answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "answer = min(j + 2 * k, answer)",
      "mutated_line": "answer = min(j + 2 / k, answer)",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 / k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "answer = min(j + 2 * k, answer)",
      "mutated_line": "answer = min(j + (2 + k), answer)",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + (2 + k), answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "answer = min(j + 2 * k, answer)",
      "mutated_line": "answer = min(j + 2 ** k, answer)",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 ** k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "p1 = [0] + list(accumulate(sorted(b1, reverse=True)))",
      "mutated_line": "p1 = [0] + list(accumulate(sorted(b1, reverse=False)))",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=False)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "p2 = [0] + list(accumulate(sorted(b2, reverse=True)))",
      "mutated_line": "p2 = [0] + list(accumulate(sorted(b2, reverse=False)))",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=False)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "answer = min(j + 2 * k, answer)",
      "mutated_line": "answer = min(j + 3 * k, answer)",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 3 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "answer = min(j + 2 * k, answer)",
      "mutated_line": "answer = min(j + 1 * k, answer)",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 1 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "answer = min(j + 2 * k, answer)",
      "mutated_line": "answer = min(j + 0 * k, answer)",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 0 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "answer = min(j + 2 * k, answer)",
      "mutated_line": "answer = min(j + 1 * k, answer)",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + 1 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "answer = min(j + 2 * k, answer)",
      "mutated_line": "answer = min(j + -2 * k, answer)",
      "code": "def min_convenience_points_to_free_memory(n, m, a, b):\n    \"\"\"\n    Calculate the minimum number of convenience points Polycarp will lose to free at least `m` units of memory.\n\n    Parameters:\n    - n (int): The number of applications.\n    - m (int): The number of memory units to be freed.\n    - a (list[int]): A list of integers representing the memory units used by each application.\n    - b (list[int]): A list of integers representing the convenience points of each application.\n\n    Returns:\n    - int: The minimum number of convenience points lost or -1 if it's not possible to free the required memory.\n    \"\"\"\n    if sum(a) < m:\n        return -1\n    b1 = []\n    b2 = []\n    for i in range(n):\n        if b[i] == 1:\n            b1.append(a[i])\n        else:\n            b2.append(a[i])\n    p1 = [0] + list(accumulate(sorted(b1, reverse=True)))\n    p2 = [0] + list(accumulate(sorted(b2, reverse=True)))\n    answer = float('inf')\n    for j in range(len(p1)):\n        k = bisect_left(p2, m - p1[j])\n        if k < len(p2):\n            answer = min(j + -2 * k, answer)\n        if p1[j] >= m:\n            return answer\n    return answer"
    }
  ]
}