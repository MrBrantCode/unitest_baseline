{
  "task_id": "taco_3464",
  "entry_point": "is_grid_achievable",
  "mutant_count": 283,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "cnt += merge_and_count_rec(A, W, m, r)",
      "mutated_line": "cnt -= merge_and_count_rec(A, W, m, r)",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt -= merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ok = True",
      "mutated_line": "ok = False",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = False\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "ok &= hb % 2 == flip[1] % 2",
      "mutated_line": "ok &= hb % 2 != flip[1] % 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 != flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "ok &= hc % 2 == flip[0] % 2",
      "mutated_line": "ok &= hc % 2 != flip[0] % 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 != flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if l + 1 >= r:",
      "mutated_line": "if l + 1 > r:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 > r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if l + 1 >= r:",
      "mutated_line": "if l + 1 < r:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 < r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if l + 1 >= r:",
      "mutated_line": "if l + 1 == r:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 == r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) / 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) / 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) * 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) * 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "while i < m and j < r:",
      "mutated_line": "while i < m or j < r:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m or j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "k += 1",
      "mutated_line": "k -= 1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k -= 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if i < m:",
      "mutated_line": "if i <= m:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i <= m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if i < m:",
      "mutated_line": "if i >= m:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i >= m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if i < m:",
      "mutated_line": "if i != m:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i != m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if j < r:",
      "mutated_line": "if j <= r:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j <= r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if j < r:",
      "mutated_line": "if j >= r:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j >= r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if j < r:",
      "mutated_line": "if j != r:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j != r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "flip = [0, 0]",
      "mutated_line": "flip = [1, 0]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [1, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "flip = [0, 0]",
      "mutated_line": "flip = [-1, 0]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [-1, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "flip = [0, 0]",
      "mutated_line": "flip = [1, 0]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [1, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "flip = [0, 0]",
      "mutated_line": "flip = [0, 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 1]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "flip = [0, 0]",
      "mutated_line": "flip = [0, -1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, -1]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "flip = [0, 0]",
      "mutated_line": "flip = [0, 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 1]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "ok &= a[1][i] % 3 == 2",
      "mutated_line": "ok &= a[1][i] % 3 != 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 != 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) != [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) != [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "ok &= dist % 2 == 0",
      "mutated_line": "ok &= dist % 2 != 0",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 != 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[2][i]] != [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] != [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if (dist // 2 % 2 == 0) != order:",
      "mutated_line": "if (dist // 2 % 2 == 0) == order:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) == order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "flip[i % 2] += 1",
      "mutated_line": "flip[i % 2] -= 1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] -= 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "hb = merge_and_count_rec(B, a[0], 0, len(B))",
      "mutated_line": "hb = merge_and_count_rec(B, a[0], 1, len(B))",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 1, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "hb = merge_and_count_rec(B, a[0], 0, len(B))",
      "mutated_line": "hb = merge_and_count_rec(B, a[0], -1, len(B))",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], -1, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "hb = merge_and_count_rec(B, a[0], 0, len(B))",
      "mutated_line": "hb = merge_and_count_rec(B, a[0], 1, len(B))",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 1, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "hc = merge_and_count_rec(C, a[0], 0, len(C))",
      "mutated_line": "hc = merge_and_count_rec(C, a[0], 1, len(C))",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 1, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "hc = merge_and_count_rec(C, a[0], 0, len(C))",
      "mutated_line": "hc = merge_and_count_rec(C, a[0], -1, len(C))",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], -1, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "hc = merge_and_count_rec(C, a[0], 0, len(C))",
      "mutated_line": "hc = merge_and_count_rec(C, a[0], 1, len(C))",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 1, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ok &= hb % 2 == flip[1] % 2",
      "mutated_line": "ok &= hb * 2 == flip[1] % 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb * 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ok &= hb % 2 == flip[1] % 2",
      "mutated_line": "ok &= hb + 2 == flip[1] % 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb + 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ok &= hb % 2 == flip[1] % 2",
      "mutated_line": "ok &= hb % 2 == flip[1] * 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] * 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "ok &= hb % 2 == flip[1] % 2",
      "mutated_line": "ok &= hb % 2 == flip[1] + 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] + 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ok &= hc % 2 == flip[0] % 2",
      "mutated_line": "ok &= hc * 2 == flip[0] % 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc * 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ok &= hc % 2 == flip[0] % 2",
      "mutated_line": "ok &= hc + 2 == flip[0] % 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc + 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ok &= hc % 2 == flip[0] % 2",
      "mutated_line": "ok &= hc % 2 == flip[0] * 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] * 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ok &= hc % 2 == flip[0] % 2",
      "mutated_line": "ok &= hc % 2 == flip[0] + 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] + 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "if l + 1 >= r:",
      "mutated_line": "if l - 1 >= r:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l - 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "if l + 1 >= r:",
      "mutated_line": "if l * 1 >= r:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l * 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 1\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return -1\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 1\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l - r) // 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l - r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = l * r // 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = l * r // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 3",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 3\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 1\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 0",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 0\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // 1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 1\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "m = (l + r) // 2",
      "mutated_line": "m = (l + r) // -2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // -2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while i < m and j < r:",
      "mutated_line": "while i <= m and j < r:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i <= m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while i < m and j < r:",
      "mutated_line": "while i >= m and j < r:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i >= m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while i < m and j < r:",
      "mutated_line": "while i != m and j < r:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i != m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while i < m and j < r:",
      "mutated_line": "while i < m and j <= r:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j <= r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while i < m and j < r:",
      "mutated_line": "while i < m and j >= r:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j >= r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while i < m and j < r:",
      "mutated_line": "while i < m and j != r:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j != r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if A[i] <= A[j]:",
      "mutated_line": "if A[i] < A[j]:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] < A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if A[i] <= A[j]:",
      "mutated_line": "if A[i] > A[j]:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] > A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if A[i] <= A[j]:",
      "mutated_line": "if A[i] == A[j]:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] == A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i -= 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j -= 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "cnt += m - i",
      "mutated_line": "cnt -= m - i",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt -= m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "k += 1",
      "mutated_line": "k += 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 2\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 0\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 0\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "k += 1",
      "mutated_line": "k += -1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += -1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ok &= a[1][i] % 3 == 2",
      "mutated_line": "ok &= a[1][i] * 3 == 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] * 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ok &= a[1][i] % 3 == 2",
      "mutated_line": "ok &= a[1][i] + 3 == 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] + 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ok &= a[1][i] % 3 == 2",
      "mutated_line": "ok &= a[1][i] % 3 == 3",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 3\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ok &= a[1][i] % 3 == 2",
      "mutated_line": "ok &= a[1][i] % 3 == 1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 1\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ok &= a[1][i] % 3 == 2",
      "mutated_line": "ok &= a[1][i] % 3 == 0",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 0\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ok &= a[1][i] % 3 == 2",
      "mutated_line": "ok &= a[1][i] % 3 == 1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 1\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ok &= a[1][i] % 3 == 2",
      "mutated_line": "ok &= a[1][i] % 3 == -2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == -2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dist = abs(a[1][i] // 3 - i)",
      "mutated_line": "dist = abs(a[1][i] // 3 + i)",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 + i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dist = abs(a[1][i] // 3 - i)",
      "mutated_line": "dist = abs(a[1][i] // 3 * i)",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 * i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ok &= dist % 2 == 0",
      "mutated_line": "ok &= dist * 2 == 0",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist * 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "ok &= dist % 2 == 0",
      "mutated_line": "ok &= dist + 2 == 0",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist + 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ok &= dist % 2 == 0",
      "mutated_line": "ok &= dist % 2 == 1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 1\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ok &= dist % 2 == 0",
      "mutated_line": "ok &= dist % 2 == -1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == -1\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ok &= dist % 2 == 0",
      "mutated_line": "ok &= dist % 2 == 1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 1\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if (dist // 2 % 2 == 0) != order:",
      "mutated_line": "if (dist // 2 % 2 != 0) != order:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 != 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "flip[i % 2] += 1",
      "mutated_line": "flip[i % 2] += 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 2\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "flip[i % 2] += 1",
      "mutated_line": "flip[i % 2] += 0",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 0\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "flip[i % 2] += 1",
      "mutated_line": "flip[i % 2] += 0",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 0\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "flip[i % 2] += 1",
      "mutated_line": "flip[i % 2] += -1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += -1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "B = a[1][0::2]",
      "mutated_line": "B = a[2][0::2]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[2][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "B = a[1][0::2]",
      "mutated_line": "B = a[0][0::2]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[0][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "B = a[1][0::2]",
      "mutated_line": "B = a[0][0::2]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[0][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "B = a[1][0::2]",
      "mutated_line": "B = a[-1][0::2]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[-1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "B = a[1][0::2]",
      "mutated_line": "B = a[1][1::2]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][1::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "B = a[1][0::2]",
      "mutated_line": "B = a[1][-1::2]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][-1::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "B = a[1][0::2]",
      "mutated_line": "B = a[1][1::2]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][1::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "B = a[1][0::2]",
      "mutated_line": "B = a[1][0::3]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::3]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "B = a[1][0::2]",
      "mutated_line": "B = a[1][0::1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::1]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "B = a[1][0::2]",
      "mutated_line": "B = a[1][0::0]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::0]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "B = a[1][0::2]",
      "mutated_line": "B = a[1][0::1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::1]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "B = a[1][0::2]",
      "mutated_line": "B = a[1][0::-2]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::-2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "hb = merge_and_count_rec(B, a[0], 0, len(B))",
      "mutated_line": "hb = merge_and_count_rec(B, a[1], 0, len(B))",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[1], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "hb = merge_and_count_rec(B, a[0], 0, len(B))",
      "mutated_line": "hb = merge_and_count_rec(B, a[-1], 0, len(B))",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[-1], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "hb = merge_and_count_rec(B, a[0], 0, len(B))",
      "mutated_line": "hb = merge_and_count_rec(B, a[1], 0, len(B))",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[1], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "C = a[1][1::2]",
      "mutated_line": "C = a[2][1::2]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[2][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "C = a[1][1::2]",
      "mutated_line": "C = a[0][1::2]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[0][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "C = a[1][1::2]",
      "mutated_line": "C = a[0][1::2]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[0][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "C = a[1][1::2]",
      "mutated_line": "C = a[-1][1::2]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[-1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "C = a[1][1::2]",
      "mutated_line": "C = a[1][2::2]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][2::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "C = a[1][1::2]",
      "mutated_line": "C = a[1][0::2]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][0::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "C = a[1][1::2]",
      "mutated_line": "C = a[1][0::2]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][0::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "C = a[1][1::2]",
      "mutated_line": "C = a[1][-1::2]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][-1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "C = a[1][1::2]",
      "mutated_line": "C = a[1][1::3]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::3]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "C = a[1][1::2]",
      "mutated_line": "C = a[1][1::1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::1]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "C = a[1][1::2]",
      "mutated_line": "C = a[1][1::0]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::0]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "C = a[1][1::2]",
      "mutated_line": "C = a[1][1::1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::1]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "C = a[1][1::2]",
      "mutated_line": "C = a[1][1::-2]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::-2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "hc = merge_and_count_rec(C, a[0], 0, len(C))",
      "mutated_line": "hc = merge_and_count_rec(C, a[1], 0, len(C))",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[1], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "hc = merge_and_count_rec(C, a[0], 0, len(C))",
      "mutated_line": "hc = merge_and_count_rec(C, a[-1], 0, len(C))",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[-1], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "hc = merge_and_count_rec(C, a[0], 0, len(C))",
      "mutated_line": "hc = merge_and_count_rec(C, a[1], 0, len(C))",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[1], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ok &= hb % 2 == flip[1] % 2",
      "mutated_line": "ok &= hb % 3 == flip[1] % 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 3 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ok &= hb % 2 == flip[1] % 2",
      "mutated_line": "ok &= hb % 1 == flip[1] % 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 1 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ok &= hb % 2 == flip[1] % 2",
      "mutated_line": "ok &= hb % 0 == flip[1] % 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 0 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ok &= hb % 2 == flip[1] % 2",
      "mutated_line": "ok &= hb % 1 == flip[1] % 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 1 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ok &= hb % 2 == flip[1] % 2",
      "mutated_line": "ok &= hb % -2 == flip[1] % 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % -2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ok &= hb % 2 == flip[1] % 2",
      "mutated_line": "ok &= hb % 2 == flip[1] % 3",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 3\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ok &= hb % 2 == flip[1] % 2",
      "mutated_line": "ok &= hb % 2 == flip[1] % 1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 1\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ok &= hb % 2 == flip[1] % 2",
      "mutated_line": "ok &= hb % 2 == flip[1] % 0",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 0\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ok &= hb % 2 == flip[1] % 2",
      "mutated_line": "ok &= hb % 2 == flip[1] % 1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 1\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ok &= hb % 2 == flip[1] % 2",
      "mutated_line": "ok &= hb % 2 == flip[1] % -2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % -2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ok &= hc % 2 == flip[0] % 2",
      "mutated_line": "ok &= hc % 3 == flip[0] % 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 3 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ok &= hc % 2 == flip[0] % 2",
      "mutated_line": "ok &= hc % 1 == flip[0] % 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 1 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ok &= hc % 2 == flip[0] % 2",
      "mutated_line": "ok &= hc % 0 == flip[0] % 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 0 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ok &= hc % 2 == flip[0] % 2",
      "mutated_line": "ok &= hc % 1 == flip[0] % 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 1 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ok &= hc % 2 == flip[0] % 2",
      "mutated_line": "ok &= hc % -2 == flip[0] % 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % -2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ok &= hc % 2 == flip[0] % 2",
      "mutated_line": "ok &= hc % 2 == flip[0] % 3",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 3\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ok &= hc % 2 == flip[0] % 2",
      "mutated_line": "ok &= hc % 2 == flip[0] % 1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 1\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ok &= hc % 2 == flip[0] % 2",
      "mutated_line": "ok &= hc % 2 == flip[0] % 0",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 0\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ok &= hc % 2 == flip[0] % 2",
      "mutated_line": "ok &= hc % 2 == flip[0] % 1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 1\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ok &= hc % 2 == flip[0] % 2",
      "mutated_line": "ok &= hc % 2 == flip[0] % -2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % -2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if l + 1 >= r:",
      "mutated_line": "if l + 2 >= r:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 2 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if l + 1 >= r:",
      "mutated_line": "if l + 0 >= r:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 0 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if l + 1 >= r:",
      "mutated_line": "if l + 0 >= r:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 0 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if l + 1 >= r:",
      "mutated_line": "if l + -1 >= r:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + -1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 2\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 0\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 0\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += -1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 2\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 0\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 0\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += -1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "cnt += m - i",
      "mutated_line": "cnt += m + i",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m + i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "cnt += m - i",
      "mutated_line": "cnt += m * i",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m * i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ok &= a[1][i] % 3 == 2",
      "mutated_line": "ok &= a[1][i] % 4 == 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 4 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ok &= a[1][i] % 3 == 2",
      "mutated_line": "ok &= a[1][i] % 2 == 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 2 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ok &= a[1][i] % 3 == 2",
      "mutated_line": "ok &= a[1][i] % 0 == 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 0 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ok &= a[1][i] % 3 == 2",
      "mutated_line": "ok &= a[1][i] % 1 == 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 1 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ok &= a[1][i] % 3 == 2",
      "mutated_line": "ok &= a[1][i] % -3 == 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % -3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] + 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] + 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] * 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] * 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] - 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] - 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] * 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] * 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dist = abs(a[1][i] // 3 - i)",
      "mutated_line": "dist = abs(a[1][i] / 3 - i)",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] / 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dist = abs(a[1][i] // 3 - i)",
      "mutated_line": "dist = abs(a[1][i] * 3 - i)",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] * 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ok &= dist % 2 == 0",
      "mutated_line": "ok &= dist % 3 == 0",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 3 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ok &= dist % 2 == 0",
      "mutated_line": "ok &= dist % 1 == 0",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 1 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ok &= dist % 2 == 0",
      "mutated_line": "ok &= dist % 0 == 0",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 0 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ok &= dist % 2 == 0",
      "mutated_line": "ok &= dist % 1 == 0",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 1 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ok &= dist % 2 == 0",
      "mutated_line": "ok &= dist % -2 == 0",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % -2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] + 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] + 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] * 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] * 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] - 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] - 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] * 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] * 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if (dist // 2 % 2 == 0) != order:",
      "mutated_line": "if (dist // 2 * 2 == 0) != order:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 * 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if (dist // 2 % 2 == 0) != order:",
      "mutated_line": "if (dist // 2 + 2 == 0) != order:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 + 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (dist // 2 % 2 == 0) != order:",
      "mutated_line": "if (dist // 2 % 2 == 1) != order:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 1) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (dist // 2 % 2 == 0) != order:",
      "mutated_line": "if (dist // 2 % 2 == -1) != order:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == -1) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (dist // 2 % 2 == 0) != order:",
      "mutated_line": "if (dist // 2 % 2 == 1) != order:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 1) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "flip[i % 2] += 1",
      "mutated_line": "flip[i * 2] += 1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i * 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "flip[i % 2] += 1",
      "mutated_line": "flip[i + 2] += 1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i + 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ok &= hb % 2 == flip[1] % 2",
      "mutated_line": "ok &= hb % 2 == flip[2] % 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[2] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ok &= hb % 2 == flip[1] % 2",
      "mutated_line": "ok &= hb % 2 == flip[0] % 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[0] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ok &= hb % 2 == flip[1] % 2",
      "mutated_line": "ok &= hb % 2 == flip[0] % 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[0] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "ok &= hb % 2 == flip[1] % 2",
      "mutated_line": "ok &= hb % 2 == flip[-1] % 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[-1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ok &= hc % 2 == flip[0] % 2",
      "mutated_line": "ok &= hc % 2 == flip[1] % 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[1] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ok &= hc % 2 == flip[0] % 2",
      "mutated_line": "ok &= hc % 2 == flip[-1] % 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[-1] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ok &= hc % 2 == flip[0] % 2",
      "mutated_line": "ok &= hc % 2 == flip[1] % 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[1] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 2, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 2, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 0, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 0, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 0, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 0, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - -1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - -1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 2]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 2]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 0]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 0]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 0]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 0]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + -1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + -1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist = abs(a[1][i] // 3 - i)",
      "mutated_line": "dist = abs(a[1][i] // 4 - i)",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 4 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist = abs(a[1][i] // 3 - i)",
      "mutated_line": "dist = abs(a[1][i] // 2 - i)",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 2 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist = abs(a[1][i] // 3 - i)",
      "mutated_line": "dist = abs(a[1][i] // 0 - i)",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 0 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist = abs(a[1][i] // 3 - i)",
      "mutated_line": "dist = abs(a[1][i] // 1 - i)",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 1 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist = abs(a[1][i] // 3 - i)",
      "mutated_line": "dist = abs(a[1][i] // -3 - i)",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // -3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 2, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 2, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 0, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 0, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 0, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 0, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - -1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - -1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 2]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 2]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 0]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 0]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 0]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 0]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + -1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + -1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if (dist // 2 % 2 == 0) != order:",
      "mutated_line": "if (dist / 2 % 2 == 0) != order:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist / 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if (dist // 2 % 2 == 0) != order:",
      "mutated_line": "if (dist * 2 % 2 == 0) != order:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist * 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (dist // 2 % 2 == 0) != order:",
      "mutated_line": "if (dist // 2 % 3 == 0) != order:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 3 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (dist // 2 % 2 == 0) != order:",
      "mutated_line": "if (dist // 2 % 1 == 0) != order:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 1 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (dist // 2 % 2 == 0) != order:",
      "mutated_line": "if (dist // 2 % 0 == 0) != order:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 0 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (dist // 2 % 2 == 0) != order:",
      "mutated_line": "if (dist // 2 % 1 == 0) != order:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 1 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (dist // 2 % 2 == 0) != order:",
      "mutated_line": "if (dist // 2 % -2 == 0) != order:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % -2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "flip[i % 2] += 1",
      "mutated_line": "flip[i % 3] += 1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 3] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "flip[i % 2] += 1",
      "mutated_line": "flip[i % 1] += 1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 1] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "flip[i % 2] += 1",
      "mutated_line": "flip[i % 0] += 1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 0] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "flip[i % 2] += 1",
      "mutated_line": "flip[i % 1] += 1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 1] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "flip[i % 2] += 1",
      "mutated_line": "flip[i % -2] += 1",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % -2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ok &= a[1][i] % 3 == 2",
      "mutated_line": "ok &= a[2][i] % 3 == 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[2][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ok &= a[1][i] % 3 == 2",
      "mutated_line": "ok &= a[0][i] % 3 == 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[0][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ok &= a[1][i] % 3 == 2",
      "mutated_line": "ok &= a[0][i] % 3 == 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[0][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ok &= a[1][i] % 3 == 2",
      "mutated_line": "ok &= a[-1][i] % 3 == 2",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[-1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[2][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[2][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[0][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[0][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[0][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[0][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[-1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[-1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[1][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[1][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[-1][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[-1][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[1][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[1][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[2][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[2][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[0][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[0][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[0][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[0][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[-1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[-1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[3][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[3][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[1][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[1][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[0][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[0][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[1][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[1][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[-2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[-2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[2][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[2][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[0][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[0][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[0][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[0][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[-1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[-1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (dist // 2 % 2 == 0) != order:",
      "mutated_line": "if (dist // 3 % 2 == 0) != order:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 3 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (dist // 2 % 2 == 0) != order:",
      "mutated_line": "if (dist // 1 % 2 == 0) != order:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 1 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (dist // 2 % 2 == 0) != order:",
      "mutated_line": "if (dist // 0 % 2 == 0) != order:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 0 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (dist // 2 % 2 == 0) != order:",
      "mutated_line": "if (dist // 1 % 2 == 0) != order:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 1 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if (dist // 2 % 2 == 0) != order:",
      "mutated_line": "if (dist // -2 % 2 == 0) != order:",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // -2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[1][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[1][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[-1][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[-1][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[1][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[1][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[2][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[2][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[0][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[0][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[0][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[0][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[-1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[-1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[3][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[3][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[1][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[1][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[0][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[0][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[1][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[1][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[-2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[-2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[2][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[2][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[0][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[0][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[0][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[0][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[-1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[-1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[2][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[2][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[0][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[0][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[0][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[0][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[-1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[-1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist = abs(a[1][i] // 3 - i)",
      "mutated_line": "dist = abs(a[2][i] // 3 - i)",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[2][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist = abs(a[1][i] // 3 - i)",
      "mutated_line": "dist = abs(a[0][i] // 3 - i)",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[0][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist = abs(a[1][i] // 3 - i)",
      "mutated_line": "dist = abs(a[0][i] // 3 - i)",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[0][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist = abs(a[1][i] // 3 - i)",
      "mutated_line": "dist = abs(a[-1][i] // 3 - i)",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[-1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[2][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[2][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[0][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[0][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[0][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[0][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[-1][i] - 1, a[1][i], a[1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[-1][i] - 1, a[1][i], a[1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[2][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[2][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[0][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[0][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[0][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[0][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[1][i] + 1]",
      "mutated_line": "order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[-1][i] + 1]",
      "code": "def is_grid_achievable(N, a):\n\n    def merge_and_count_rec(A, W, l, r):\n        if l + 1 >= r:\n            return 0\n        m = (l + r) // 2\n        cnt = merge_and_count_rec(A, W, l, m)\n        cnt += merge_and_count_rec(A, W, m, r)\n        (i, j, k) = (l, m, l)\n        while i < m and j < r:\n            if A[i] <= A[j]:\n                W[k] = A[i]\n                i += 1\n            else:\n                W[k] = A[j]\n                j += 1\n                cnt += m - i\n            k += 1\n        if i < m:\n            W[k:r] = A[i:m]\n        if j < r:\n            W[k:r] = A[j:r]\n        A[l:r] = W[l:r]\n        return cnt\n    ok = True\n    flip = [0, 0]\n    for i in range(N):\n        ok &= a[1][i] % 3 == 2\n        ok &= sorted((a[0][i], a[1][i], a[2][i])) == [a[1][i] - 1, a[1][i], a[1][i] + 1]\n        dist = abs(a[1][i] // 3 - i)\n        ok &= dist % 2 == 0\n        order = [a[0][i], a[1][i], a[2][i]] == [a[1][i] - 1, a[1][i], a[-1][i] + 1]\n        if (dist // 2 % 2 == 0) != order:\n            flip[i % 2] += 1\n    B = a[1][0::2]\n    hb = merge_and_count_rec(B, a[0], 0, len(B))\n    C = a[1][1::2]\n    hc = merge_and_count_rec(C, a[0], 0, len(C))\n    ok &= hb % 2 == flip[1] % 2\n    ok &= hc % 2 == flip[0] % 2\n    return ok"
    }
  ]
}