{
  "task_id": "taco_10455",
  "entry_point": "min_attacks_to_destination",
  "mutant_count": 143,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 * 20",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 * 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 + 20",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 + 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "a -= 1",
      "mutated_line": "a += 1",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a += 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "b -= 1",
      "mutated_line": "b += 1",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b += 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "costs = [INF] * (n * (l + 1))",
      "mutated_line": "costs = [INF] / (n * (l + 1))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] / (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "costs = [INF] * (n * (l + 1))",
      "mutated_line": "costs = [INF] + n * (l + 1)",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] + n * (l + 1)\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "costs = [INF] * (n * (l + 1))",
      "mutated_line": "costs = [INF] ** (n * (l + 1))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] ** (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "costs[l * n] = 0",
      "mutated_line": "costs[l * n] = 1",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 1\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "costs[l * n] = 0",
      "mutated_line": "costs[l * n] = -1",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = -1\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "costs[l * n] = 0",
      "mutated_line": "costs[l * n] = 1",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 1\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 11 ** 20",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 11 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 9 ** 20",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 9 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 0 ** 20",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 0 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 1 ** 20",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 1 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = -10 ** 20",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = -10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 21",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 21\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 19",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 19\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 0",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 0\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** 1",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 1\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "INF = 10 ** 20",
      "mutated_line": "INF = 10 ** -20",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** -20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "a -= 1",
      "mutated_line": "a -= 2",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 2\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "a -= 1",
      "mutated_line": "a -= 0",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 0\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "a -= 1",
      "mutated_line": "a -= 0",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 0\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "a -= 1",
      "mutated_line": "a -= -1",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= -1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "b -= 1",
      "mutated_line": "b -= 2",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 2\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "b -= 1",
      "mutated_line": "b -= 0",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 0\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "b -= 1",
      "mutated_line": "b -= 0",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 0\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "b -= 1",
      "mutated_line": "b -= -1",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= -1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "costs = [INF] * (n * (l + 1))",
      "mutated_line": "costs = [INF] * (n / (l + 1))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n / (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "costs = [INF] * (n * (l + 1))",
      "mutated_line": "costs = [INF] * (n + (l + 1))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n + (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "costs = [INF] * (n * (l + 1))",
      "mutated_line": "costs = [INF] * n ** (l + 1)",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * n ** (l + 1)\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "costs[l * n] = 0",
      "mutated_line": "costs[l / n] = 0",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l / n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "costs[l * n] = 0",
      "mutated_line": "costs[l + n] = 0",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l + n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "costs[l * n] = 0",
      "mutated_line": "costs[l ** n] = 0",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l ** n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for i in range(d, l + 1):",
      "mutated_line": "for i in range(d, l - 1):",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l - 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for i in range(d, l + 1):",
      "mutated_line": "for i in range(d, l * 1):",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l * 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in range(l + 1):",
      "mutated_line": "for i in range(l - 1):",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l - 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in range(l + 1):",
      "mutated_line": "for i in range(l * 1):",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l * 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heappush(que, (0, l * n))",
      "mutated_line": "heappush(que, (1, l * n))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (1, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heappush(que, (0, l * n))",
      "mutated_line": "heappush(que, (-1, l * n))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (-1, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "heappush(que, (0, l * n))",
      "mutated_line": "heappush(que, (1, l * n))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (1, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "heappush(que, (0, l * n))",
      "mutated_line": "heappush(que, (0, l / n))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l / n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "heappush(que, (0, l * n))",
      "mutated_line": "heappush(que, (0, l + n))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l + n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "heappush(que, (0, l * n))",
      "mutated_line": "heappush(que, (0, l ** n))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l ** n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "costs = [INF] * (n * (l + 1))",
      "mutated_line": "costs = [INF] * (n * (l - 1))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l - 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "costs = [INF] * (n * (l + 1))",
      "mutated_line": "costs = [INF] * (n * (l * 1))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l * 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if costs[to] > total + enemy:",
      "mutated_line": "if costs[to] >= total + enemy:",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] >= total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if costs[to] > total + enemy:",
      "mutated_line": "if costs[to] <= total + enemy:",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] <= total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if costs[to] > total + enemy:",
      "mutated_line": "if costs[to] != total + enemy:",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] != total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "edges = [[] for _ in range(n * (l + 1))]",
      "mutated_line": "edges = [[] for _ in range(n / (l + 1))]",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n / (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "edges = [[] for _ in range(n * (l + 1))]",
      "mutated_line": "edges = [[] for _ in range(n + (l + 1))]",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n + (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "edges = [[] for _ in range(n * (l + 1))]",
      "mutated_line": "edges = [[] for _ in range(n ** (l + 1))]",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n ** (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(d, l + 1):",
      "mutated_line": "for i in range(d, l + 2):",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 2):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(d, l + 1):",
      "mutated_line": "for i in range(d, l + 0):",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 0):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(d, l + 1):",
      "mutated_line": "for i in range(d, l + 0):",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 0):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(d, l + 1):",
      "mutated_line": "for i in range(d, l + -1):",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + -1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(l + 1):",
      "mutated_line": "for i in range(l + 2):",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 2):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(l + 1):",
      "mutated_line": "for i in range(l + 0):",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 0):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(l + 1):",
      "mutated_line": "for i in range(l + 0):",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 0):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(l + 1):",
      "mutated_line": "for i in range(l + -1):",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + -1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "costs = [INF] * (n * (l + 1))",
      "mutated_line": "costs = [INF] * (n * (l + 2))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 2))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "costs = [INF] * (n * (l + 1))",
      "mutated_line": "costs = [INF] * (n * (l + 0))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 0))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "costs = [INF] * (n * (l + 1))",
      "mutated_line": "costs = [INF] * (n * (l + 0))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 0))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "costs = [INF] * (n * (l + 1))",
      "mutated_line": "costs = [INF] * (n * (l + -1))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + -1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if costs[to] > total + enemy:",
      "mutated_line": "if costs[to] > total - enemy:",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total - enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if costs[to] > total + enemy:",
      "mutated_line": "if costs[to] > total * enemy:",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total * enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "costs[to] = total + enemy",
      "mutated_line": "costs[to] = total - enemy",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total - enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "costs[to] = total + enemy",
      "mutated_line": "costs[to] = total * enemy",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total * enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans = min((costs[i * n + n - 1] for i in range(l + 1)))",
      "mutated_line": "ans = min((costs[i * n + n + 1] for i in range(l + 1)))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n + 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans = min((costs[i * n + n - 1] for i in range(l + 1)))",
      "mutated_line": "ans = min((costs[(i * n + n) * 1] for i in range(l + 1)))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[(i * n + n) * 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "edges = [[] for _ in range(n * (l + 1))]",
      "mutated_line": "edges = [[] for _ in range(n * (l - 1))]",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l - 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "edges = [[] for _ in range(n * (l + 1))]",
      "mutated_line": "edges = [[] for _ in range(n * (l * 1))]",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l * 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "edges[i * n + a].append((0, (i - d) * n + b))",
      "mutated_line": "edges[i * n + a].append((1, (i - d) * n + b))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((1, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "edges[i * n + a].append((0, (i - d) * n + b))",
      "mutated_line": "edges[i * n + a].append((-1, (i - d) * n + b))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((-1, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "edges[i * n + a].append((0, (i - d) * n + b))",
      "mutated_line": "edges[i * n + a].append((1, (i - d) * n + b))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((1, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "edges[i * n + a].append((0, (i - d) * n + b))",
      "mutated_line": "edges[i * n + a].append((0, (i - d) * n - b))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n - b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "edges[i * n + a].append((0, (i - d) * n + b))",
      "mutated_line": "edges[i * n + a].append((0, (i - d) * n * b))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n * b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "edges[i * n + b].append((0, (i - d) * n + a))",
      "mutated_line": "edges[i * n + b].append((1, (i - d) * n + a))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((1, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "edges[i * n + b].append((0, (i - d) * n + a))",
      "mutated_line": "edges[i * n + b].append((-1, (i - d) * n + a))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((-1, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "edges[i * n + b].append((0, (i - d) * n + a))",
      "mutated_line": "edges[i * n + b].append((1, (i - d) * n + a))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((1, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "edges[i * n + b].append((0, (i - d) * n + a))",
      "mutated_line": "edges[i * n + b].append((0, (i - d) * n - a))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n - a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "edges[i * n + b].append((0, (i - d) * n + a))",
      "mutated_line": "edges[i * n + b].append((0, (i - d) * n * a))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n * a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "edges[i * n + a].append((e, i * n + b))",
      "mutated_line": "edges[i * n + a].append((e, i * n - b))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n - b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "edges[i * n + a].append((e, i * n + b))",
      "mutated_line": "edges[i * n + a].append((e, i * n * b))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n * b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "edges[i * n + b].append((e, i * n + a))",
      "mutated_line": "edges[i * n + b].append((e, i * n - a))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n - a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "edges[i * n + b].append((e, i * n + a))",
      "mutated_line": "edges[i * n + b].append((e, i * n * a))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n * a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans = min((costs[i * n + n - 1] for i in range(l + 1)))",
      "mutated_line": "ans = min((costs[i * n - n - 1] for i in range(l + 1)))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n - n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans = min((costs[i * n + n - 1] for i in range(l + 1)))",
      "mutated_line": "ans = min((costs[i * n * n - 1] for i in range(l + 1)))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n * n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = min((costs[i * n + n - 1] for i in range(l + 1)))",
      "mutated_line": "ans = min((costs[i * n + n - 2] for i in range(l + 1)))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 2] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = min((costs[i * n + n - 1] for i in range(l + 1)))",
      "mutated_line": "ans = min((costs[i * n + n - 0] for i in range(l + 1)))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 0] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = min((costs[i * n + n - 1] for i in range(l + 1)))",
      "mutated_line": "ans = min((costs[i * n + n - 0] for i in range(l + 1)))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 0] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = min((costs[i * n + n - 1] for i in range(l + 1)))",
      "mutated_line": "ans = min((costs[i * n + n - -1] for i in range(l + 1)))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - -1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans = min((costs[i * n + n - 1] for i in range(l + 1)))",
      "mutated_line": "ans = min((costs[i * n + n - 1] for i in range(l - 1)))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l - 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans = min((costs[i * n + n - 1] for i in range(l + 1)))",
      "mutated_line": "ans = min((costs[i * n + n - 1] for i in range(l * 1)))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l * 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "edges = [[] for _ in range(n * (l + 1))]",
      "mutated_line": "edges = [[] for _ in range(n * (l + 2))]",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 2))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "edges = [[] for _ in range(n * (l + 1))]",
      "mutated_line": "edges = [[] for _ in range(n * (l + 0))]",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 0))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "edges = [[] for _ in range(n * (l + 1))]",
      "mutated_line": "edges = [[] for _ in range(n * (l + 0))]",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 0))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "edges = [[] for _ in range(n * (l + 1))]",
      "mutated_line": "edges = [[] for _ in range(n * (l + -1))]",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + -1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "edges[i * n + a].append((0, (i - d) * n + b))",
      "mutated_line": "edges[i * n - a].append((0, (i - d) * n + b))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n - a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "edges[i * n + a].append((0, (i - d) * n + b))",
      "mutated_line": "edges[i * n * a].append((0, (i - d) * n + b))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n * a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "edges[i * n + a].append((0, (i - d) * n + b))",
      "mutated_line": "edges[i * n + a].append((0, (i - d) / n + b))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) / n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "edges[i * n + a].append((0, (i - d) * n + b))",
      "mutated_line": "edges[i * n + a].append((0, i - d + n + b))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, i - d + n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "edges[i * n + a].append((0, (i - d) * n + b))",
      "mutated_line": "edges[i * n + a].append((0, (i - d) ** n + b))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) ** n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "edges[i * n + b].append((0, (i - d) * n + a))",
      "mutated_line": "edges[i * n - b].append((0, (i - d) * n + a))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n - b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "edges[i * n + b].append((0, (i - d) * n + a))",
      "mutated_line": "edges[i * n * b].append((0, (i - d) * n + a))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n * b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "edges[i * n + b].append((0, (i - d) * n + a))",
      "mutated_line": "edges[i * n + b].append((0, (i - d) / n + a))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) / n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "edges[i * n + b].append((0, (i - d) * n + a))",
      "mutated_line": "edges[i * n + b].append((0, i - d + n + a))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, i - d + n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "edges[i * n + b].append((0, (i - d) * n + a))",
      "mutated_line": "edges[i * n + b].append((0, (i - d) ** n + a))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) ** n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "edges[i * n + a].append((e, i * n + b))",
      "mutated_line": "edges[i * n - a].append((e, i * n + b))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n - a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "edges[i * n + a].append((e, i * n + b))",
      "mutated_line": "edges[i * n * a].append((e, i * n + b))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n * a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "edges[i * n + a].append((e, i * n + b))",
      "mutated_line": "edges[i * n + a].append((e, i / n + b))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i / n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "edges[i * n + a].append((e, i * n + b))",
      "mutated_line": "edges[i * n + a].append((e, i + n + b))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i + n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "edges[i * n + a].append((e, i * n + b))",
      "mutated_line": "edges[i * n + a].append((e, i ** n + b))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i ** n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "edges[i * n + b].append((e, i * n + a))",
      "mutated_line": "edges[i * n - b].append((e, i * n + a))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n - b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "edges[i * n + b].append((e, i * n + a))",
      "mutated_line": "edges[i * n * b].append((e, i * n + a))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n * b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "edges[i * n + b].append((e, i * n + a))",
      "mutated_line": "edges[i * n + b].append((e, i / n + a))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i / n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "edges[i * n + b].append((e, i * n + a))",
      "mutated_line": "edges[i * n + b].append((e, i + n + a))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i + n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "edges[i * n + b].append((e, i * n + a))",
      "mutated_line": "edges[i * n + b].append((e, i ** n + a))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i ** n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "heappush(que, (total + enemy, to))",
      "mutated_line": "heappush(que, (total - enemy, to))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total - enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "heappush(que, (total + enemy, to))",
      "mutated_line": "heappush(que, (total * enemy, to))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total * enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans = min((costs[i * n + n - 1] for i in range(l + 1)))",
      "mutated_line": "ans = min((costs[i / n + n - 1] for i in range(l + 1)))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i / n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans = min((costs[i * n + n - 1] for i in range(l + 1)))",
      "mutated_line": "ans = min((costs[i + n + n - 1] for i in range(l + 1)))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i + n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans = min((costs[i * n + n - 1] for i in range(l + 1)))",
      "mutated_line": "ans = min((costs[i ** n + n - 1] for i in range(l + 1)))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i ** n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = min((costs[i * n + n - 1] for i in range(l + 1)))",
      "mutated_line": "ans = min((costs[i * n + n - 1] for i in range(l + 2)))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 2)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = min((costs[i * n + n - 1] for i in range(l + 1)))",
      "mutated_line": "ans = min((costs[i * n + n - 1] for i in range(l + 0)))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 0)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = min((costs[i * n + n - 1] for i in range(l + 1)))",
      "mutated_line": "ans = min((costs[i * n + n - 1] for i in range(l + 0)))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 0)))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = min((costs[i * n + n - 1] for i in range(l + 1)))",
      "mutated_line": "ans = min((costs[i * n + n - 1] for i in range(l + -1)))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + -1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "edges[i * n + a].append((0, (i - d) * n + b))",
      "mutated_line": "edges[i / n + a].append((0, (i - d) * n + b))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i / n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "edges[i * n + a].append((0, (i - d) * n + b))",
      "mutated_line": "edges[i + n + a].append((0, (i - d) * n + b))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i + n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "edges[i * n + a].append((0, (i - d) * n + b))",
      "mutated_line": "edges[i ** n + a].append((0, (i - d) * n + b))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i ** n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "edges[i * n + a].append((0, (i - d) * n + b))",
      "mutated_line": "edges[i * n + a].append((0, (i + d) * n + b))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i + d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "edges[i * n + a].append((0, (i - d) * n + b))",
      "mutated_line": "edges[i * n + a].append((0, i * d * n + b))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, i * d * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "edges[i * n + b].append((0, (i - d) * n + a))",
      "mutated_line": "edges[i / n + b].append((0, (i - d) * n + a))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i / n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "edges[i * n + b].append((0, (i - d) * n + a))",
      "mutated_line": "edges[i + n + b].append((0, (i - d) * n + a))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i + n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "edges[i * n + b].append((0, (i - d) * n + a))",
      "mutated_line": "edges[i ** n + b].append((0, (i - d) * n + a))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i ** n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "edges[i * n + b].append((0, (i - d) * n + a))",
      "mutated_line": "edges[i * n + b].append((0, (i + d) * n + a))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i + d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "edges[i * n + b].append((0, (i - d) * n + a))",
      "mutated_line": "edges[i * n + b].append((0, i * d * n + a))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, i * d * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "edges[i * n + a].append((e, i * n + b))",
      "mutated_line": "edges[i / n + a].append((e, i * n + b))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i / n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "edges[i * n + a].append((e, i * n + b))",
      "mutated_line": "edges[i + n + a].append((e, i * n + b))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i + n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "edges[i * n + a].append((e, i * n + b))",
      "mutated_line": "edges[i ** n + a].append((e, i * n + b))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i ** n + a].append((e, i * n + b))\n            edges[i * n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "edges[i * n + b].append((e, i * n + a))",
      "mutated_line": "edges[i / n + b].append((e, i * n + a))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i / n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "edges[i * n + b].append((e, i * n + a))",
      "mutated_line": "edges[i + n + b].append((e, i * n + a))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i + n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "edges[i * n + b].append((e, i * n + a))",
      "mutated_line": "edges[i ** n + b].append((e, i * n + a))",
      "code": "from heapq import heappush, heappop\n\ndef min_attacks_to_destination(n, m, l, roads):\n    INF = 10 ** 20\n    edges = [[] for _ in range(n * (l + 1))]\n    for (a, b, d, e) in roads:\n        a -= 1\n        b -= 1\n        for i in range(d, l + 1):\n            edges[i * n + a].append((0, (i - d) * n + b))\n            edges[i * n + b].append((0, (i - d) * n + a))\n        for i in range(l + 1):\n            edges[i * n + a].append((e, i * n + b))\n            edges[i ** n + b].append((e, i * n + a))\n    que = []\n    heappush(que, (0, l * n))\n    costs = [INF] * (n * (l + 1))\n    costs[l * n] = 0\n    while que:\n        (total, node) = heappop(que)\n        for (enemy, to) in edges[node]:\n            if costs[to] > total + enemy:\n                costs[to] = total + enemy\n                heappush(que, (total + enemy, to))\n    ans = min((costs[i * n + n - 1] for i in range(l + 1)))\n    return ans"
    }
  ]
}