{
  "task_id": "taco_5178",
  "entry_point": "count_arrangements",
  "mutant_count": 148,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "def count_arrangements(N, K, mod=10**9 + 7):",
      "mutated_line": "def count_arrangements(N, K, mod=10 ** 9 - 7):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 - 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "def count_arrangements(N, K, mod=10**9 + 7):",
      "mutated_line": "def count_arrangements(N, K, mod=10 ** 9 * 7):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 * 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "def count_arrangements(N, K, mod=10**9 + 7):",
      "mutated_line": "def count_arrangements(N, K, mod=10 * 9 + 7):",
      "code": "def count_arrangements(N, K, mod=10 * 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 1,
      "original_line": "def count_arrangements(N, K, mod=10**9 + 7):",
      "mutated_line": "def count_arrangements(N, K, mod=10 + 9 + 7):",
      "code": "def count_arrangements(N, K, mod=10 + 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_arrangements(N, K, mod=10**9 + 7):",
      "mutated_line": "def count_arrangements(N, K, mod=10 ** 9 + 8):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 8):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_arrangements(N, K, mod=10**9 + 7):",
      "mutated_line": "def count_arrangements(N, K, mod=10 ** 9 + 6):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 6):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_arrangements(N, K, mod=10**9 + 7):",
      "mutated_line": "def count_arrangements(N, K, mod=10 ** 9 + 0):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 0):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_arrangements(N, K, mod=10**9 + 7):",
      "mutated_line": "def count_arrangements(N, K, mod=10 ** 9 + 1):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 1):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_arrangements(N, K, mod=10**9 + 7):",
      "mutated_line": "def count_arrangements(N, K, mod=10 ** 9 + -7):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + -7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 3,
      "original_line": "if r < 0 or r > n:",
      "mutated_line": "if r < 0 and r > n:",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 and r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return g1[n] * g2[r] * g2[n - r] % mod",
      "mutated_line": "return g1[n] * g2[r] * g2[n - r] * mod",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] * mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return g1[n] * g2[r] * g2[n - r] % mod",
      "mutated_line": "return g1[n] * g2[r] * g2[n - r] + mod",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] + mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g1 = [1, 1]  # factorial",
      "mutated_line": "g2 = [1, 1]",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [2, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g1 = [1, 1]  # factorial",
      "mutated_line": "g2 = [1, 1]",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [0, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g1 = [1, 1]  # factorial",
      "mutated_line": "g2 = [1, 1]",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [0, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g1 = [1, 1]  # factorial",
      "mutated_line": "g2 = [1, 1]",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [-1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g1 = [1, 1]  # factorial",
      "mutated_line": "g2 = [1, 1]",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 2]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g1 = [1, 1]  # factorial",
      "mutated_line": "g2 = [1, 1]",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 0]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g1 = [1, 1]  # factorial",
      "mutated_line": "g2 = [1, 1]",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 0]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "g1 = [1, 1]  # factorial",
      "mutated_line": "g2 = [1, 1]",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, -1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g2 = [1, 1]  # inverse factorial",
      "mutated_line": "g2 = [2, 1]",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [2, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g2 = [1, 1]  # inverse factorial",
      "mutated_line": "g2 = [0, 1]",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [0, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g2 = [1, 1]  # inverse factorial",
      "mutated_line": "g2 = [0, 1]",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [0, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g2 = [1, 1]  # inverse factorial",
      "mutated_line": "g2 = [-1, 1]",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [-1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g2 = [1, 1]  # inverse factorial",
      "mutated_line": "g2 = [1, 2]",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 2]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g2 = [1, 1]  # inverse factorial",
      "mutated_line": "g2 = [1, 0]",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 0]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g2 = [1, 1]  # inverse factorial",
      "mutated_line": "g2 = [1, 0]",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 0]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "g2 = [1, 1]  # inverse factorial",
      "mutated_line": "g2 = [1, -1]",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, -1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inverse = [0, 1]",
      "mutated_line": "inverse = [1, 1]",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [1, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inverse = [0, 1]",
      "mutated_line": "inverse = [-1, 1]",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [-1, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inverse = [0, 1]",
      "mutated_line": "inverse = [1, 1]",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [1, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inverse = [0, 1]",
      "mutated_line": "inverse = [0, 2]",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 2]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inverse = [0, 1]",
      "mutated_line": "inverse = [0, 0]",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 0]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inverse = [0, 1]",
      "mutated_line": "inverse = [0, 0]",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 0]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "inverse = [0, 1]",
      "mutated_line": "inverse = [0, -1]",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, -1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(3, N + 1):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(3, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(1, N + 1):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(1, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(0, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(1, N + 1):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(1, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(-2, N + 1):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(-2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(2, N - 1):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N - 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(2, N * 1):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N * 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, K + 1):",
      "mutated_line": "for i in range(2, K + 1):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(2, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, K + 1):",
      "mutated_line": "for i in range(0, K + 1):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(0, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, K + 1):",
      "mutated_line": "for i in range(0, K + 1):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(0, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, K + 1):",
      "mutated_line": "for i in range(-1, K + 1):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(-1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for i in range(1, K + 1):",
      "mutated_line": "for i in range(1, K - 1):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K - 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for i in range(1, K + 1):",
      "mutated_line": "for i in range(1, K * 1):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K * 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_arrangements(N, K, mod=10**9 + 7):",
      "mutated_line": "def count_arrangements(N, K, mod=11 ** 9 + 7):",
      "code": "def count_arrangements(N, K, mod=11 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_arrangements(N, K, mod=10**9 + 7):",
      "mutated_line": "def count_arrangements(N, K, mod=9 ** 9 + 7):",
      "code": "def count_arrangements(N, K, mod=9 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_arrangements(N, K, mod=10**9 + 7):",
      "mutated_line": "def count_arrangements(N, K, mod=0 ** 9 + 7):",
      "code": "def count_arrangements(N, K, mod=0 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_arrangements(N, K, mod=10**9 + 7):",
      "mutated_line": "def count_arrangements(N, K, mod=1 ** 9 + 7):",
      "code": "def count_arrangements(N, K, mod=1 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_arrangements(N, K, mod=10**9 + 7):",
      "mutated_line": "def count_arrangements(N, K, mod=-10 ** 9 + 7):",
      "code": "def count_arrangements(N, K, mod=-10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_arrangements(N, K, mod=10**9 + 7):",
      "mutated_line": "def count_arrangements(N, K, mod=10 ** 10 + 7):",
      "code": "def count_arrangements(N, K, mod=10 ** 10 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_arrangements(N, K, mod=10**9 + 7):",
      "mutated_line": "def count_arrangements(N, K, mod=10 ** 8 + 7):",
      "code": "def count_arrangements(N, K, mod=10 ** 8 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_arrangements(N, K, mod=10**9 + 7):",
      "mutated_line": "def count_arrangements(N, K, mod=10 ** 0 + 7):",
      "code": "def count_arrangements(N, K, mod=10 ** 0 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_arrangements(N, K, mod=10**9 + 7):",
      "mutated_line": "def count_arrangements(N, K, mod=10 ** 1 + 7):",
      "code": "def count_arrangements(N, K, mod=10 ** 1 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def count_arrangements(N, K, mod=10**9 + 7):",
      "mutated_line": "def count_arrangements(N, K, mod=10 ** -9 + 7):",
      "code": "def count_arrangements(N, K, mod=10 ** -9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if r < 0 or r > n:",
      "mutated_line": "if r <= 0 or r > n:",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r <= 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if r < 0 or r > n:",
      "mutated_line": "if r >= 0 or r > n:",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r >= 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if r < 0 or r > n:",
      "mutated_line": "if r != 0 or r > n:",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r != 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if r < 0 or r > n:",
      "mutated_line": "if r < 0 or r >= n:",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r >= n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if r < 0 or r > n:",
      "mutated_line": "if r < 0 or r <= n:",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r <= n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if r < 0 or r > n:",
      "mutated_line": "if r < 0 or r != n:",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r != n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 1\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return -1\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 1\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "r = min(r, n - r)",
      "mutated_line": "r = min(r, n + r)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n + r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "r = min(r, n - r)",
      "mutated_line": "r = min(r, n * r)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n * r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return g1[n] * g2[r] * g2[n - r] % mod",
      "mutated_line": "return g1[n] * g2[r] / g2[n - r] % mod",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] / g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return g1[n] * g2[r] * g2[n - r] % mod",
      "mutated_line": "return (g1[n] * g2[r] + g2[n - r]) % mod",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return (g1[n] * g2[r] + g2[n - r]) % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return g1[n] * g2[r] * g2[n - r] % mod",
      "mutated_line": "return (g1[n] * g2[r]) ** g2[n - r] % mod",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return (g1[n] * g2[r]) ** g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(2, N + 2):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 2):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(2, N + 0):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 0):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(2, N + 0):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 0):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for i in range(2, N + 1):",
      "mutated_line": "for i in range(2, N + -1):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + -1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "g1.append(g1[-1] * i % mod)",
      "mutated_line": "g1.append(g1[-1] * i * mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i * mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "g1.append(g1[-1] * i % mod)",
      "mutated_line": "g1.append(g1[-1] * i + mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i + mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "inverse.append(-inverse[mod % i] * (mod // i) % mod)",
      "mutated_line": "inverse.append(-inverse[mod % i] * (mod // i) * mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) * mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "inverse.append(-inverse[mod % i] * (mod // i) % mod)",
      "mutated_line": "inverse.append(-inverse[mod % i] * (mod // i) + mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) + mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[-1] * inverse[-1] * mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] * mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[-1] * inverse[-1] + mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] + mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, K + 1):",
      "mutated_line": "for i in range(1, K + 2):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 2):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, K + 1):",
      "mutated_line": "for i in range(1, K + 0):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 0):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, K + 1):",
      "mutated_line": "for i in range(1, K + 0):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 0):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(1, K + 1):",
      "mutated_line": "for i in range(1, K + -1):",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + -1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "mutated_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) * mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) * mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "mutated_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) + mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) + mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if r < 0 or r > n:",
      "mutated_line": "if r < 1 or r > n:",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 1 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if r < 0 or r > n:",
      "mutated_line": "if r < -1 or r > n:",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < -1 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if r < 0 or r > n:",
      "mutated_line": "if r < 1 or r > n:",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 1 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return g1[n] * g2[r] * g2[n - r] % mod",
      "mutated_line": "return g1[n] / g2[r] * g2[n - r] % mod",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] / g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return g1[n] * g2[r] * g2[n - r] % mod",
      "mutated_line": "return (g1[n] + g2[r]) * g2[n - r] % mod",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return (g1[n] + g2[r]) * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return g1[n] * g2[r] * g2[n - r] % mod",
      "mutated_line": "return g1[n] ** g2[r] * g2[n - r] % mod",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] ** g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "g1.append(g1[-1] * i % mod)",
      "mutated_line": "g1.append(g1[-1] / i % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] / i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "g1.append(g1[-1] * i % mod)",
      "mutated_line": "g1.append((g1[-1] + i) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append((g1[-1] + i) % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "g1.append(g1[-1] * i % mod)",
      "mutated_line": "g1.append(g1[-1] ** i % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] ** i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "inverse.append(-inverse[mod % i] * (mod // i) % mod)",
      "mutated_line": "inverse.append(-inverse[mod % i] / (mod // i) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] / (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "inverse.append(-inverse[mod % i] * (mod // i) % mod)",
      "mutated_line": "inverse.append((-inverse[mod % i] + mod // i) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append((-inverse[mod % i] + mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "inverse.append(-inverse[mod % i] * (mod // i) % mod)",
      "mutated_line": "inverse.append((-inverse[mod % i]) ** (mod // i) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append((-inverse[mod % i]) ** (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[-1] / inverse[-1] % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] / inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append((g2[-1] + inverse[-1]) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append((g2[-1] + inverse[-1]) % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[-1] ** inverse[-1] % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] ** inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "mutated_line": "result.append(cmb(N - K + 1, i, mod) / cmb(K - 1, i - 1, mod) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) / cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "mutated_line": "result.append((cmb(N - K + 1, i, mod) + cmb(K - 1, i - 1, mod)) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append((cmb(N - K + 1, i, mod) + cmb(K - 1, i - 1, mod)) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "mutated_line": "result.append(cmb(N - K + 1, i, mod) ** cmb(K - 1, i - 1, mod) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) ** cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return g1[n] * g2[r] * g2[n - r] % mod",
      "mutated_line": "return g1[n] * g2[r] * g2[n + r] % mod",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n + r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return g1[n] * g2[r] * g2[n - r] % mod",
      "mutated_line": "return g1[n] * g2[r] * g2[n * r] % mod",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n * r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "inverse.append(-inverse[mod % i] * (mod // i) % mod)",
      "mutated_line": "inverse.append(+inverse[mod % i] * (mod // i) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(+inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "inverse.append(-inverse[mod % i] * (mod // i) % mod)",
      "mutated_line": "inverse.append(-inverse[mod % i] * (mod / i) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod / i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "inverse.append(-inverse[mod % i] * (mod // i) % mod)",
      "mutated_line": "inverse.append(-inverse[mod % i] * (mod * i) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod * i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "g1.append(g1[-1] * i % mod)",
      "mutated_line": "g1.append(g1[+1] * i % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[+1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[+1] * inverse[-1] % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[+1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[-1] * inverse[+1] % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[+1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "mutated_line": "result.append(cmb(N - K - 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K - 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "mutated_line": "result.append(cmb((N - K) * 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb((N - K) * 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "mutated_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K + 1, i - 1, mod) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K + 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "mutated_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K * 1, i - 1, mod) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K * 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "mutated_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i + 1, mod) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i + 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "mutated_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i * 1, mod) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i * 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g1.append(g1[-1] * i % mod)",
      "mutated_line": "g1.append(g1[-2] * i % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-2] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g1.append(g1[-1] * i % mod)",
      "mutated_line": "g1.append(g1[-0] * i % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-0] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g1.append(g1[-1] * i % mod)",
      "mutated_line": "g1.append(g1[-0] * i % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-0] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g1.append(g1[-1] * i % mod)",
      "mutated_line": "g1.append(g1[--1] * i % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[--1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "inverse.append(-inverse[mod % i] * (mod // i) % mod)",
      "mutated_line": "inverse.append(-inverse[mod * i] * (mod // i) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod * i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "inverse.append(-inverse[mod % i] * (mod // i) % mod)",
      "mutated_line": "inverse.append(-inverse[mod + i] * (mod // i) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod + i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[-2] * inverse[-1] % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-2] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[-0] * inverse[-1] % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-0] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[-0] * inverse[-1] % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-0] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[--1] * inverse[-1] % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[--1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[-1] * inverse[-2] % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-2] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[-1] * inverse[-0] % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-0] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[-1] * inverse[-0] % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-0] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "g2.append(g2[-1] * inverse[-1] % mod)",
      "mutated_line": "g2.append(g2[-1] * inverse[--1] % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[--1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "mutated_line": "result.append(cmb(N + K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N + K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "mutated_line": "result.append(cmb(N * K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N * K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "mutated_line": "result.append(cmb(N - K + 2, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 2, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "mutated_line": "result.append(cmb(N - K + 0, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 0, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "mutated_line": "result.append(cmb(N - K + 0, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 0, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "mutated_line": "result.append(cmb(N - K + -1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + -1, i, mod) * cmb(K - 1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "mutated_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 2, i - 1, mod) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 2, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "mutated_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 0, i - 1, mod) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 0, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "mutated_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 0, i - 1, mod) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 0, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "mutated_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - -1, i - 1, mod) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - -1, i - 1, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "mutated_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 2, mod) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 2, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "mutated_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 0, mod) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 0, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "mutated_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 0, mod) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 0, mod) % mod)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - 1, mod) % mod)",
      "mutated_line": "result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - -1, mod) % mod)",
      "code": "def count_arrangements(N, K, mod=10 ** 9 + 7):\n\n    def cmb(n, r, mod):\n        if r < 0 or r > n:\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n    g1 = [1, 1]\n    g2 = [1, 1]\n    inverse = [0, 1]\n    for i in range(2, N + 1):\n        g1.append(g1[-1] * i % mod)\n        inverse.append(-inverse[mod % i] * (mod // i) % mod)\n        g2.append(g2[-1] * inverse[-1] % mod)\n    result = []\n    for i in range(1, K + 1):\n        result.append(cmb(N - K + 1, i, mod) * cmb(K - 1, i - -1, mod) % mod)\n    return result"
    }
  ]
}